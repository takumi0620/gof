<html><head><title>BUILDER</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/bui.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　複合オブジェクトについて、その作成過程を表現形式に依存しないものにすることにより、同じ作成過程で異なる表現形式のオブジェクトを生成できるようにする。</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　RTF（Rich Text Format ）文書変換フォーマットの読み取り部は、RTF を他のテキストフォーマットに変換できるようになっている。たとえば、ASCII テキストに変換したり、対話的な編集が可能になるようなテキストウィジェットに変換する。しかも、変換すべきフォーマットのすべてを事前に確定できるとは限らないので、読み取り部を修正することなく、新たに与えられたフォーマットへの変換が容易に行えるようにしておくことが望ましい。<br><font style="text-indent:10pt">　1つの方法としては、RTF を他のテキストフォーマットに変換するための  TextConverter オブジェクトを用意して、読み取り部のクラス RTFReader を構成すればよい。RTFReader オブジェクトが RTF の文書の構文解析を行い、その結果を TextConverter オブジェクトを使って変換する。つまり、RTFReader オブジェクトは RTF のトークン（プレインテキスト、または RTF 制御コード）を認識するたびに、TextConverter オブジェクトにそのトークンを変換するように要求を出す。TextConverter オブジェクトは、データ変換と特定のフォーマットでトークンを表現することに対して責任を持つ。<br><font style="text-indent:10pt">　TextConverter のサブクラスは、TextConverter クラスを特定のフォーマットと変換に特化したクラスである。たとえば、ASCIIConverter クラスでは、プレインテキスト以外への変換要求は無視するようになっている。一方、TeXConverter クラスは、テキスト内のスタイル情報を捉えて 　TEX 表現を作り出すための要求に応えられるようにオペレーションを実装している。また、TextWidgetConverter クラスは、ユーザがテキストを確認したり編集したりすることができるように、多くの要素からなるユーザインタフェースオブジェクトを作成する。<br><br><br><p align="center"><img src="img/pics/build096.gif" hspace="10"></p><br><br><br><font style="text-indent:10pt">　このような各種の変換クラスは、必要になるさまざまなオブジェクトを生成したり組み合わせたりする仕組みを持っており、それらを抽象インタフェースで隠ぺいしている。さらに、この変換クラスは、RTF の文書の構文解析を行う読み取り部から分離されている。<br><font style="text-indent:10pt">　Builder パターンは、こうした関係をすべて表現している。このパターンでは、各変換クラスを builder と呼び、読み取り部のクラスを director と呼ぶ。このパターンを使えば、テキストフォーマットの解釈を行うアルゴリズム（すなわち、RTF の文書の構文解析部）を、変換後のフォーマットをいかに作成し、表現するかという点から分離することができる。これにより、RTF の文書から別のテキスト表現を生成する場合にも、RTFReader クラスの構文解析アルゴリズムは再利用することができるようになる（RTFReader クラスを構成している TextConverter のサブクラスを変えるだけでよい）。</font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Builder パターンは、次のような場合に適用することができる。<br><br><ul><li>多くの構成要素からなるオブジェクトを生成するアルゴリズムを、構成要素自体やそれらがどのように組み合わされるのかということから独立にしておきたい場合。<br><br><li>オブジェクトの作成プロセスが、オブジェクトに対する多様な表現を認めるようにしておかなければならない場合。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/builder.gif" hspace="20"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Builder クラス</b>（TextConverter クラス）<ul><li>Product オブジェクトの構成要素を生成するための抽象化されたインタフェースを規定する。</ul><br><br><li><b>ConcreteBuilder クラス</b>（ASCIIConverter  クラス、TextConverter クラス、TextWidgetConverter クラス）<ul><li>Builder クラスのインタフェースを実装することで、Product オブジェクトの構成要素の生成や組み合わせを行う。<li>自身が生成する表現を定義し、管理する。<li>Product オブジェクトを取り出すためのインタフェースを提供する（たとえば、GetASCIIText オペレーション、GetTextWidget オペレーション）。</ul><br><br><li><b>Director クラス</b>（RTFReader クラス）<ul><li>Builder クラスのインタフェースを使って、オブジェクトを生成する。</ul><br><br><li><b>Product クラス</b>（ASCIIText クラス、TeXText クラス、TextWidget クラス）<ul><li>作成中の、多くの構成要素からなる複合オブジェクトを表す。ConcreteBuilder クラスは、Product オブジェクトの内部表現を作成し、また、それを組み立てる過程を定義している。<li>構成要素を定義するクラス、および構成要素を最終的な Product オブジェクトに組み合わせていくためのインタフェースを含んでいる。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px"><ul><li>クライアントは、Director オブジェクトを生成し、それが必要とする ConcreteBuilder オブジェクトを与える。<br><br><li>Director オブジェクトは、Product オブジェクトを作成するときには ConcreteBuilder オブジェクトに通知する。<br><br><li>ConcreteBuilderオブジェクトは、Director オブジェクトからの要求に従って Product オブジェクトに構成要素を追加する。<br><br><li>クライアントは、ConcreteBuilder オブジェクトから Product オブジェクトを取り出す。</ul><br><br><font style="text-indent:10pt">　次のインタラクションダイアグラムは、ConcreteBuilder オブジェクトと Director オブジェクトがクライアントと協調する様子を示している。<br><br><br><p align="center"><img src="img/pics/build095.gif" hspace="10"></p><br><br><br></font></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Builder パターンの主な結果は次の通りである。<br><br><ol><li><b>Product オブジェクトの内部表現の変更が可能になる</b>。Builder クラスは、Director オブジェクトに対して Product オブジェクトを生成するための抽象インタフェースを提供している。この抽象インタフェースにより、Builder のオブジェクトは、Product オブジェクトの内部表現や内部構造を隠ぺいしている。また、Product オブジェクトがどのように組み立てられるのかということも隠ぺいしている。このように、Product オブジェクトは抽象インタフェースを通じて作成されるので、Product オブジェクトの内部表現を変更する場合には、新しい種類の ConcreteBuilder クラスを定義するだけでよい。<br><br><li><b>生成や表現のためのコードを局所化する</b>。Builder パターンは、複合オブジェクトの作成方法や表現方法をカプセル化することにより、モジュール度を向上させている。クライアント側では、Product オブジェクトの内部構造を定義するクラスについて知る必要はないし、そのようなクラスは Builder クラスのインタフェースには現れない。<br><font style="text-indent:10pt">　各 ConcreteBuilder クラスには、特定の Product オブジェクトの生成と組み立てを行うためのすべてのコードが含まれている。そのようなコードを一度書いておくと、別の Director オブジェクトが同じ構成要素からなる Product オブジェクトを作成する場合に、それを再利用することができるようになる。先の RTF の例では、RTF 以外のフォーマットに対する読み取り部、たとえば SGMLReader クラスを定義して、これが SGML の文書から ASCIIText オブジェクトや TeXText オブジェクトや TextWidget オブジェクトを生成する際に、同じ TextConverter のオブジェクトを使うことができるようになる。<br><br><li><b>Product オブジェクトの作成過程をより細かくコントロールできるようになる</b>。Product オブジェクトを一度に作成するパターンとは違い、Builder パターンでは Director オブジェクトのコントロールのもとで、Product オブジェクトを段階的に作成する。作成を終了したときに、Director オブジェクトはそれを ConcreteBuilder オブジェクトから取り出す。したがって、Builder クラスのインタフェースは、生成に関する他のパターンに比べて Product オブジェクトの作成過程を反映したものになっている。これにより、作成過程、そして、結果的には Product オブジェクトの内部構造を、より細かくコントロールすることができるようになる。</ol></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　抽象クラス Builder では、Director オブジェクトから生成要求が出される可能性があるすべての構成要素に対して、オペレーションを定義しておくのが一般的である。これらのオペレーションはデフォルトでは何も行わない。各 ConcreteBuilder クラスが、生成する構成要素に対するオペレーションのみをオーバーライドする。<br><font style="text-indent:10pt">　考慮すべき実装上の問題を以下にまとめる。<br><br><ol><li><b>生成と組み立てのインタフェース。</b>ConcreteBuilder クラスは、Product オブジェクトを段階的に作成する。ゆえに、Builder クラスのインタフェースは、あらゆる種類の ConcreteBuilder クラスでの Product オブジェクトの作成に適用できるように、十分に一般的でなければならない。<br></font><font style="text-indent:10pt">　生成と組み立てのプロセスをどのようにモデル化するのかということも重要な設計上の問題である。生成要求の結果を、それまでに得られているProductオブジェクトに単純に追加していくだけのモデルで十分な場合が多い。RTF の例では、 ConcreteBuilder クラスは、それまでに変換したテキストに対して、次のトークンを変換して追加するようになっている。<br><font style="text-indent:10pt">　しかし、場合によっては、すでに作成されている Product オブジェクトの一部にアクセスする必要があるかもしれない。「サンプルコード」の節であげる迷路の例では、MazeBuilder クラスは、それまでに作成された部屋にドアを追加するというインタフェースを持っている。別の例として、構文解析木のように、ボトムアップに作成される木構造をあげることもできる。この場合には、ConcreteBuilder オブジェクトは Director オブジェクトに子ノードを返し、そして、親ノードを作る際にそれらは再び ConcreteBuilder オブジェクトに渡されることになる。<br><br><li><b>なぜProductオブジェクトは抽象クラスを必要としないのか。</b>多くの場合、ConcreteBuilder クラスにより作成される Product オブジェクトには、さまざまな表現のものが存在するので、異なる Product オブジェクトに共通の親クラスを作るメリットは少ない。RTF の例では、ASCIIText オブジェクトと TextWidget オブジェクトとの間に共通のインタフェースは存在しないだろうし、その必要もない。適切な ConcreteBuilder オブジェクトを使って Director オブジェクトを構成するのはクライアントである場合が多いので、クライアントは Builder のどの具象サブクラスが使われているのかを知ることができ、それに応じて Product オブジェクトを適切に扱うことができる。<br><br><li><b>Builderクラスのメソッドをデフォルトで空にしておく。</b>C++で実装する場合には、Builder クラスのメソッドを意図的に純粋仮想メンバ関数として宣言しないようにする。その代わりに、これらを空のメソッドとして定義しておき、必要な場合にのみクライアントにオーバーライドさせるようにする。</ol></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　MazeBuilder クラスのインスタンスを引数として取るように、CreateMaze メンバ関数（92ページ）を修正してみよう。<font style="text-indent:10pt">　MazeBuilder クラスでは、迷路を作成するために次のようなインタフェースを定義する。<br><br><pre>    class MazeBuilder {    public:        virtual void BuildMaze() { }        virtual void BuildRoom(int room) { }        virtual void BuildDoor(int roomFrom, int roomTo) { }            virtual Maze* GetMaze() { return 0; }    protected:        MazeBuilder();    };</pre><br><br><font style="text-indent:10pt">　このインタフェースでは、(1) 迷路、(2) 部屋（部屋番号が与えられる）、(3) 部屋と部屋の間のドア、という3種類の構成要素を作成することができる。GetMaze オペレーションは、クライアントに迷路を返す。MazeBuilder のサブクラスは、自身が作成する迷路を返すようにこのオペレーションをオーバーライドする。<br><font style="text-indent:10pt">　MazeBuilder クラスの迷路作成オペレーションはすべてデフォルトで空に定義される。これらは、導出クラスが必要なメソッドだけをオーバーライドできるようにするために、純粋仮想関数としては宣言されない。<br><font style="text-indent:10pt">　この MazeBuilder クラスのインタフェースを基にして、メンバ関数 CreateMazeを、MazeBuilder オブジェクトをパラメータとして取るように修正することができる。<br><br><pre>    Maze* MazeGame::CreateMaze (MazeBuilder&amp; builder) {        builder.BuildMaze();            builder.BuildRoom(1);        builder.BuildRoom(2);        builder.BuildDoor(1, 2);            return builder.GetMaze();    }</pre><br><br><font style="text-indent:10pt">　このコードを元のコードと比較してみよう。MazeBuilder オブジェクトが、Maze クラスの内部表現（すなわち、部屋、壁、ドアを定義するクラス）や、迷路を完成させるためにそれらの構成要素がどのように組み合わされるのかを隠ぺいしている点に注意してほしい。そこでは、部屋やドアを表現するクラスについては推測できるかもしれないが、壁を定義するクラスについては推測不可能だろう。これにより、迷路の表現を変更しても、MazeBuilder クラスのクライアントを変更する必要はないので、変更は容易になる。<br><font style="text-indent:10pt">　生成に関する他のパターンと同様に、Builder パターンは MazeBuilder クラスが定義するインタフェースを使うことで、オブジェクトがどのように生成されるのかを隠ぺいしている。これは、異なる種類の迷路を作成する場合に MazeBuilder クラスを再利用できることを意味している。次の CreateComplexMaze オペレーションはその例である。<br><br><pre>    Maze* MazeGame::CreateComplexMaze (MazeBuilder&amp; builder) {        builder.BuildRoom(1);        // ...        builder.BuildRoom(1001);            return builder.GetMaze();    }</pre><br><br><font style="text-indent:10pt">　MazeBuilder クラスは迷路そのものを作るのではなく、迷路作成のためのインタフェースを定義しているにすぎないことに注目してほしい。そこでは、便宜上、空の実装が主に定義されており、MazeBuilder のサブクラスで、実際の作業が定義される。<br><font style="text-indent:10pt">　サブクラス StandardMazeBuilder は、単純な迷路を作成するように実装されている。ここでは、変数- currrentMaze に、作成中の迷路が保持されている。<br><br><pre>    class StandardMazeBuilder : public MazeBuilder {    public:        StandardMazeBuilder();            virtual void BuildMaze();        virtual void BuildRoom(int);        virtual void BuildDoor(int, int);            virtual Maze* GetMaze();    private:        Direction CommonWall(Room*, Room*);        Maze* _currentMaze;    };</pre><br><br><font style="text-indent:10pt">　CommonWall オペレーションは、2つの部屋がどの面で壁を共有しているのかを明確にするためのユーティリティオペレーションである。<br><font style="text-indent:10pt">　StandardMazeBuilder クラスのコンストラクタでは、- currentMaze を単に初期化するだけである。<br><br><pre>    StandardMazeBuilder::StandardMazeBuilder () {        _currentMaze = 0;    }</pre><br><br><font style="text-indent:10pt">　BuildMaze オペレーションでは、他のオペレーションにより組み立てられ、最終的に GetMaze オペレーションによりクライアントに返される Maze オブジェクトを生成する。<br><br><pre>    void StandardMazeBuilder::BuildMaze () {        _currentMaze = new Maze;    }        Maze* StandardMazeBuilder::GetMaze () {        return _currentMaze;    }</pre><br><br><font style="text-indent:10pt">　BuildRoom オペレーションでは、Room オブジェクトを生成して、そのまわりに壁を作成する。<br><br><pre>    void StandardMazeBuilder::BuildRoom (int n) {        if (!_currentMaze->RoomNo(n)) {            Room* room = new Room(n);            _currentMaze->AddRoom(room);                room->SetSide(North, new Wall);            room->SetSide(South, new Wall);            room->SetSide(East, new Wall);            room->SetSide(West, new Wall);        }    }</pre><br><br><font style="text-indent:10pt">　2つの部屋の間にドアを作るために、StandardMazeBuilder クラスはそれらの部屋を Maze オブジェクトの中から取り出して、どの面で隣接しているのかを見つけ出す。<br><br><pre>    void StandardMazeBuilder::BuildDoor (int n1, int n2) {        Room* r1 = _currentMaze->RoomNo(n1);        Room* r2 = _currentMaze->RoomNo(n2);        Door* d = new Door(r1, r2);            r1->SetSide(CommonWall(r1,r2), d);        r2->SetSide(CommonWall(r2,r1), d);    }</pre><br><br><font style="text-indent:10pt">　クライアントは StandardMazeBuilder クラスとともに CreateMaze オペレーションを利用することにより、迷路を作成することができる。<br><br><pre>    Maze* maze;    MazeGame game;    StandardMazeBuilder builder;        game.CreateMaze(builder);    maze = builder.GetMaze();</pre><br><br><font style="text-indent:10pt">　StandardMazeBuilder クラスのオペレーションすべてを Maze クラス内で定義して、Maze クラスに迷路を作成させることもできただろう。しかし、Maze クラスを小さくしておくことで理解や修正が容易になるという利点があり、また、StandardMazeBuilder クラスは Maze クラスから容易に分離することもできる。もっとも重要なことは、この2つを分離しておくことにより、部屋、壁、ドアに対して、異なるクラスを使ってさまざまな MazeBuilder クラスを作れるようになるという点である。<br><font style="text-indent:10pt">　一風変わった MazeBuilder のサブクラスとして、CountingMazeBuilder クラスを考えることができる。これは迷路を作成するのではなく、構成要素ごとにそれまでに作成した数を数えておくというものである。<br><br><pre>    class CountingMazeBuilder : public MazeBuilder {    public:        CountingMazeBuilder();            virtual void BuildMaze();        virtual void BuildRoom(int);        virtual void BuildDoor(int, int);        virtual void AddWall(int, Direction);            void GetCounts(int&amp;, int&amp;) const;    private:        int _doors;        int _rooms;    };</pre><br><br><font style="text-indent:10pt">　このコンストラクタではカウンタ変数の初期化を行い、また、他のオペレーション（MazeBuilder クラスのオペレーションをオーバーライドする）で、そのカウントアップを行う。<br><br><pre>    CountingMazeBuilder::CountingMazeBuilder () {        _rooms = _doors = 0;    }        void CountingMazeBuilder::BuildRoom (int) {        _rooms++;    }        void CountingMazeBuilder::BuildDoor (int, int) {        _doors++;    }        void CountingMazeBuilder::GetCounts (        int&amp; rooms, int&amp; doors    ) const {        rooms = _rooms;        doors = _doors;    }</pre><br><br><font style="text-indent:10pt">　次のコードは、クライアントがどのように CountingMazeBuilder オブジェクトを使うことになるのかを示している。<br><br><pre>    int rooms, doors;    MazeGame game;    CountingMazeBuilder builder;        game.CreateMaze(builder);    builder.GetCounts(rooms, doors);        cout &lt;&lt; "The maze has "         &lt;&lt; rooms &lt;&lt; " rooms and "         &lt;&lt; doors &lt;&lt; " doors" &lt;&lt; endl;</pre></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　RTF の変換部への適用例は、ET++［WGM88］から採用した。そのテキスト作成部は、RTF フォーマットで保存されているテキストを処理するために builder を用いている。<br><font style="text-indent:10pt">　Builder パターンは Smalltalk-80［Par90］ではよく使われている。たとえば、次のようなものがある。<br><br><ul><li>コンパイラサブシステム内の Parser クラスは、ProgramNodeBuilder オブジェクトから構成される Director クラスである。Parser オブジェクトは、文法上の構文を認識するたびに、ProgramNodeBuilder オブジェクトに通知を送る。構文解析が終了するときに、Parser オブジェクトは、ProgramNodeBuilder オブジェクトに対して、それまでに作成した構文解析木を要求し、それをクライアントに返す。<br><br><li>ClassBuilder クラスは、Class オブジェクトがサブクラスを生成する場合に利用する builder である。この場合、Class オブジェクトは、Director オブジェクトであり、Product オブジェクトでもある。<br><br><li>ByteCodeStream クラスは、バイト配列としてメソッドのコンパイルされたコードを生成する builder である。これは、生成される複合オブジェクトがバイト配列として表現されており、Smalltalk の普通のオブジェクトではないという点で、Builder パターンの標準的な使われ方とは異る。しかし、ByteCodeStream クラスのインタフェースは builder として典型的であり、ゆえに、ByteCodeStream クラスを、プログラムを composite として表現する別のクラスに容易に置き換えることができる。</ul><br><br><font style="text-indent:10pt">　適応型通信環境におけるサービス構成フレームワークでは、実行時にサーバへと結合されるネットワークサービス要素を生成するために、builder を用いている［SS94］。そこでは、構成要素はLALR（1）構文解析部により解析される構成言語を使って記述される。構文解析部は、サービス要素への情報追加を builder 上のオペレーションを使って行う。この場合には、構文解析部が Director オブジェクトになっている。</font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="01.html" target="down">Abstract Factory パターン</a>: このパターンは、複合オブジェクトを作成するという点で Builder パターンに類似している。主な違いは、Builder パターンでは複合オブジェクトを段階的に作成していく過程に焦点をあてているのに対して、<a href="01.html" target="down">Abstract Factory パターン</a>では部品の集合を強調している（それが単純であっても複雑であっても）という点である。Builder パターンでは、Product オブジェクトを最終段階で返すことになるが、<a href="01.html" target="down">Abstract Factory パターン</a>では即座に返す。<br><font style="text-indent:10pt">　<a href="08.html" target="down">Composite パターン</a>: builder は、しばしば composite を作成する。</font></font><br><br><br></body></html>