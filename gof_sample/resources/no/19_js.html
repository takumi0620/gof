<html><head><title>java sample code</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><img src="img/00/java.gif" hspace="10"><font style="margin-left:40px"><p><font style="text-indent:10pt">　Java 版サンプルコードでは、Java 1.1 のイベントモデルに従って Observer パターンを適用する。</font><br><font style="text-indent:10pt">　Java 1.1 イベントモデルではしばしば、&lt;Observer&gt; が通知と共に受け取るオブジェクトは &lt;ConcreteSubject&gt; ではなく、java.util.EventObject のサブクラスのインスタンスである。しかしこのサンプルコードでは &lt;Subject&gt; を java.util.EventObject のサブクラスとすることで、通知と共に &lt;ConcreteSubject&gt; を渡している。</font><p><hr><pre>import java.util.EventObject;import java.util.Enumeration;import java.util.Vector;/* *  Subject * *  役割：&lt;Subject&gt; */public abstract class Subject extends EventObject {    public Subject() {        // EventObject 自身を event source に指定するための処理。        //        // 非常に危ういハック。EventObject のコンストラクタの実        // 装に依存している。継承のこうした使い方は、プログラマ        // ーをオブジェクト指向の暗黒面に引き込む。        super("");        source = this; // EventObject で定義するメンバ変数    }    public void addClockTickListener(ClockTickListener listener) {        // この実装では同じ &lt;Observer&gt; を二度登録した場合、それに対し        // 一度に二回通知が行く        _listeners.addElement(listener);    }    public void removeClockTickListener(ClockTickListener listener) {        _listeners.removeElement(listener);    }    public void notifyListener() {        Enumeration en = _listeners.elements();        while (en.hasMoreElements()) {            ((ClockTickListener)en.nextElement()).clockTicked(this);        }    }    private Vector _listeners = new Vector();}/* *  ClockTickListener * *  役割：&lt;Observer&gt; */public interface ClockTickListener {    public void clockTicked(Subject theChangedSubject);}/* *  ClockTimer * *  役割：&lt;ConcreteSubject&gt; */public class ClockTimer extends Subject {    public ClockTimer() {        // ...    }    public int getHour() {        // ...    }    public int getMinute() {        // ...    }    public int getSecond() {        // ...    }    public void tick() {        // 時間を計るための内部状態を更新する        // ...        notifyListener();    }}/* *  DigitalClock * *  役割：&lt;ConcreteObserver&gt; */public class DigitalClock extends java.applet.Applet                          implements ClockTickListener {    public DigitalClock(ClockTimer s) {        _subject = s;        _subject.addClockTickListener(this);    }    protected void finalize() {        _subject.removeClockTickListener(this);    }    public void clockTicked(Subject theChangedSubject) {        if (theChangedSubject == _subject) {            draw();        }    }    public void draw() {        // &lt;Subject&gt; から新たな値を取得する        int hour = _subject.getHour();        int minute = _subject.getMinute();        // ...などなど        this.paint(this.getGraphics());    }    public void paint(java.awt.Graphics g) {        // デジタル時計を描く    }    private ClockTimer _subject;}/* *  AnalogClock * *  役割：&lt;ConcreteObserver&gt; */public class AnalogClock extends java.applet.Applet                         implements ClockTickListener {    public AnalogClock(ClockTimer s) {        _subject = s;        _subject.addClockTickListener(this);    }    protected void finalize() {        _subject.removeClockTickListener(this);    }    public void clockTicked(Subject theChangedSubject) {        if (theChangedSubject == _subject) {            draw();        }    }    public void draw() {        // &lt;Subject&gt; から新たな値を取得する        int hour = _subject.getHour();        int minute = _subject.getMinute();        // ...などなど        this.paint(this.getGraphics());    }    public void paint(java.awt.Graphics g) {        // アナログ時計を描く    }    private ClockTimer _subject;}</pre><p></font></body></html>