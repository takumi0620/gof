<html><head><title>ABSTRACT FACTORY</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/abs.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　互いに関連したり依存し合うオブジェクト群を、その具象クラスを明確にせずに生成するためのインタフェースを提供する。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Kit</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Motif や Presentation Manager などの、複数の look-and-feel 規格をサポートしているユーザインタフェースツールキットについて考えよう。look-and-feel 規格が異なると、スクロールバー、ウィンドウ、ボタンのようなユーザインタフェース部品（ウィジェット）の表示や振る舞いが異なってくる。別の look-and-feel 規格に容易に変更できるようにするためには、特定の規格のウィジェットに関するプログラムをアプリケーションに直接書くことは避けなければならない。また、特定の規格に依存するクラスをアプリケーション内でインスタンス化することも、後の変更に困難をきたすことになる。<br><font style="text-indent:10pt">　この問題は、各種の基本ウィジェットを生成するためのインタフェースを宣言した抽象クラス WidgetFactory を定義することにより、解決することができる。また、各種のウィジェットについて抽象クラスを作成し、その具象クラスで特定の look-and-feel 規格のもとでの実装を与える。WidgetFactory クラスのインタフェースには、ウィジェットの抽象クラスごとに対応するオブジェクトを返すようなオペレーションが含まれている。クライアントは、ウィジェットのインスタンスを得るためにこのオペレーションを使う。このとき、クライアントはウィジェットの具象クラスを把握しておく必要がないため、その時点での look-and-feel 規格には依存しないで済むようになる。</font></font><br><br><p align="center"><img src="img/pics/abfac109.gif" hspace="20"></p><br><br><font style="margin-left:40px;text-indent:10pt">　この方法では、look-and-feel 規格ごとに WidgetFactory の具象サブクラスが存在し、このサブクラスで個々の look-and-feel 規格に対して適切なウィジェットを生成するオペレーションの実装が行われる。たとえば、MotifWidgetFactory クラスの CreateScrollBar オペレーションでは、Motif のスクロールバーが生成されるし、PMWidgetFactory クラスの CreateScrollBar オペレーションでは、Presentation Manager のスクロールバーが生成される。クライアントは、WidgetFactory クラスが提供するインタフェースを通してウィジェットを生成するので、特定の look-and-feel 規格のウィジェットを実装しているクラスについて把握しておく必要はなくなる。つまり、クライアントは、抽象クラスで定義されたインタフェースに処理を委ねるので、特定の具象クラスとは関係する必要がないということである。<br><font style="text-indent:10pt">　WidgetFactory クラスは、ウィジェットの具象クラス間の依存関係も規定する。たとえばMotifでは、スクロールバーはボタンやテキストエディタとともに使われなければならないといった制約が、MotifWidgetFactory クラスを利用する結果として自動的に規定されることになる。</font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Abstract Factory パターンは、以下のような場合に有効である。<br><br><ul><li>システムを部品の生成、組み合わせ、表現の方法から独立にすべき場合。<br><br><li>部品の集合が複数存在して、その中の1つを選んでシステムを構築する場合。<br><br><li>一群の関連する部品を常に使用しなければならないように設計する場合。<br><br><li>部品のクラスライブラリを提供する際に、インタフェースだけを公開して、実装は非公開にしたい場合。</ul></font><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/abfac108.gif"></p></font><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>AbstractFactory クラス </b>（WidgetFactory クラス）<ul><li>AbstractProduct のオブジェクトを生成するオペレーションのインタフェースを宣言する。</ul><br><li><b>ConcreteFactory クラス </b>（MotifWidgetFactory クラス、PMWidgetFactory クラス）<ul><li>ConcreteProduct オブジェクトを生成するオペレーションを実装する。</ul><br><li><b>AbstractProduct クラス </b>（Window クラス、ScrollBar クラス）<ul><li>部品ごとにインタフェースを宣言する。</ul><br><li><b>ConcreteProduct クラス </b>（MotifWindow クラス、MotifScrollBar クラス）<ul><li>対応する ConcreteFactory オブジェクトで生成される部品オブジェクトを定義する。<li>AbstractProduct クラスのインタフェースを実装する。</ul><br><li><b>Client クラス</b><ul><li>AbstractFactory クラスと AbstractProduct クラスで宣言されたインタフェースのみを利用する。</ul></ul></font><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>普通、ConcreteFactory クラスのインスタンスは実行時に生成される。そして、このインスタンスでは、特定の実装を持つ ConcreteProduct オブジェクトが生成される。別の実装を持つ ConcreteProduct オブジェクトを生成したいときには、 Client オブジェクトは別の ConcreteFactory クラスのインスタンスを生成しなければならない。<br><br><li>Abstract Factory パターンでは、部品オブジェクトの生成を ConcreteFactory クラスで定義している。</ul></font><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Abstract Factory パターンの特徴をまとめておく。<br><br><ol><li><b>具象クラスを局所化する。</b>Abstract Factory パターンでは、アプリケーションが生成するオブジェクトのクラスをプログラマが制御できるようにする。部品オブジェクトが生成される際の責任分担や過程が隠ぺいされているので、Client オブジェクトを、実装上のクラスから分離することができる。Client オブジェクトは、各インスタンスを抽象インタフェースを通して操作する。さらに、部品クラスの名前は ConcreteFactory クラスの実装の中に局所化されているので、それらが Client クラスのコード中で用いられることはない。<br><br><li><b>部品の集合を容易に変更できるようになる。</b>ConcreteFactory クラスは、アプリケーション内で、インスタンス化される際に1回現れるだけなので、ConcreteFactory オブジェクトの変更は容易になる。ConcreteFactory オブジェクトを変更するだけで、異なる部品の集合でシステムを構成することができる。つまり、ConcreteFactory オブジェクトは、必要とされるすべての部品オブジェクトを生成するため、ConcreteFactory オブジェクトを変更することで部品の集合を一度に変えることができるのである。ユーザインタフェースの例では、Motif のウィジェットから Presentation Manager のウィジェットへの切り替えが、対応する ConcreteFactory オブジェクト同士を入れ替えて、オブジェクトを再生成するだけで可能になる。<br><br><li><b>部品間の無矛盾性を促進する。</b>ある集合内の部品オブジェクトが協調して機能を実現するように設計されているときに、アプリケーションが別の集合に属するオブジェクト同士を一緒に利用することがないようにしておくのは重要である。Abstract Factory パターンを使えば、この制約を容易に実現できる。<br><br><li><b>新たな種類の部品に対応することが困難である。</b>新たな種類の部品に対応できるように Abstract Factory パターンを拡張することは容易ではない。なぜならば、AbstractFactory クラスのインタフェースは生成される部品の集合を固定しているからである。新たな種類の部品への対応は、インタフェースの修正が必要になるために、AbstractFactory クラスだけでなくそのすべてのサブクラスを修正しなければならなくなる。「実装」の節で、この問題に対する1つの解決策について議論する。</ol></ol></font><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br></font><font style="margin-left:40px;text-indent:10pt">　Abstract Factory パターンを実装するために、次のような役に立つテクニックがある。<br><br><ol><li><b><a href="05.html" target="down">Singleton パターン</a>を利用する。</b>典型的なアプリケーションでは、部品の集合ごとに ConcreteFactory クラスのインスタンスを1つしか必要としない。したがって、通常では ConcreteFactory クラスを <a href="05.html" target="down">Singleton パターン</a>を使って実装することが最良の方法になる。<br><br><li><b>部品を生成する。</b>AbstractFactory クラスでは、部品を生成するためのインタフェースが宣言されるだけであり、実際の生成は ConcreteProduct クラスに任されている。これを実現するためによく用いる方法は、各部品について factory method（<a href="03.html" target="down">Factory Method パターン</a>を参照）を定義する方法である。ConcreteFactory クラスは、各部品について factory method をオーバーライドすることにより、どの部品を使用するのかを明確にする。この方法は単純ではあるが、生成すべき部品の集合間にわずかな相違点しか存在しない場合でも、集合ごとに ConcreteFactory クラスを定義しておく必要がある。部品の集合が多数存在する場合には、<a href="04.html" target="down">Prototype パターン</a>を使って ConcreteFactory クラスを実装することができる。このとき、ConcreteFactory オブジェクトは集合内の各部品についての原型となるインスタンス（ prototype ）とともに初期化され、新たな部品の生成は prototype の複製を作ることで行う。prototype をうまく利用することで、生成する部品の集合ごとに ConcreteFactory クラスを用意しなくても済むようになる。<br><font style="text-indent:10pt">　Smalltalk を使って、prototype を用いた ConcreteFactory クラスを実装する方法を示す。ConcreteFactory クラスは、複製すべき prototype を格納する partCatalog クラスと呼ばれる辞書を持っている。make : メソッドでは、辞書中の prototype を検索して複製を作る。<br><br><pre>    make: partName        ^ (partCatalog at: partName) copy</pre><br><br><font style="text-indent:10pt">　ConcreteFactory クラスには、partCatalog オブジェクトに部品を追加するためのメソッドもある。<br><br><pre>    addPart: partTemplate named: partName        partCatalog at: partName put: partTemplate</pre><br><br><font style="text-indent:10pt">　また、ConcreteFactory オブジェクトに prototype を追加する際には、他と識別できる名前が与えられる。<br><br><pre>    aFactory addPart: aPrototype named: #ACMEWidget</pre><br><br><font style="text-indent:10pt">　クラスをオブジェクトとして扱うことのできる言語（たとえば、Smalltalk や Objective C など）では、prototype を用いたアプローチに変化をつけることが可能になる。これらの言語では、クラスを1種類の部品のみを生成する退化した ConcreteFactory オブジェクトとして考えることができる。ConcreteFactory オブジェクトの中では、ConcreteProduct オブジェクトを生成するクラスを、prototype のように変数内に格納しておくことができる。格納されたクラスが、 ConcreteFactory オブジェクトに代わって新たなインスタンスを生成する。新たな ConcreteFactory クラスを定義する必要のある場合には、サブクラス化ではなく、 ConcreteFactory クラスのインスタンスを新たなクラスで初期化すればよい。先の純粋な prototype を用いたアプローチは実装言語に依存しないものであるが、これは言語の特徴を生かしたアプローチである。<br><font style="text-indent:10pt">　先にあげた prototype を用いた ConcreteFactory クラスの実装と同様に、クラスを用いた ConcreteFactory クラスも、インスタンス変数 partCatalog を持つ。ただしこの場合には、複製の基になる prototype を格納する代わりに、部品のクラスを格納することになる。したがって、make: メソッドは次のようになる。<br><br><pre>    make: partName        ^ (partCatalog at: partName) new</pre><br><br><li><b>拡張が可能なように定義する。</b>AbstractFactory クラスでは、通常、生成する部品ごとにオペレーションを定義する。部品の種類はオペレーションのシグニチャの中にコード化される。新しい種類の部品を追加すると、AbstractFactory クラスのインタフェースと、それに依存するすべてのクラスを修正しなければならなくなる。<br><font style="text-indent:10pt">　拡張性を考慮してより柔軟な設計にするために（後に述べるようにトラブルの原因になる可能性があるが）、オブジェクトを生成するオペレーションにパラメータを付加する。このパラメータは、生成されるオブジェクトの種類を指定するもので、クラス識別子、整数値、文字列など、オブジェクトの種類を特定できるものであれば何でもよい。この方法では、AbstractFactory クラスには、生成する部品の種類を示すパラメータを取る Make オペレーションがあればよい。先に説明した prototype を用いたアプローチとクラスに基づくアプローチのいずれに対しても、この方法を適用することができる。<br><font style="text-indent:10pt">　この方法は、C++のような静的に型付けされる言語よりも、Smalltalk のような動的に型付けされる言語で容易に適用することができる。C++を使うときには、すべてのオブジェクトが同じ抽象基底クラスを持つ場合か、要求を出すクライアントにより部品オブジェクトが正しい型に安全に変換できる場合にのみ、適用することができる。<a href="03.html" target="down">Factory Method パターン</a>の「実装」の節で、このようなパラメータ化されたオペレーションをC++でどのように実装するのかを説明する。<br><font style="text-indent:10pt">　型変換の必要がない場合でも、本来の問題はそのまま残る。すなわち、すべての部品が、戻り値の型により与えられる同一の抽象化されたインタフェースを備えた形でクライアントに返される。したがって、クライアントは、部品のクラスに関して区別をしたり、安全な仮定を置くことが不可能になる。もし、クライアントがサブクラスに特有のオペレーションを実行したくても、抽象クラスのインタフェースを通してでは、それらを実行することはできない。クライアントはダウンキャストを（たとえばC++の dynamic-cast を使って）行うことができるかもしれないが、これは常に実行可能、または安全であるとは限らない。なぜならば、ダウンキャストは失敗する可能性があるからである。これは柔軟で拡張可能なインタフェースを提供する場合に常に問題になるトレードオフである。</ol></font></font></font></font></font></font></font></font></font><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　本章の最初に紹介した迷路を作成する問題に、Abstract Factory パターンを適用してみる。<br><font style="text-indent:10pt">　MazeFactory クラスは迷路の構成要素を作るためのもので、部屋や壁を作ったり、部屋の間にドアを作ったりする。これは、ファイルから迷路の作成計画を読み出して、それに従って迷路を作成していくプログラムにより使われることもあるだろう。ランダムに迷路を作成するプログラムによって使われることもあるだろう。迷路作成のプログラムでは、作りたい部屋、壁、ドアのクラスをプログラマが指定できるようにするために、MazeFactory オブジェクトを引数として取る。<br><br><pre>    class MazeFactory {    public:        MazeFactory();            virtual Maze* MakeMaze() const            { return new Maze; }        virtual Wall* MakeWall() const            { return new Wall; }        virtual Room* MakeRoom(int n) const            { return new Room(n); }        virtual Door* MakeDoor(Room* r1, Room* r2) const            { return new Door(r1, r2); }    };</pre><br><br><font style="text-indent:10pt">　メンバ関数 CreateMaze（92ページ）では、2つの部屋とその間のドアからなる小さな迷路を作成していることを思い出していただきたい。そのときには、使うクラスの名前をプログラム中に直接コーディングしていたので、迷路を別の構成要素を使って作成することが難しくなっていた。次に示す CreateMaze の改良版では、MazeFactory オブジェクトをパラメータに取ることで、この問題点を解決している。<br><br><pre>    Maze* MazeGame::CreateMaze (MazeFactory&amp; factory) {        Maze* aMaze = factory.MakeMaze();        Room* r1 = factory.MakeRoom(1);        Room* r2 = factory.MakeRoom(2);        Door* aDoor = factory.MakeDoor(r1, r2);            aMaze->AddRoom(r1);        aMaze->AddRoom(r2);            r1->SetSide(North, factory.MakeWall());        r1->SetSide(East, aDoor);        r1->SetSide(South, factory.MakeWall());        r1->SetSide(West, factory.MakeWall());            r2->SetSide(North, factory.MakeWall());        r2->SetSide(East, factory.MakeWall());        r2->SetSide(South, factory.MakeWall());        r2->SetSide(West, aDoor);            return aMaze;    }</pre><br><br><font style="text-indent:10pt">　MazeFactory をサブクラス化することにより、魔法の迷路ゲームのための ConcreteFactory クラス、すなわち EnchantedMazeFactory クラスを作ることができる。 EnchantedMazeFactory クラスでは、メンバ関数のオーバーライドを行い、Room や Wall について別のサブクラスのインスタンスを返すようになっている。<br><br><pre>    class EnchantedMazeFactory : public MazeFactory {    public:        EnchantedMazeFactory();            virtual Room* MakeRoom(int n)  const            { return new EnchantedRoom(n, CastSpell()); }            virtual Door* MakeDoor(Room* r1, Room* r2)  const            { return new DoorNeedingSpell(r1, r2); }        protected:        Spell* CastSpell() const;    };</pre><br><br><font style="text-indent:10pt">　さて、迷路ゲームの変形として、部屋の中に爆弾がしかけられたゲームを作りたいとする。爆弾が爆発すると、壁が被害を受け、その他に被害が及ぶこともある。部屋に爆弾があるかどうかや、爆弾が爆発したかどうかを記録するために、Room のサブクラスを作ることになる。さらに、爆弾による壁の被害を記録するために Wall のサブクラスも必要になる。これらを、RoomWithBomb クラス、BombedWall クラスと呼ぶことにする。<br><font style="text-indent:10pt">　最後に、MazeFactory のサブクラスである BombedMazeFactory を爆弾付き迷路ゲーム用の迷路作成のために、壁の作成に BombedWall クラスを、部屋の作成に RoomWithBomb クラスをそれぞれ使うように定義する。このとき、BombedMazeFactory クラスは2つの関数をオーバーライドするだけでよい。<br><br><pre>    Wall* BombedMazeFactory::MakeWall () const {        return new BombedWall;    }        Room* BombedMazeFactory::MakeRoom(int n) const {        return new RoomWithABomb(n);    }</pre><br><br><font style="text-indent:10pt">　爆弾付き迷路ゲームを作成するためには、BombedMazeFactory オブジェクトを引数として CreateMaze オペレーションを呼び出すだけでよい。<br><br><pre>    MazeGame game;    BombedMazeFactory factory;        game.CreateMaze(factory);</pre><br><br><font style="text-indent:10pt">　同様に、魔法の迷路を作成するためには、EnchantedMazeFactory クラスのインスタンスを CreateMaze オペレーションに与えればよい。<br><font style="text-indent:10pt">　MazeFactory クラスは、単に factory method を集めたものになっているが、これは Abstract Factory パターンを実装するときにもっとも一般的な方法である。また、MazeFactory クラスは単なる抽象クラスではなく、AbstractFactory クラスであると同時に ConcreteFactory クラスにもなっている。これも、Abstract Factory パターンを簡単に適用するための一般的な実装方法である。MazeFactory クラスは、factory mehtod だけからなる具象クラスなので、サブクラスを作って、オーバーライドすることで、容易に新しい MazeFactory クラスを作ることができる。<br><font style="text-indent:10pt">　CreateMaze オペレーションは、部屋の側面を作るために SetSide オペレーションを使っている。BombedMazeFactory クラスを使って部屋を作る場合には、BombedWall クラスの壁を持つ RoomWithABomb オブジェクトから迷路が作成される。RoomWithABomb オブジェクトが、BombedWall クラスに特有の部分にアクセスしなければならない場合には、Wall*型の参照を BombedWall*型へとキャストしなければならない。引数が BombedWall オブジェクトである限り（BombedMazeFactory オブジェクトを使って壁を作っていれば、この点は保証される）、このダウンキャストは安全である。<br><font style="text-indent:10pt">　もちろん、Smalltalk のような動的に型付けされる言語では、このようなキャストは不要である。しかし、Wall のサブクラスを使うべきところで Wall を用いていたりすると、実行時にエラーが発生するかもしれない。壁を作るために Abstract Factroy パターンを利用すれば、決まった種類の壁が生成されるようになるので、そのような実行時のエラーを防ぐことができる。<br><font style="text-indent:10pt">　Smalltalk による MazeFactory クラスの実装を考えてみよう。このクラスは、作成すべきオブジェクトの種類をパラメータとして取るmake:メソッドを持つ。また、この具象クラスでは、生成する部品のクラスを格納するようになっている。<br><font style="text-indent:10pt">　まず、CreateMaze メソッドを Smalltalk で記述してみよう。<br><br><pre>    createMaze: aFactory        | room1 room2 aDoor |        room1 := (aFactory make: #room) number: 1.        room2 := (aFactory make: #room) number: 2.        aDoor := (aFactory make: #door) from: room1 to: room2.        room1 atSide: #north put: (aFactory make: #wall).        room1 atSide: #east put: aDoor.        room1 atSide: #south put: (aFactory make: #wall).        room1 atSide: #west put: (aFactory make: #wall).        room2 atSide: #north put: (aFactory make: #wall).        room2 atSide: #east put: (aFactory make: #wall).        room2 atSide: #south put: (aFactory make: #wall).        room2 atSide: #west put: aDoor.        ^ Maze new addRoom: room1; addRoom: room2; yourself</pre><br><br><font style="text-indent:10pt">　「実装」の節で述べたように、MazeFactoryクラスでは、辞書（生成する部品のクラスをキーとする）を与えるインスタンス変数partCatalogのみが必要になる。また、make:メソッドをどのように実装したかも思い出していただきたい。<br><br><pre>    make: partName        ^ (partCatalog at: partName) new</pre><br><br><font style="text-indent:10pt">　ところで、MazeFactory オブジェクトを生成し、それを使って CreateMaze メソッドを実装することができる。MazeGame クラスの createMazeFactory メソッドを使って、MazeFactory オブジェクトを生成する。<br><br><pre>    createMazeFactory        ^ (MazeFactory new            addPart: Wall named: #wall;            addPart: Room named: #room;            addPart: Door named: #door;            yourself)</pre><br><br><font style="text-indent:10pt">　BombedMazeFactory オブジェクトや EnchantedMazeFactory オブジェクトは、それぞれ別のクラスとキーを結び付けることによって生成される。たとえば、EnchantedMazeFactory オブジェクトの場合には、次のように生成される。</font></font></font></font></font></font><br><br><pre>    createMazeFactory        ^ (MazeFactory new            addPart: Wall named: #wall;            addPart: EnchantedRoom named: #room;            addPart: DoorNeedingSpell named: #door;            yourself)</pre><br><br></font></font></font></font></font></font></font></font></font></font><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　InterViews では、AbstractFactory クラスを表すために名前の語尾に“Kit”を付けて区別しており［Lin92］、look-and-feel 規格の特定のユーザインタフェースオブジェクトを生成するために WidgetKit クラスや DialogKit クラスが提供されている。また、指定されたレイアウトに従ってオブジェクトの組み合わせを生成する LayoutKit クラスも提供されている。たとえば、横向きや縦向きといった文書の配置方向に応じて、レイアウトの際に必要になるオブジェクトの組み合わせは異なる。<br><font style="text-indent:10pt">　ET++［WGM88］では、X Window や SunView といった異なるウィンドウシステム間での移植性を提供するために、Abstract Factory パターンを用いている。抽象基底クラス WindowSystem では、ウィンドウシステムのリソースを表すオブジェクトを生成するためのインタフェース（MakeWindow、MakeFont、MakeColor など）を定義している。具象サブクラスでは、特定のウィンドウシステムに対して、そのインタフェースを実装する。ET++では、この具象サブクラスのインスタンスを実行時に生成する。</font></font></font></font></font></font></font></font></font></font><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="03.html" target="down">Factory Method パターン</a>、<a href="04.html" target="down">Prototype パターン</a>: AbstractFactory クラスは、しばしば factory method を使って実装されるが、<a href="04.html" target="down">Prototype パターン</a>を使って実装することも可能である。<br><font style="text-indent:10pt">　<a href="05.html" target="down">Singleton パターン</a>: ConcreteFactory オブジェクトは、しばしば、Singleton オブジェクトである。<br><br><br></body></html>