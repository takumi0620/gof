<html><head><title>COMMAND</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/comm.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　要求をオブジェクトとしてカプセル化することによって、異なる要求や、要求からなるキューやログにより、クライアントをパラメータ化する。また、取り消し可能なオペレーションをサポートする。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Action、Transaction</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　ときには、要求により呼び出されるオペレーションや要求を受信するオブジェクトについては何もわからないまま、オブジェクト群に要求を発行する必要がある。たとえば、ユーザインタフェースツールキットには、ユーザからの入力に反応して要求を実行するボタンやメニューのようなオブジェクトがある。しかし、ツールキットはボタンやメニューの中で、直接、要求を実装することはできない。なぜならば、どのオブジェクトでどのようなことがなされなければならないかを知っているのは、そのツールキットを使うアプリケーションだけだからである。ツールキットの設計者は、要求を受信するオブジェクトや実行されるオペレーションについて知ることはできない。<br><font style="text-indent:10pt">　Command パターンは、要求自身をオブジェクトにすることにより、ツールキットのオブジェクトが、仕様化されていないアプリケーションオブジェクトの要求を作成できるようにする。このオブジェクトは、他のオブジェクトと同様に、保存したり、オブジェクト間でのやりとりに使うことができる。このパターンでキーとなるのは、抽象クラス Command である。そこでは、オペレーションを実行するためのインタフェースが宣言されている。もっとも簡単な形としては、このインタフェースに、抽象化した Execute オペレーションを入れておく。受信オブジェクトをインスタンス変数に保持し、要求を呼び出す Execute オペレーションに対して実装を与えることにより、Command の具象サブクラスが受信オブジェクトとアクションの組を明らかにする。受信オブジェクトには、要求を実行するために必要な知識がある。 <br><br><br><p align="center"><img src="img/pics/comma081.gif"></p><br><br><br><font style="text-indent:10pt">　メニューは Command オブジェクトを使って容易に実装することができる。Menu オブジェクトの中の各選択肢は、MenuItem クラスのインスタンスである。Application クラスは、このような Menu オブジェクトと MenuItem オブジェクトをユーザインタフェースの他の部分とともに生成する。Application クラスは、ユーザが開いた Document オブジェクトについても管理している。<br><font style="text-indent:10pt">　Application クラスは、MenuItem の各オブジェクトに対して Command の具象サブクラスのインスタンス（総称して command と呼ぶ）を結び付ける。ユーザが MenuItem オブジェクトを選択すると、そのオブジェクトは関連する command に対して Execute を呼び出し、それがオペレーションを実行する。このとき、MenuItem オブジェクトは Command のどのサブクラスを使っているのかについては知らない。Command のサブクラスでは、要求を受信するオブジェクトを保存しておき、そのオブジェクトに対して、1つ以上のオペレーションの呼び出しを行う。<br><font style="text-indent:10pt">　たとえば、PasteCommand クラスは、クリップボードから Document オブジェクトへのテキストのペーストをサポートする。PasteCommand オブジェクトには、要求を受信するオブジェクトとして Document オブジェクトが初期化の際に与えられる。Execute オペレーションは、Document オブジェクトに対して Paste オペレーションの呼び出しを行う。<br><br><br><p align="center"><img src="img/pics/comma078.gif"></p><br><br><br><font style="text-indent:10pt">　OpenCommand クラスの Execute オペレーションはこれとは異なる。それは、ユーザに書類名の入力を促し、対応する Document オブジェクトを生成し、その Document オブジェクトを受け手である Application オブジェクトに追加してから、その Document オブジェクトに対して Open オペレーションの呼び出しを行う。<br><br><br><p align="center"><img src="img/pics/comma079.gif"></p><br><br><br><font style="text-indent:10pt">　MenuItem オブジェクトは、ときには一連の command 群に対して Execute オペレーションを呼び出す必要がある。たとえば、ページを通常サイズでセンタリングするための MenuItem オブジェクトは、CenterDocumentCommand オブジェクトと NormalSizeCommand オブジェクトから構成することができる。このように command をつなぎ合わせるのは一般的なので、MenuItem オブジェクトが複数の command に対して Execute オペレーションの呼び出しを行うことができるように、MacroCommand クラスを定義する。MacroCommand クラスは Commandの 具象サブクラスで、一連の command に対して Execute オペレーションの呼び出しを行う。MacroCommand クラスは、それを構成している各 command が受信オブジェクトを持っているので、それ自身は明示的に受信オブジェクトを持つことはない。<br><br><br><p align="center"><img src="img/pics/comma080.gif"></p><br><br><br><font style="text-indent:10pt">　それぞれの例において、オペレーションを呼び出すオブジェクトと、オペレーションを実行するための知識を持っているオブジェクトを、Command パターンがいかに分離しているかに注目してほしい。これにより、ユーザインタフェースを設計する際に大いに柔軟性が得られることになる。たとえば Application クラスは、ユーザインタフェースの一部としてメニューとプッシュボタンを提供する際に、Menu オブジェクトと PushButton オブジェクトに Command の具象サブクラスのインスタンスを共有させるようにすることができる。また、command を動的に入れ替えることもできる。これは状況依存のメニューを実装するのに便利である。また、複数の command を合成することにより、コマンドスクリプトをサポートすることもできる。以上は、要求を出すオブジェクトはその出し方だけを知っていればよく、その要求がどのように実行されるのかを知っている必要がないために可能になることである。</font></font></font></font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のような場合に Command パターンを使用することができる。<br><br><ul><li>先にあげた MenuItem オブジェクトのように、実行する動作によりオブジェクトをパラメータ化したい場合。手続き型言語では、そのようなパラメータ化をコールバック関数を使って表現する。すなわち、コールバック関数を、呼び出してほしいところに登録しておく、という形になる。Command パターンでは、そのようなコールバック関数の代わりにオブジェクトを使う。<br><br><li>要求を明確にし、順番に並べ、実行するのをそれぞれ別々に行いたい場合。command は、元の要求とは独立に存在し続ける。もし、要求を最終的に受信するオブジェクトをアドレス空間とは独立な方法で表現できるならば、command を別のプロセスに移してそこで要求を実行させることもできる。<br><br><li>要求の取り消しをサポートしたい場合。Command クラスの Execute オペレーションでは、command での処理の結果を再び元の状態に戻すことができるように、状態を保存するようにしておくことができる。その場合 Command クラスには、インタフェースとして、直前の Execute オペレーションの呼び出しの結果を元に戻す Unexecute オペレーションを追加しておかなければならない。実行される command は、履歴リストの中にたくわえられる。取り消しや再実行は、このリスト内を前後に移動しながら、Unexecute オペレーションや Execute オペレーションの呼び出しを行うことにより、何度でも実行できる。<br><br><li>システムがクラッシュしたときにコマンドを再度実行できるように、ログの更新をサポートしたい場合。Command クラスのインタフェースにロードとセーブのオペレーションを備えておくことで、更新を永続的にログに記録しておくことができる。クラッシュからの復旧に際しては、ログに記録された command 群をディスクからロードして、それらに対して Execute オペレーションの呼び出しを再度行う。<br><br><li>プリミティブなオペレーションを基に作られた高度なオペレーションによりシステムを構造化したい場合。そのような構造は、情報システムのトランザクションにとっては一般的である。一般に、1つのトランザクションは、データに対する更新手続きの集合をカプセル化している。Command パターンはこのようなトランザクションをモデル化する方法を与える。command は共通のインタフェースを持っているので、すべてのトランザクションを同じように呼び出すことができるようになる。このパターンにより、新しいトランザクションを追加してシステムを拡張することも容易になる。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/command.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Command クラス</b><ul><li>オペレーションを実行するためのインタフェースを宣言する。</ul><br><br><li><b>ConcreteCommand クラス</b> （PasteCommand クラス、OpenCommand クラス）<ul><li>Receive rオブジェクトとアクションの間のつながりを定義する。<li>Execute オペレーションを、Receiver オブジェクトに対して該当するオペレーションの呼び出しを行うように実装する。</ul><br><br><li><b>Client クラス </b>（Application クラス）<ul><li>ConcreteCommand オブジェクトを生成して、それに対する Receiver オブジェクトを設定する。</ul><br><br><li><b>Invoker クラス </b>（MenuItem クラス）<ul><li>command に要求を実行するように依頼する。</ul><br><br><li><b>Receiver クラス</b> （Document クラス、Application クラス）<ul><li>要求を実現するためにオペレーションをいかに実行するのかを知っている。任意のクラスが Receiver になり得る。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Client オブジェクトは、ConcreteCommand オブジェクトを生成して、それに対する Receiver オブジェクトを明確にする。<br><br><li>Invoker オブジェクトは、ConcreteCommand オブジェクトを保持している。<br><br><li>Invoker オブジェクトは、ConcreteCommand オブジェクトに対して Execute オペレーションの呼び出しを行うことにより要求を出す。これを取り消し可能にする場合、ConcreteCommand オブジェクトは、実際に取り消しを行うときのために、Execute オペレーションが呼び出される前の状態をセーブしておく。<br><br><li>ConcreteCommand オブジェクトは、Reciever オブジェクトに対して要求を実行するオペレーションの呼び出しを行う。</ul><br><br><font style="text-indent:10pt">　次のダイアグラムは、これらのオブジェクト間でのやりとりを表しており、Command オブジェクトが Invoker オブジェクトと Receiver オブジェクト（さらに実行される要求）を分離する様子が説明されている。 <br><br><br><p align="center"><img src="img/pics/comma077.gif"></p></font></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Command パターンを適用すると、次のような結果が得られる。<br><br><ol><li><b>Command パターンは、オペレーションを呼び出すオブジェクトと実行するオブジェクトを分離する。</b><br><br><li><b>command は補助的なオブジェクトではない。</b>それらは他のオブジェクトと同様に操作され、拡張される。<br><br><li><b>複数の command を合成することができる。</b>たとえば、前に述べた MacroCommand クラスをあげることができる。一般に、command の合成は、Composite クラスのインスタンスである。<br><br><li><b>既存のクラスに変更を加える必要がないので、新しい command を容易に追加できる。</b></ol></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Command パターンを実装する際には、次の問題を考えなければならない。<br><br><ol><li><b>command をどれだけインテリジェントにするか。</b>command が備える能力には幅を持たせることができる。極端な場合、単に Receiver オブジェクトと要求を実行するアクションを結び付けるだけのものから、Receiver オブジェクトにはまったく委譲することなくそれ自身ですべてを実装してしまうものまで考えることができる。後者は、command を既存のクラスとは独立に定義したいとき、または適当な Receiver オブジェクトが存在しないとき、または command が暗黙のうちに Receiver オブジェクトを知っているときに有効である。たとえば、新たに別のアプリケーションウインドウを生成する command には、それを別の Receiver オブジェクトに委譲せずに、自身で生成する能力を持たせてしまうだろう。上述の極端な場合の中間に位置するものとして、Receiver オブジェクトを動的に見つけ出すための知識を備えた command を考えることができる。<br><br><li><b>取り消しと再実行を支援する。</b>command に、実行をさかのぼる方法を与える（たとえば、Unexecute オペレーションや Undo オペレーションを持たせる）ことにより、その取り消しや再実行を支援することができる。この場合、ConcreteCommand クラスは、そのための状態を別に保存しておく必要がある。この状態には次の3点が含まれる。<br><br><ul><li>要求に反応して実際にオペレーションを実行する Receiver オブジェクト。<br><br><li>Receiver オブジェクトで実行されるオペレーションの引数。<br><br><li>要求を扱うことにより Receiver オブジェクト内で値が変化する場合、その元の値。Receiver オブジェクトは、自身を元の状態に戻すことができるようなオペレーションを command に対して提供しなければならない。</ul><br><br><font style="text-indent:10pt">　1回前に実行されたオペレーションの取り消しを可能にするためには、アプリケーションは常に最後に実行された command を保存しておく必要がある。複数回前に実行されたオペレーションの取り消しと再実行を可能にするためには、アプリケーションには、それまでに実行された command の履歴リストが必要である。履歴リストの最大の長さが、取り消しや再実行を何回前までさかのぼって実行できるかという回数を決定することになる。履歴リストはそれまでに実行された command の列を保存している。リスト中をさかのぼりながら1つ1つの command に対して取り消しのオペレーションを呼び出すことにより、実行結果を元に戻していくことができる。リスト中を時系列順に移動しながら、1つ1つの command に対して Execute オペレーションを呼び出すことにより、コマンドの再実行ができる。<br><font style="text-indent:10pt">　取り消し可能な command は、それを履歴リストに入れる前にコピーしておくべきだろう。なぜなら、そのようにすることで command は、たとえば MenuItem オブジェクトからの最初の要求を実行した後でも、引き続き MenuItem オブジェクトからの次の要求を実行できるようになるからである。ただし、コピーをする場合には、呼び出し時の状態を正確に識別できるようにしておく必要がある。<br><font style="text-indent:10pt">　たとえば、選択された複数のオブジェクトを削除する DeleteCommand オブジェクトは、それが実行される際には、削除されるオブジェクトの集合を保持しておかなければならない。そして、DeleteCommand オブジェクトは実行のたびにコピーされ、そのコピーされたオブジェクトが履歴リストに入れられていく。もし、command の状態が実行により変化しないのであれば、コピーをする必要はない（履歴リストには、command への参照のみが入れられればよい）。履歴リストに入れられる前のコピー元となる command オブジェクトは、prototype として活動する（<a href="05.html" target="down">Prototype パターン</a>を参照）。<br><br><li><b>取り消しの過程で、エラーが蓄積されていくのを避ける。</b>取り消し/再実行のメカニズムに信頼性と意味の不変性を保証する際に、ヒステリシスが問題になる。command の実行、取り消し、再実行をたびたび行うと、結果的にアプリケーションの状態が元の値とかけ離れたものになり、エラーが蓄積されていくということが起こり得る。したがって、command には、アプリケーションのオブジェクトを確実に元の状態に戻せるように、より多くの情報を保持させる必要がある。command が他のオブジェクトの内部に踏み入ることなくこの情報にアクセスできるように、<a href="18.html" target="down">Memento パターン</a>を適用することができる。<br><br><li><b>C++のテンプレートを使う。</b>（1）取り消しができない、または（2）引数を必要としない command については、アクションと Receiver オブジェクトごとに Command のサブクラスを生成することを避けるために、C++のテンプレートを使うことができる。この方法については、「サンプルコード」の節で紹介する。</ol></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　ここでは、「動機」の節であげた Command クラスの実装を、C++のコードで簡略化して紹介する。OpenCommand クラス、PasteCommand クラス、MacroCommand クラスを定義する。まず最初に、抽象クラス Command は次のようになる。<br><br><pre>    class Command {    public:        virtual ~Command();            virtual void Execute() = 0;    protected:        Command();    };</pre><br><br><font style="text-indent:10pt">　OpenCommand クラスは、ユーザにより名前を設定されたドキュメントを開く。OpenCommand オブジェクトには、コンストラクタで Application オブジェクトへのポインタが渡される。AskUser オペレーションは、ユーザに開きたいドキュメントの名前を入力するように促す。<br><br><pre>    class OpenCommand : public Command {    public:        OpenCommand(Application*);            virtual void Execute();    protected:        virtual const char* AskUser();    private:        Application* _application;        char* _response;    };        OpenCommand::OpenCommand (Application* a) {        _application = a;    }        void OpenCommand::Execute () {        const char* name = AskUser();            if (name != 0) {            Document* document = new Document(name);            _application->Add(document);            document->Open();        }    }</pre><br><br><font style="text-indent:10pt">　PasteCommand クラスには、Receiver オブジェクトとして Document オブジェクトが渡されなければならない。Receiver オブジェクトは、PasteCommand クラスのコンストラクタにパラメータとして与えられる。<br><br><pre>    class PasteCommand : public Command {    public:        PasteCommand(Document*);            virtual void Execute();    private:        Document* _document;    };        PasteCommand::PasteCommand (Document* doc) {        _document = doc;    }        void PasteCommand::Execute () {        _document->Paste();    }</pre><br><br><font style="text-indent:10pt">　取り消しできない、または引数を必要としない簡単な command については、Receiver オブジェクトをパラメータ化するためにクラステンプレートを使うことができる。そのような command のために、テンプレートサブクラス SimpleCommand を定義する。SimpleCommand クラスは Receiver の型によりパラメータ化され、Receiver オブジェクトとアクション（メンバ関数へのポインタとして保持している）を結び付けている。<br><br><pre>    template &lt;class Receiver>    class SimpleCommand : public Command {    public:        typedef void (Receiver::* Action)();            SimpleCommand(Receiver* r, Action a) :            _receiver(r), _action(a) { }            virtual void Execute();    private:        Action _action;        Receiver* _receiver;    };</pre><br><br><font style="text-indent:10pt">　コンストラクタは、Receiver オブジェクトとアクションを対応するインスタンス変数の中に保存する。Execute オペレーションでは、Receiver オブジェクトに対してアクションの呼び出しを行うだけである。 <br><br><pre>   template &lt;class Receiver>    void SimpleCommand&ltReceiver>::Execute () {        (_receiver->*_action)();    }</pre><br><br><font style="text-indent:10pt">　MyClass クラスのインスタンスに対して Action オペレーションを呼び出す command を生成するためには、Client クラスでは次のように書く。<br><br><pre>    MyClass* receiver = new MyClass;    // ...    Command* aCommand =        new SimpleCommand&lt;MyClass>(receiver, &amp;MyClass::Action);    // ...    aCommand->Execute();</pre><br><br><font style="text-indent:10pt">　この解決策は、簡単な command に対してしか通用しないことに注意してほしい。Receiver オブジェクトだけではなく、引数や取り消しのための状態も考慮しなければならない複雑な commandは、Command のサブクラスとして定義しなければならない。<br><font style="text-indent:10pt">　MacroCommand クラスでは、一連の command を管理し、また command をこれに追加したりここから削除したりするオペレーションを提供する。各 command がすでに Receiver オブジェクトを定義しているので、MacroCommand クラスが独自に Receiver オブジェクトを持つ必要はない。<br><br><pre>    class MacroCommand : public Command {    public:        MacroCommand();        virtual ~MacroCommand();            virtual void Add(Command*);        virtual void Remove(Command*);            virtual void Execute();    private:        List&lt;Command*>* _cmds;    };</pre><br><br><font style="text-indent:10pt">　MacroCommand クラスにおいてキーとなるのは Execute オペレーションである。これは、管理している1つ1つの commandにExecute オペレーションを実行するようにメッセージを投げていく。<br><br><pre>    void MacroCommand::Execute () {        ListIterator&lt;Command*> i(_cmds);            for (i.First(); !i.IsDone(); i.Next()) {            Command* c = i.CurrentItem();            c->Execute();        }    }</pre><br><br><font style="text-indent:10pt">　MacroCommand クラスに Unexecute オペレーションを実装する際には、Execute オペレーションを実行したときとは逆の順番で command の Unexecute オペレーションが実行できなければならないことに注意してほしい。<br><font style="text-indent:10pt">　最後に、MacroCommand クラスに複数の command を管理するためのオペレーションを定義しなければならない。command を削除するのは MacroCommand クラスの責任である。<br><br><pre>    void MacroCommand::Add (Command* c) {        _cmds->Append(c);    }        void MacroCommand::Remove (Command* c) {        _cmds->Remove(c);    }</pre></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　おそらく、Command パターンの例が最初にあげられたのは Lieberman［Lie85］の論文においてであろう。MacApp［App89］は、取り消し可能なオペレーションを実装するために command の考え方を一般化させた。ET++［WGM88］、InterViews［LCI+92］、Unidraw［VL90］では、Command パターンの考え方に従ったクラスを定義している。InterViews では、Command クラスの機能を提供する抽象クラス Action を定義している。また、Command のサブクラスを自動的にインスタンス化することができる ActionCallback テンプレート（アクションメソッドによりパラメータ化されている）を定義している。<br><font style="text-indent:10pt">　THINK クラスライブラリ［Sym93b］でも、取り消し可能なアクションをサポートするために command を使っている。THINK においては、command は、Task オブジェクトと呼ばれている。Task オブジェクトは <a href="13.html" target="down">Chain Of Responsibility パターン</a>に沿って渡されていく。<br><font style="text-indent:10pt">　Unidraw の command は、メッセージのように振る舞うことができるという点が、他にはない特徴になっている。Unidraw の command は、それを解釈するために他のオブジェクトに送られるが、どのオブジェクトに送られるかにより解釈の結果は変化する。また、送られた先のオブジェクトでは、典型的には <a href="13.html" target="down">Chain Of Responsibility パターン</a>のようなより大きな構造の中の親オブジェクトに対して、その解釈を委譲することもある。したがって、Unidraw の command では、Receiver オブジェクトを保持しているというよりは、そのときどきで計算するようになっている。Unidraw の解釈メカニズムは、実行時の型情報を基にしている。<br><font style="text-indent:10pt">　Coplien は、関数のオブジェクトである functor をC++で実装する方法を述べている。functor の使用に際しては、関数呼び出しのオペレータ（operator（））をオーバーロードすることにより、透過性を実現している。Command パターンはこれとは異なっている。その中心は、Receiver オブジェクトと関数（すなわち、アクション）の関係を保持しておくことにあり、単に関数を保持しておくことにあるのではない。</font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="08.html" target="down">Composite パターン</a>: MacroCommand クラスを実装するために <a href="08.html" target="down">Composite パターン</a>を使うことができる。<br><font style="text-indent:10pt">　<a href="18.html" target="down">Memento パターン</a>: command がその実行結果を取り消すことができるように、状態を保存しておくことができる。<br><font style="text-indent:10pt">　<a href="05.html" target="down">Prototype パターン</a>: command を履歴リストに入れる前にコピーする場合、コピー元のオブジェクトは prototype として振る舞っている。</font></font></font><br><br><br></body></html>