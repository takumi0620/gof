<html><head><title>BRIDGE</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/bri.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　抽出されたクラスと実装を分離して、それらを独立に変更できるようにする。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Handle/Body</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　抽出されたクラスの実装方法がいくつか考えられる場合、これらを使い分けるために、通常は継承を用いる。抽出されたクラスへのインタフェースを抽象クラスで定義し、具象サブクラスでそれをさまざまな方法で実装する。しかし、この方法が常に十分に柔軟であるわけではない。継承は、実装を抽出されたクラスに対して永続的に結び付けるため、抽出されたクラスと実装を独立に変更、拡張、再利用するのが困難になる。<br><font style="text-indent:10pt">　ユーザインタフェースツールキットで抽出されている、移植可能なウィンドウのクラスの実装を考えてみよう。この抽出により、たとえば、X Window System と IBM の Presentation Manager の両方で動作するアプリケーションが記述できるようになっているのが望ましい。継承を用いることで、抽象クラス Window とそのサブクラス XWindow、PMWindow を定義することができる。これらのサブクラスでは、Window クラスのインタフェースをそれぞれのプラットフォームに対応して実装する。しかし、このアプローチには以下の2つの欠点がある。<br><br><ol><li>別の種類のウィンドウや新たなプラットフォームにも対応するようにウィンドウについて抽出されたクラスを拡張するには不都合である。Window のサブクラス IconWindow について考えてみよう。このクラスは Window クラスをアイコンに特化したものである。前記の2つのプラットフォームに対応する IconWindow クラスをサポートするためには、XIconWindow クラスと PMIconWindow クラスの2つの新たなクラスを実装しなければならない。さらに悪いことには、“すべての”種類のウィンドウに対して、2つずつ新たなクラスを定義していかなければならなくなるだろう。また、3つめのプラットフォームをサポートするためには、あらゆる種類のウィンドウに対して、そのプラットフォームに対応するサブクラスが新たに必要になる。<br><br><br><p align="center"><img src="img/pics/bridg098.gif"></p><br><br><br><li>クライアントのコードをプラットフォームに依存させる。クライアントがあるウィンドウを生成する場合、ある特定の実装を持つ具象クラスをインスタンス化する。たとえば、XWindow オブジェクトを生成することにより、Window クラスは X Window 用の実装に結び付けられる。すると、クライアントのコードは X Window 用の実装に依存するようになる。その結果、クライアントのコードを別のプラットフォームに移植するのが困難になる。<br><font style="text-indent:10pt">　クライアントは、具体的な実装には束縛されずにウィンドウを生成できるようにすべきである。つまり、プラットフォームに依存しているのはウィンドウの実装だけになるようにすべきである。ゆえに、クライアントのコードでは、特定のプラットフォームについて触れずにウィンドウをインスタンス化できるようにすべきである。</ol><br><font style="text-indent:10pt">　Bridge パターンでは、抽出されたウィンドウのクラスとその実装を別々のクラス階層に配置することでこれらの問題に対処している。下の図では、ウィンドウのインタフェースに関するクラス階層（Window クラス、IconWindow クラス、TransientWindow クラス）と、プラットフォームに特化したウィンドウの実装に関するクラス階層（WindowImp クラスを最上位のクラスとする）が示されている。たとえば、XWindowImp サブクラスは X Window System 用の実装を提供する。<br><br><br><p align="center"><img src="img/pics/bridg100.gif"></p><br><br><br><font style="text-indent:10pt">　Window のサブクラスのすべてのオペレーションが、WindowImp クラスのインタフェースで宣言されている抽象化されたオペレーションを用いて実装される。こうすることで、各ウィンドウの抽象を、さまざまなプラットフォームに特化した実装から分離する。この Window クラスと WindowImp クラスの間の関係を bridge と呼ぶ。なぜならば、bridge は抽出されたクラスとその実装とを橋渡ししているからである。bridge によってこれらを独立に変更できるようになる。</font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のような場合に、Bridge パターンを利用する。<br><br><ul><li>抽出されたクラスとその実装を永続的に結合することを避けたい場合。たとえば、実装を実行時に選択したり交換したりしなければならないときに、このような場合が起こり得る。<br><br><li>抽出されたクラスとその実装の両方を、サブクラスの追加により拡張可能にすべき場合。この場合、Bridge パターンを用いることで、抽出されたクラスに異なる実装を結合したり、それぞれを独立に拡張することが可能になる。<br><br><li>抽出されたクラスの実装における変更が、クライアントに影響を与えるべきではない場合。すなわち、クライアントのコードを再コンパイルしなくても済むようにすべき場合。<br><br><li>（C++で）抽出されたクラスの実装をクライアントから完全に隠ぺいしたい場合。C++では、クラスの内部表現はクラスのインタフェースで見ることができてしまう。<br><br><li>「動機」の節の最初の図に示されているように、サブクラスが増殖していくような継承を行う場合。この図のクラス階層は、1つのオブジェクトを2つの部分に分割する必要があることを示している。Rumbaugh は、このようなクラス階層を“ネスト化された一般化”［RBP+91］という言葉で呼んでいる。<br><br><li>（おそらく参照数を用いることにより）複数のオブジェクト間で実装を共有したい場合、そして、そのことをクライアントから隠しておきたい場合。Coplien の String クラス［Cop92］が1つの簡単な例である。この String クラスでは、複数のオブジェクトが同じ文字列の内部表現（StringRep オブジェクト）を共有している。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><font style="margin-left:40px;text-indent:10pt"><br><br><p align="center"><img src="img/pics/bridge.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Abstraction クラス</b> （Window クラス）<ul><li>抽出されたクラスのインタフェースを定義する。<li>mplementor 型のオブジェクトへの参照を保持する。</ul><br><br><li><b>RefinedAbstraction クラス</b> （IconWindow クラス）<ul><li>Abstraction クラスで定義されたインタフェースを拡張する。</ul><br><br><li><b>Implementor クラス</b> （WindowImp クラス）<ul><li>実装を行うクラスのインタフェースを定義する。このインタフェースは Abstraction クラスのインタフェースに正確に一致する必要はない。実際、この2つのインタフェースがまったく異なることもあり得る。典型的には、Implementor クラスのインタフェースはプリミティブなオペレーションのみを提供しており、Abstraction クラスは、これらのオペレーションを基にしてより高レベルのオペレーションを定義する。</ul><br><br><li><b>ConcreteImplementor クラス</b> （XWindowImp クラス、PMWindowImp クラス）<ul><li>Implementor クラスのインタフェースを実装する。具体的な実装について定義する。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Abstraction クラスは、クライアントからの要求を Implementor のオブジェクトへ転送する。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Bridge パターンを用いることで、次にあげる結果が得られる。<br><br><ol><li><b>インタフェースと実装を分離する。</b>実装はインタフェースへ永続的には結合されない。したがって、抽出されたクラスの実装を実行時に決定することができる。また、オブジェクトがその実装を実行時に変更することさえできるようになる。<br><font style="text-indent:10pt">　Abstraction クラスと Implementor クラスを分離することにより、実装に対するコンパイル時の依存性を取り除くこともできる。実装を行うクラスを変更しても、Abstraction クラスやそのクライアントの再コンパイルは必要ない。クラスライブラリがバージョン間でバイナリレベルの互換性を維持しなければならないときには、この特性が必要不可欠になる。<br><font style="text-indent:10pt">　さらに、この分離により階層化が促進され、システムがよりよく構造化されていくことになる。システムの上層部では、Abstraction クラスと Implementor クラスの2種類のみを知っていればよい。<br><br><li><b>拡張性を改善する。</b>Abstraction クラスの階層と Implementor クラスの階層を独立に拡張することができる。<br><br><li><b>クライアントから実装の詳細を隠ぺいする。</b>Implementor のオブジェクトの共有やそれに伴う参照数の管理機構のような実装の詳細が、クライアントに影響を及ぼさないようにする。</ol></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Bridge パターンを適用する際には、次にあげる実装上の問題点を考えなければならない。<br><br><ol><li><b>Implementor クラスが1つしか存在しない場合。</b>1つの実装しか存在しない場合は、抽象クラス Implementor を生成する必要はない。これは Bridge パターンが退化した場合である。つまりこの場合には、Abstraction クラスと Implementor クラスが一対一に関係している。それでも、クラスの実装上の変化がクライアントに影響を与えることがあってはならない場合（つまり、再コンパイルする必要をなくし、再リンクだけで十分にすべき場合）には、この分離は有効である。<br><font style="text-indent:10pt">　Carolan［Car89］はこの分離を“Cheshire Cat（チェシア猫）”という言葉で表現している。C++では、Implementor クラスのインタフェースを、クライアントには公開されないように私的なヘッダファイルで宣言する。これにより、クラスの実装をクライアントから完全に隠ぺいできるようになる。<br><br><li><b>正しい Implementor オブジェクトを生成する。</b>複数の種類の Implementor クラスが存在する場合、どの Implementor クラスをインスタンス化するのかを、いつ、どこで、どのようにして決定するのか。<br><font style="text-indent:10pt">　Abstraction クラスがすべての ConcreteImplementor クラスを知っている場合には、その Abstraction クラスのコンストラクタに渡されるパラメータに基づいて、それらの中から1つを決定しインスタンス化することができる。たとえば、コレクションクラスが複数の実装をサポートする場合には、コレクションに求められるサイズに基づいてどの実装を選択するかを決めることができる。また、コレクションが小さい場合にはリストによる実装が選択され、大きい場合にはハッシュテーブルによる実装が選択される。<br><font style="text-indent:10pt">　別のアプローチとして、最初にデフォルトの実装を選択しておき、後で必要に応じて変更するという方法もある。たとえば、コレクションがある閾値よりも大きくなると、大きなコレクションに適した実装に切り替える。<br><font style="text-indent:10pt">　決定を他のオブジェクトに完全に委譲するという方法もある。Window/WindowImp クラスの例では、プラットフォームに特化した部分のカプセル化だけが仕事である factory オブジェクト（ <a href="01.html" target="down">Abstract Factory パターン</a>を参照）を導入することができる。factory オブジェクトは、使用しているプラットフォームに対してどの WindowImp オブジェクトを生成すればよいのかを知っている。これにより、Window オブジェクトは factory オブジェクトに WindowImp オブジェクトの生成を依頼して、必要な WindowImp オブジェクトを返してもらうことになる。このアプローチの利点は、Abstraction クラスが Implementor クラスと直接結び付くことがないという点である。<br><br><li><b>Implementor のオブジェクトを共有する。</b>Coplien は、複数のオブジェクト間で実装を共有するために、C++でよく使われる Handle/Body の使用法について示した［Cop92］。Body オブジェクトは、それを参照している Handle クラスのオブジェクトの数を管理している。共有されている Body オブジェクトを Handle オブジェクトに割り当てるためのコードは、一般に次のようになる。<br><br><pre>    Handle&amp; Handle::operator= (const Handle&amp; other)  {        other._body->Ref();        _body->Unref();            if (_body->RefCount() == 0) {            delete _body;        }        _body = other._body;            return *this;    }</pre><br><br><li><b>多重継承を利用する。</b>インタフェースと実装を結合するために、C++では多重継承を用いることができる［Mar91］。たとえば、あるクラスは Abstraction クラスを公開で継承し、ConcreteImplementor クラスを私的に継承することができる。しかし、このアプローチでは静的な継承を用いるため、実装をインタフェースに永続的に結合してしまう。したがって、（少なくともC++では）多重継承を用いて本当の Bridge パターンを実現することはできない。</ol></font></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のC++のコードは、「動機」の節の Window/WindowImp クラスの例を実装したものである。Window クラスは、クライアントとなるアプリケーションに対して、ウィンドウを抽象化して定義している。<br><br><pre>    class Window {    public:        Window(View* contents);            // requests handled by window        virtual void DrawContents();            virtual void Open();        virtual void Close();        virtual void Iconify();        virtual void Deiconify();            // requests forwarded to implementation        virtual void SetOrigin(const Point&amp; at);        virtual void SetExtent(const Point&amp; extent);        virtual void Raise();        virtual void Lower();            virtual void DrawLine(const Point&amp;, const Point&amp;);        virtual void DrawRect(const Point&amp;, const Point&amp;);        virtual void DrawPolygon(const Point[], int n);        virtual void DrawText(const char*, const Point&amp;);        protected:        WindowImp* GetWindowImp();        View* GetView();        private:        WindowImp* _imp;        View* _contents; // the window's contents    };</pre><br><br><font style="text-indent:10pt">　Window クラスは WindowImp クラスへの参照を保持する。この抽象クラス WindowImp では、基にあるウィンドウシステムに対するインタフェースを宣言している。<br><br><pre>    class WindowImp {    public:        virtual void ImpTop() = 0;        virtual void ImpBottom() = 0;        virtual void ImpSetExtent(const Point&amp;) = 0;        virtual void ImpSetOrigin(const Point&amp;) = 0;            virtual void DeviceRect(Coord, Coord, Coord, Coord) = 0;        virtual void DeviceText(const char*, Coord, Coord) = 0;        virtual void DeviceBitmap(const char*, Coord, Coord) = 0;        // lots more functions for drawing on windows...    protected:        WindowImp();    };</pre><br><br><font style="text-indent:10pt">　Window のサブクラスでは、アプリケーションが使用するかもしれないさまざまな種類のウィンドウ、すなわちアプリケーションウィンドウ、アイコン、一時的なダイアログウィンドウ、ツールのパレットなどを、それぞれ定義する。<br><font style="text-indent:10pt">　たとえば ApplicationWindow クラスでは、保持している View クラスのインスタンスを描画するために DrawContents オペレーションが実装される。<br><br><pre>    class ApplicationWindow : public Window {    public:        // ...        virtual void DrawContents();    };        void ApplicationWindow::DrawContents () {        GetView()->DrawOn(this);    }</pre><br><br><font style="text-indent:10pt">　IconWindow クラスでは、表示されるアイコンのビットマップ名を保持し、<br><br><pre>    class IconWindow : public Window {    public:        // ...        virtual void DrawContents();    private:        const char* _bitmapName;    };</pre><br><br><font style="text-indent:10pt">　また、ウィンドウにビットマップを描画するために DrawContents オペレーションを実装する。<br><br><pre>    void IconWindow::DrawContents() {        WindowImp* imp = GetWindowImp();        if (imp != 0) {            imp->DeviceBitmap(_bitmapName, 0.0, 0.0);        }    }</pre><br><br><font style="text-indent:10pt">　他にもさまざまな種類の Window クラスが可能である。ダイアログウィンドウのための TransientWindow クラスは、それを生成したウィンドウと通信する必要があるかもしれない。そのため、そのウィンドウオブジェクトに対する参照を常に保持している。PaletteWindow クラスは、常に他のウィンドウ上に表示されるパレットを生成する。IconDockWindow クラスは、複数の IconWindow オブジェクトを管理し、表示の際にはそれらをきちんと整列する。<br><font style="text-indent:10pt">　Window クラスのオペレーションは、WindowImp クラスのインタフェースに基づいて定義される。たとえば、DrawRect オペレーションは、Point クラスのパラメータ2つから4つの点を抽出した後に、ウィンドウに長方形を描画する WindowImp クラスのオペレーションを呼び出す。<br><br><pre>    void Window::DrawRect (const Point&amp; p1, const Point&amp; p2) {        WindowImp* imp = GetWindowImp();        imp->DeviceRect(p1.X(), p1.Y(), p2.X(), p2.Y());    }</pre><br><br><font style="text-indent:10pt">　WindowImp の具象サブクラスでは、さまざまなウィンドウシステムをサポートしている。たとえば、XWindowImp クラスは X Window System をサポートする。<br><br><pre>    class XWindowImp : public WindowImp {    public:        XWindowImp();            virtual void DeviceRect(Coord, Coord, Coord, Coord);        // remainder of public interface...    private:        // lots of X window system-specific state, including:        Display* _dpy;        Drawable _winid;  // window id        GC _gc;           // window graphic context    };</pre><br><br><font style="text-indent:10pt">　また、Presentation Manager に対しては、PMWindowImp クラスを定義する。<br><br><pre>    class PMWindowImp : public WindowImp {    public:        PMWindowImp();        virtual void DeviceRect(Coord, Coord, Coord, Coord);            // remainder of public interface...    private:        // lots of PM window system-specific state, including:        HPS _hps;    };</pre><br><br><font style="text-indent:10pt">　これらのサブクラスは、WindowImp クラスのオペレーションをウィンドウシステムが提供しているプリミティブなオペレーションを使って実装する。たとえば、X Window System に対する DeviceRect オペレーションは次のようになる。<br><br><pre>    void XWindowImp::DeviceRect (        Coord x0, Coord y0, Coord x1, Coord y1    ) {        int x = round(min(x0, x1));        int y = round(min(y0, y1));        int w = round(abs(x0 - x1));        int h = round(abs(y0 - y1));        XDrawRectangle(_dpy, _winid, _gc, x, y, w, h);    }</pre><br><br><font style="text-indent:10pt">　また、Presentation Manager に対する実装は次のようになる。<br><br><pre>    void PMWindowImp::DeviceRect (        Coord x0, Coord y0, Coord x1, Coord y1    ) {        Coord left = min(x0, x1);        Coord right = max(x0, x1);        Coord bottom = min(y0, y1);        Coord top = max(y0, y1);            PPOINTL point[4];            point[0].x = left;    point[0].y = top;        point[1].x = right;   point[1].y = top;        point[2].x = right;   point[2].y = bottom;        point[3].x = left;    point[3].y = bottom;            if (            (GpiBeginPath(_hps, 1L) == false) ||            (GpiSetCurrentPosition(_hps, &amp;point[3]) == false) ||            (GpiPolyLine(_hps, 4L, point) == GPI_ERROR)  ||            (GpiEndPath(_hps) == false)        ) {            // report error            } else {            GpiStrokePath(_hps, 1L, 0L);        }    }</pre><br><br><font style="text-indent:10pt">　個々のウィンドウは、WindowImp のサブクラスの中からどのように適切なものを選択してそのインスタンスを得るのだろうか。この例では、Window クラスがその責任を負っていることにしよう。Window クラスの GetWindowImp オペレーションは、AbstractFactory（ <a href="01.html" target="down">Abstract Factory パターン</a>を参照）から正しいインスタンスを得る。AbstractFactory クラスは、すべてのウィンドウシステムごとに特有の点をすべて効果的にカプセル化している。<br><br><pre>    WindowImp* Window::GetWindowImp () {        if (_imp == 0) {            _imp = WindowSystemFactory::Instance()->MakeWindowImp();        }        return _imp;    }</pre><br><br><font style="text-indent:10pt">　WindowSystemFactory::Instance（）オペレーションは、1つのウィンドウシステムに特化したオブジェクトを作り出す ConcreteFactory オブジェクトを返す。簡単にするために、これを Singleton オブジェクトにし、さらに Window クラスが ConcreteFactory オブジェクトを直接アクセスできるようにした。</font></font></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　前記の Window クラスの例は、ET++［WGM88］から出してきたものである。ET++では、WindowImp クラスは WindowPort クラスと呼ばれ、XWindowPort クラスや SunWindowPort クラスなどのサブクラスを持っている。Window オブジェクトは、WindowSystem と呼ばれる AbstractFactory に要求することにより、プラットフォームに対応する ConcreteImplementor オブジェクトを生成する。この WindowSystem クラスは、フォント、カーソル、ビットマップなどのプラットフォームに特化したオブジェクトを生成するためのインタフェースを提供する。<br><font style="text-indent:10pt">　ET++の Window/WindowPort クラスの設計では、WindowPort オブジェクトの方でも Window オブジェクトへの参照を保持するように、Bridge パターンを拡張している。Implementor にあたる WindowPort クラスは、WindowPort クラスに特化したイベント（入力イベントの到着、ウィンドウサイズの変更など）を Window クラスへ知らせるために、この参照を使用している。<br><font style="text-indent:10pt">　Coplien［Cop92］と Stroustrup［Str91］は Handle クラスについて言及しており、いくつかの例をあげている。彼らの例では、文字列表現の共有や可変サイズのオブジェクトのサポートのようなメモリ管理問題が強調されている。しかし、Bridge パターンでは、抽出クラスと実装の独立した拡張をサポートすることに焦点が置かれている。<br><font style="text-indent:10pt">　libg++［Lea88］では、Set クラス、LinkedSet クラス、HashSet クラス、LinkedList クラス、HashTable クラスなどの共通のデータ構造を実装するクラスが定義されている。Set クラスは集合を定義している抽象クラスであり、LinkedList クラスと HashTable クラスは、それぞれリストやハッシュテーブルに対する ConcreteImplementor クラスである。LinkedSet クラスと HashSet クラスは、Set クラスの実装を表す ConcreteImplementor クラスであり、Set クラスと LinkedList クラスや HashTable クラスとの間の橋渡しをしている。この例は、抽象クラス Implementor が存在しない、Bridge パターンの退化した例である。<br><font style="text-indent:10pt">　NeXT の AppKit［Add94］では、画像の実装と表示に、Bridge パターンを用いている。画像はいくつかの異なる方法で表示することができる。画像にとって最適な表示は、表示デバイスの特性、特にその発色数や解像度に依存している。AppKitの支援がなければ、アプリケーションごとに、さまざまな環境下で、使用すべき実装を開発者が決定しなければならなかっただろう。<br><font style="text-indent:10pt">　開発者からこの手間を取り除くために、AppKit では NXimage/NXimageRep クラスによる bridge を提供している。NXImage クラスは画像を扱うインタフェースを定義している。画像の実装はインタフェースとは別に NXImageRep クラス階層で定義される。NXImageRep クラス階層には、NXEPSImageRep クラス、NXCachedImageRep クラス、NXBitMapImageRep クラスなどのサブクラスがある。NXImage クラスは複数の NXImageRep オブジェクトへの参照を扱う。もし画像の実装が複数存在すれば、NXImage クラスは、その時点の表示デバイスに対してもっとも適切な実装を選択する。また、NXImage クラスは、必要に応じて、ある実装を別の実装へ変換することもできる。NXImage クラスが NXImageRep のサブクラスによる実装を同時に複数保持できることは、この変形 Bridge パターンの興味深い面である。</font></font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="01.html" target="down">Abstract Factory パターン</a>: このパターンにより、Bridge パターンに基づくインスタンスの生成と構築を行うことができる。<br><font style="text-indent:10pt">　<a href="06.html" target="down">Adapter パターン</a>: このパターンは、関係のないクラス同士をつなぐことが目的である。このパターンは通常は設計が終わった後で適用される。それに対して、Bridge パターンは、抽出されたクラスと実装を独立に変更可能にするために設計の前段階で使われる。</font></font><br><br><br></body></html>