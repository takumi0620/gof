<html><head><title>STATE</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/sta.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　オブジェクトの内部状態が変化したときに、オブジェクトが振る舞いを変えるようにする。クラス内では、振る舞いの変化を記述せず、状態を表すオブジェクトを導入することでこれを実現する。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Objects for States</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　ネットワーク網を表す TCPConnection クラスを考える。TCPConnection オブジェクトは、数種類の状態（Established 状態、Listening 状態、Close 状態）のうちのどれか1つの状態をとり得る。このオブジェクトは、他のオブジェクトから要求を受け取ると、そのときの状態により異なる反応を示す。たとえば、Open 要求に対する振る舞いは、ネットワーク網が Close 状態にあるか、あるいは Established 状態にあるかにより変わる。State パターンでは、TCPConnection クラスが状態によりどのように異なる振る舞いを示すかについて述べる。<br><font style="text-indent:10pt">　このパターンでキーとなる考えは、TCPState クラスと呼ばれる抽象クラスを導入することである。このクラスは、ネットワーク網の状態を表し、異なる状態を表現するすべてのクラスに共通のインタフェースを宣言する。TCPState クラスのサブクラスでは、状態に依存した振る舞いを実装する。たとえば、TCPEstablished クラスでは TCPConnection クラスの Established 状態に特化した振る舞いを実装し、TCPClosed クラスでは TCPConnection クラスの Closed 状態に特化した振る舞いを実装する。<br><br><br><p align="center"><img src="img/pics/state-eg.gif"></p><br><br><br><font style="text-indent:10pt">　TCPConnection クラスは、TCP ネットワーク網の状態を表す状態オブジェクト（TCPState のサブクラスのインスタンス）を保持している。TCPConnection クラスは、状態に依存した要求はすべてこの状態オブジェクトに委譲する。その際、TCPConnection クラスは、ネットワーク網の状態に依存したオペレーションを実行するために TCPState のサブクラスのインスタンスを利用する。<br><font style="text-indent:10pt">　ネットワーク網の状態が変化するとき、TCPConnection オブジェクトは利用する状態オブジェクトを変更する。たとえば、ネットワーク網が Established 状態から Closed 状態に変化するとき、TCPConnection クラスは、利用するインスタンスを TCPEstablished クラスのインスタンスから TCPClosed クラスのインスタンスに変更する。</font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次に示すいずれかの場合に、State パターンを利用する。<br><br><ul><li>オブジェクトの振る舞いが状態に依存し、実行時にはオブジェクトがその状態により振る舞いを変えなければならない場合。<br><br><li>オペレーションが、オブジェクトの状態に依存した多岐にわたる条件文を持っている場合。この状態はたいてい1つ以上の列挙型の定数で表されており、たびたび複数のオペレーションに同じ条件構造が現れる。State パターンでは、1つ1つの条件分岐を別々のクラスに受け持たせる。これにより、オブジェクトの各状態を1つのオブジェクトとして扱うことができるようになる。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/state.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Contextクラス</b> （TCPConnection クラス）<ul><li>クライアントに必要なインタフェースを定義する。<li>状態を表す ConcreteState クラスのインスタンスを保持する。</ul><br><br><li><b>State クラス</b> （TCPState クラス）<ul><li>Context クラスの個々の状態に関する振る舞いをカプセル化するためのインタフェースを定義する。</ul><br><br><li><b>ConcreteState クラス</b> （TCPEstablished クラス、TCPListen クラス、TCPClosed クラス）<ul><li>Context クラスの1つの状態に関する振る舞いが実装される。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Context クラスは、状態に依存した要求を ConcreteState オブジェクトに委譲する。<br><br><li>Context オブジェクトは、要求を処理する ConcreteState オブジェクトに対して自身を引数として送る。これにより、ConcreteState オブジェクトは必要に応じて Context オブジェクトにアクセスできるようになる。<br><br><li>Context クラスは、初期の段階でクライアントに対するインタフェースになる。クライアントは、ConcreteState オブジェクトを持つ Context オブジェクトを構成する。ひとたび構成した後は、クライアントは ConcreteState オブジェクトを直接扱う必要がなくなる。<br><br><li>ある状態から別の状態にどのような状況で遷移するのかは、Context クラスあるいは ConcreteState クラスが決定する。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　State パターンは、次のような結果をもたらす。<br><br><ol><li><b>状態に依存した振る舞いを局所化し、状態ごとに振る舞いを分割する。</b>State パターンでは、ある状態に関する振る舞いを1つのオブジェクトにまとめている。状態に依存するコードはすべて State のサブクラスに記述するので、新しい状態や遷移は、新しいサブクラスを定義することにより簡単に追加することができる。<br><font style="text-indent:10pt">　一方、内部状態を定義するためにデータの値を使い、Context クラスのオペレーションにデータを明示的にチェックさせる方法がある。しかしこの方法では、Context クラスの実装に、似たような条件文やCASE文が散在することになる。新しい状態を追加すると複数のオペレーションを変更しなければならなくなり、保守を複雑にすることになる。<br><font style="text-indent:10pt">　State パターンは、このような問題を防ぐが、別の問題を新たに引き起こすかもしれない。個々の状態に対する振る舞いをStateのサブクラスに分配するため、クラスの数は増え、1つのクラスを利用する場合よりもコンパクトではなくなるという問題である。しかし、多くの状態が存在する場合には、このように分配することにより、実際に良い効果が得られる。なぜならば、もしこの方法を用いなければ、多数の条件文が必要になるからである。<br><font style="text-indent:10pt">　長い手続きや多数の条件文を含むコードは望ましくない。このようなコードは単調で理解しにくい傾向があり、コードの修正と拡張が難しくなる。State パターンでは、状態に依存したコードを構造化するためのより良い方法を提供する。状態遷移を決定するロジックは、単調な if 文や switch 文の中に与えられるのではなく、State のサブクラスに分配される。状態遷移とアクションを1つのクラスにカプセル化することにより、実行状態という概念を完全なオブジェクトの地位にまで引き上げることになる。これにより、コードは構造化され、意図をより明確にすることができる。<br><br><li><b>状態遷移を明確にする。</b>オブジェクトが単に内部データの値として状態を定義するとき、状態遷移を明確に表現することはできない。この場合には、単に変数への代入として表されるだけである。そこで、複数の状態に対して別々のオブジェクトを導入することによって遷移をより明確に表現できるようにする。また、これらのオブジェクトにより、Context クラスが矛盾した内部状態を持つのを防ぐことができるようになる。なぜなら状態遷移は、Context クラスの観点からは、単一の動作で実現されることになるからである。状態遷移は、複数の変数ではなく1つの変数（Context クラスが持つ State 型の変数）の内容を入れ替えることにより実現する［dCLF93］。<br><br><li><b>ConcreteState オブジェクトを共有することができる。</b>もし ConcreteState オブジェクトがインスタンス変数を持たないなら（つまり、ConcreteState オブジェクトが表す状態がその型で完全に表現される）、Context オブジェクト間で ConcreteState オブジェクトを共有することができる。このように共有するときには、ConcreteState オブジェクトは本質的には、intrinsic 状態を持たず振る舞いのみを持つ flyweight（<a href="11.html" target="down">Flyweight パターン</a>を参照）である。</ol></font></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　State パターンでは実装上のさまざまな問題をあげることができる。<br><br><ol><li><b>どのオブジェクトが状態遷移を定義するのか。</b>State パターンでは、どの構成要素が状態遷移の規準を定義するのかを特定していない。もし規準が固定化されるならば、状態遷移は Context クラス内ですべて実装することができる。しかし、State のサブクラス自身が次の状態と遷移の時期を特定できれば、一般的により柔軟で適切なものになる。この場合には、ConcreteState オブジェクトが Context クラスの状態を明示的に設定できるようにするために、Context クラスに新たにインタフェースを追加する必要がある。<br><font style="text-indent:10pt">　このように遷移のロジックを分散させることで、State の新しいサブクラスを定義することによるロジックの修正や拡張が容易になる。しかし、分散させることの欠点は、Stateのあるサブクラスが少なくとももう1つのサブクラスを知っていなければならない、ということである。これにより、サブクラス間に実装上の依存関係が入り込むことになる。<br><br><li><b>テーブルをベースにした代替案。</b>Cargill はC++ Programming Style［Car92］で、状態駆動のコードを構造化する別の方法を述べている。この方法では、入力を状態遷移にマッピングするテーブルを使用している。それぞれの状態について、テーブルは、考えられる入力の1つ1つを遷移後の状態にマッピングしている。このアプローチは、条件文のコード（State パターンの場合には仮想関数）をテーブル検索に改造したものと言える。<br><font style="text-indent:10pt">　テーブルの主な利点は、その規則性である。すなわち、プログラムコードを修正する代わりにデータを修正することにより、遷移の規準を変更することができるようになる。しかし、欠点として以下にあげる点がある。<br><br><ul><li>テーブル検索は、（仮想）関数コールに比べてしばしば非効率的である。<br><br><li>一定の表形式で遷移のロジックを記述することにより、遷移の規準が不明確になり、その結果、理解しにくくなる。<br><br><li>状態遷移に伴うアクションを加えることは、通常難しい。テーブルをベースにしたアプローチは、状態と遷移についてはカバーしているが、遷移の際に実行する計算も扱えるようにしなければならない。</ul><br><br><font style="text-indent:10pt">　テーブルをベースにした状態マシンと State パターンとの主な違いは、次のようにまとめることができる。State パターンは、状態に依存した振る舞いをモデル化する。一方、テーブルをベースにしたアプローチは、状態遷移を定義することに焦点をあてている。<br><br><li><b>State オブジェクトの生成と破壊。</b>実装において考慮すべき一般的なトレードオフは、次の2点である。(1) ConcreteState オブジェクトを、必要なときだけ生成し、その後破壊する。(2) 前もって ConcreteState オブジェクトを生成しておき、決してそれらを破壊しない。<br><font style="text-indent:10pt">　最初の選択は、実行時にどの状態に遷移することになるのかがわからず、かつ、Context インスタンスがそれほど状態を変えない場合に向いている。このアプローチは、利用しないオブジェクトを生成することを避ける。この点は、ConcreteState オブジェクトが多くの情報を記憶する場合に重要である。2番めのアプローチは、状態変化がひんぱんに起こり、ConcreteState オブジェクトを破壊することを避けたい場合（そのオブジェクトがすぐにまた必要になるから）に向いている。前もって一度オブジェクトを生成すれば、それらを破壊する必要はまったくない。しかしこのアプローチは、遷移するすべての状態に対して Context クラスが参照を持たなければならないので、不便である。<br><br><li><b>動的継承の利用。</b>特定の要求に対して振る舞いを変えることは、実行時にオブジェクトの属するクラスを変えることができれば実現できるだろう。しかし、これはほとんどのオブジェクト指向プログラミング言語では不可能である。ただし、例外的にこのようなメカニズムを持つ言語も存在する。それは、Self［US87］やその他の委譲ベースの言語である。これらの言語を利用すれば、State パターンを直接サポートすることができる。Self では、動的継承を実現するために、オブジェクトが他のオブジェクトに対してオペレーションを委譲することができるようになっている。委譲先のオブジェクトを実行時に変えることにより、効果的に継承構造を変えるようになっている。このメカニズムにより、オブジェクトは振る舞いを変え、さらに属するクラスを変えることができるようになる。</ol></ol></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次の例は、「動機」の節で述べた TCP 接続の例に対する C++のコードである。この例は、TCP プロトコルの簡易バージョンである。したがって、完全なプロトコルや TCP 接続のすべての状態を記述しているわけではない。<br><font style="text-indent:10pt">　まず、TCPConnection クラスを定義する。このクラスは、データを送信するためのインタフェースを提供し、状態を変更する要求を処理する。<br><br><pre>    class TCPOctetStream;    class TCPState;        class TCPConnection {    public:        TCPConnection();            void ActiveOpen();        void PassiveOpen();        void Close();            void Send();        void Acknowledge();        void Synchronize();            void ProcessOctet(TCPOctetStream*);    private:        friend class TCPState;        void ChangeState(TCPState*);    private:        TCPState* _state;    };</pre><br><br><font style="text-indent:10pt">　TCPConnection クラスは、メンバ変数 -stateにTCPState クラスのインスタンスを持っている。TCPState クラスのインタフェースは、TCPConnection クラスの状態を変更するインタフェースと同じである。TCPState クラスの各オペレーションは、パラメータとして TCPConnection オブジェクトをとることで、TCPConnection クラスが持つデータに TCPState クラスがアクセスできるようにし、接続の状態を変更する。<br><br><pre>    class TCPState {    public:        virtual void Transmit(TCPConnection*, TCPOctetStream*);        virtual void ActiveOpen(TCPConnection*);        virtual void PassiveOpen(TCPConnection*);        virtual void Close(TCPConnection*);        virtual void Synchronize(TCPConnection*);        virtual void Acknowledge(TCPConnection*);        virtual void Send(TCPConnection*);    protected:        void ChangeState(TCPConnection*, TCPState*);    };</pre><br><br><font style="text-indent:10pt">　TCPConnection クラスは、状態に依存した要求はすべて、TCPState のサブクラスのインスタンス（-state）に委譲する。また TCPConnection クラスは、この変数を TCPState の別のサブクラスのオブジェクトに変えるためのオペレーションを提供する。TCPConnection クラスのコンストラクタは、このオブジェクトを TCPClosed 状態（後に定義する）に初期化する。<br><br><pre>    TCPConnection::TCPConnection () {        _state = TCPClosed::Instance();    }        void TCPConnection::ChangeState (TCPState* s) {        _state = s;    }        void TCPConnection::ActiveOpen () {        _state->ActiveOpen(this);    }        void TCPConnection::PassiveOpen () {        _state->PassiveOpen(this);    }        void TCPConnection::Close () {        _state->Close(this);    }        void TCPConnection::Acknowledge () {        _state->Acknowledge(this);    }        void TCPConnection::Synchronize () {        _state->Synchronize(this);    }</pre><br><br><font style="text-indent:10pt">　TCPState クラスでは、委譲されるすべての要求に対するデフォルトの振る舞いを実装する。このクラスは、ChangeState オペレーションを使って TCPConnection オブジェクトの状態を変更することもできる。その際、TCPState クラスがこのオペレーションに特別にアクセスできるようにするために、TCPConnection クラスでは TCPState クラスをフレンドクラスとして宣言している。<br><br><pre>    void TCPState::Transmit (TCPConnection*, TCPOctetStream*) { }    void TCPState::ActiveOpen (TCPConnection*) { }    void TCPState::PassiveOpen (TCPConnection*) { }    void TCPState::Close (TCPConnection*) { }    void TCPState::Synchronize (TCPConnection*) { }        void TCPState::ChangeState (TCPConnection* t, TCPState* s) {        t->ChangeState(s);    }</pre><br><br><font style="text-indent:10pt">　TCPState のサブクラスでは、状態に依存した振る舞いを実装する。TCP 接続は多くの状態（Established 状態、Listening 状態、Closed 状態など）をとり得る。それぞれの状態に対して TCPState のサブクラスが存在する。ここでは、3つのサブクラス（TCPEstablished クラス、TCPListen クラス、TCPClosed クラス）について詳細に議論する。<br><br><pre>    class TCPEstablished : public TCPState {    public:        static TCPState* Instance();            virtual void Transmit(TCPConnection*, TCPOctetStream*);        virtual void Close(TCPConnection*);    };        class TCPListen : public TCPState {    public:        static TCPState* Instance();            virtual void Send(TCPConnection*);        // ...    };        class TCPClosed : public TCPState {    public:        static TCPState* Instance();            virtual void ActiveOpen(TCPConnection*);        virtual void PassiveOpen(TCPConnection*);        // ...    };</pre><br><br><font style="text-indent:10pt">　TCPState のサブクラスはローカルな状態を保持しないので、そのインスタンスは共有することができる。したがって、各サブクラスについて、インスタンスは1つだけ存在すればよいことになる。この唯一のインスタンスは、static を指定して宣言された Instance オペレーションにより得られる。TCPState の各サブクラスでは、その状態で有効な要求に対して、その状態に依存した振る舞いを次のように実装する。<br><br><pre>    void TCPClosed::ActiveOpen (TCPConnection* t) {        // send SYN, receive SYN, ACK, etc.            ChangeState(t, TCPEstablished::Instance());    }        void TCPClosed::PassiveOpen (TCPConnection* t) {        ChangeState(t, TCPListen::Instance());    }        void TCPEstablished::Close (TCPConnection* t) {        // send FIN, receive ACK of FIN            ChangeState(t, TCPListen::Instance());    }        void TCPEstablished::Transmit (        TCPConnection* t, TCPOctetStream* o    ) {        t->ProcessOctet(o);    }        void TCPListen::Send (TCPConnection* t) {        // send SYN, receive SYN, ACK, etc.            ChangeState(t, TCPEstablished::Instance());    }</pre><br><br><font style="text-indent:10pt">　状態に依存した処理を行った後、上記のオペレーションは TCPConnection クラスの状態を変えるために ChangeState オペレーションを呼び出す。TCPConnection クラス自身は、TCP 接続プロトコルについては知らない。すなわち、TCP における状態遷移とアクションを定義しているのは TCPState のサブクラスなのである。</font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Johnson と Zweig［JZ91］は、State パターンと TCP 接続プロトコルへの適用について、その特徴を述べている。<br><font style="text-indent:10pt">　ほとんどのインタラクティブ描画プログラムでは、ダイレクトマニュピュレーションによるオペレーションを行うために「ツール」を提供している。たとえば、線描画ツールは、新しい線を生成するためにユーザにクリックとドラッグを行わせる。選択ツールは、ユーザに図形を選択させる。そして、このようなツールからなるパレットがあり、そこからツールを選択できるようになっている。ユーザはツールを選んで使うという自身の動作のみを意識しているが、実際にはエディタの振る舞いも、そのとき選ばれているツールによって変化しているのである。たとえば、描画ツールがアクティブなときには、ユーザは図形を生成する。また、選択ツールがアクティブなときには、ユーザは図形を選択する。選択しているツールによってエディタの振る舞いを変えるために、State パターンを利用することができる。<br><font style="text-indent:10pt">　抽象クラス Tool を定義し、ツールに依存した振る舞いを実現するために、そのサブクラスを定義する。描画エディタはToolのサブクラスのオブジェクトを保持し、このオブジェクトに対して要求を委譲する。ユーザが新しいツールを選択するときには、このオブジェクトを変更し、それに応じて描画エディタの振る舞いを変化させる。<br><font style="text-indent:10pt">　この技術は、HotDraw［Joh92］や Unidraw［VL90］などの描画エディタフレームワークで利用されている。クライアントは簡単に新しい種類のツールを定義することができる。HotDraw では、DrawingController クラスがそのときのツールオブジェクトに要求を送る。Unidraw では、それぞれに対応するクラスは Viewer クラスと Tool クラスである。次のクラスダイアグラムは、Tool クラスと DrawingController クラスのインタフェースを簡単に記したものである。<br><br><br><p align="center"><img src="img/pics/state012.gif"></p><br><br><br>Coplien の Envelope-Letter idiom［Cop92］は、State パターンと関連がある。Envelope-Letter は、実行時にオブジェクトのクラスを変更するための技術である。それに比べて、State パターンはより具体的で、状態によって振る舞いを変えるオブジェクトの扱い方に焦点をあてている。</font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="11.html" target="down">Flyweight パターン</a>:いつどのように ConcreteState オブジェクトが共有されるのかを説明している。<br><font style="text-indent:10pt">　<a href="05.html" target="down">Singleton パターン</a>:ConcreteState オブジェクトは、しばしば <a href="05.html" target="down">Singleton パターン</a>にあてはまる。</font></font><br><br><br></body></html>