<html><head><title>ADAPTER</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/ada.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　あるクラスのインタフェースを、クライアントが求める他のインタフェースへ変換する。Adapter　パターンは、インタフェースに互換性のないクラス同士を組み合わせることができるようにする。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Wrapper</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　再利用を目的として設計されたツールキットクラスは、そのインタフェースがアプリケーションの要求するドメインに特化したインタフェースと一致しないというだけの理由で、再利用できないことがある。<br><font style="text-indent:10pt">　たとえば、絵やダイアグラムの一部として、図形要素（直線、多面体、テキストなど）の描画と整形が可能な描画エディタを考えてみよう。描画エディタの抽象化においてキーとなるのは、グラフィックオブジェクトである。グラフィックオブジェクトは形状を編集でき、それ自身の描画もできる。グラフィックオブジェクトのインタフェースは、Shape と呼ばれる抽象クラスにより定義される。そして、各種のグラフィックオブジェクトに対して Shape のサブクラス（直線に対しては LineShape クラス、多面体に対しては PolygonShape クラスなど）が定義される。<br><font style="text-indent:10pt">　LineShape クラスや PolygonShape クラスのような基本的な幾何学的形状に対するクラスは、その描画と編集の機能が本質的に制限されているため、比較的簡単に実装できる。それに対して、テキストの表示と編集を行う TextShape クラスは、基本的なテキスト編集の際にも、複雑な画面の更新やバッファの管理などをしなければならないため、実装はより困難であると考えられる。ところで、ユーザインタフェースツールキットでは、テキストの表示と編集を行うために洗練された TextView クラスがすでに提供されている場合がある。このような場合には、TextShape クラスを実装する際に、この TextView クラスを再利用するのが理想的である。しかしながら、このツールキットは Shape クラスを考慮に入れて設計されたものではないので、TextView オブジェクトと Shape オブジェクトを組み合わせることができない、ということが起こり得る。<br><font style="text-indent:10pt">　アプリケーションの中で、TextView のような既存のクラスを、互換性のない異なるインタフェースを持つクラスと組み合わせて使用するためには、どうしたらよいのだろうか。もし、このツールキットのソースコードを持っていれば、Shape クラスのインタフェースに一致するように TextView クラスを変更することができるだろう。しかし、TextView クラスを変更するのは勧められない。なぜならば、このツールキットが、ある1つのアプリケーションを動作させるためだけに、ドメインに特化したインタフェースを採用したとすると、このツールキット自体が汎用性を欠くものになってしまうからである。<br><font style="text-indent:10pt">　その代わりに、TextView クラスのインタフェースを Shape クラスのインタフェースに適合（ adapt ）させるように、TextShape クラスを定義することもできる。これは次にあげる2つの方法のいずれかで実現できる。(1) Shape クラスのインタフェースと TextView クラスの実装を継承する。(2) TextView クラスのインスタンスを TextShape オブジェクトの内部に組み込み、TextView クラスのインタフェースを用いて TextShape クラスを実装する。これらの2つのアプローチは、クラスに適用する Adapter パターンとオブジェクトに適用する Adapter パターンにそれぞれ対応している。この場合、TextShape クラスをadapter と呼ぶ。<br><br><br><p align="center"><img src="img/pics/adapt105.gif"></p><br><br><br><font style="text-indent:10pt">　上のダイアグラムはオブジェクトに適用する adapter の例である。Shape クラスで宣言されている BoundingBox オペレーションが、どのようにして TextView クラスで定義されている GetExtent オペレーションに変換されるかがわかるだろう。TextShape クラスが TextView クラスを Shape クラスのインタフェースに適合させるため、描画エディタは互換性がなかった TextView クラスを再利用できるようになる。<br><font style="text-indent:10pt">　adapter は、元のクラスには定義されていなかった機能を追加することがしばしばある。図は、adapter がどのようにしてこの責任を果たすのかを示している。Shape のどのオブジェクトも、ユーザがインタラクティブに“ドラッグ”して別の場所へ移すことができるようになっているべきである。ところが、TextView クラスは、それができるように設計されていない。そこで、TextShape クラスは、Shape クラスの CreateManipulator オペレーションを、Manipulator の適切なサブクラスのインスタンスを返すように実装することで、この足りない機能を追加する。<br><font style="text-indent:10pt">　Manipulator クラスは、ユーザの入力（たとえば、Shape オブジェクトをドラッグして別の場所へ移す）に反応して Shape のオブジェクトをどのように動作させるかを定義している抽象クラスである。Shape のサブクラスごとに Manipulator のサブクラスが存在する。たとえば、TextManipulator クラスは TextShape クラスに対するサブクラスである。TextShape クラスは、TextManipulator クラスのインスタンスを返すことにより、TextView クラスでは定義されていないがShapeクラスは必要としている機能を追加する。</font></font></font></font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Adapter パターンは、次のような状況で使うことができる。<br><br><ul><li>既存のクラスを利用したいが、そのインタフェースが必要なインタフェースと一致していない場合。<br><br><li>まったく無関係で予想もつかないようなクラス（必ずしも互換性のあるインタフェースを持つとは限らない）とも協調していける、再利用可能なクラスを作成したい場合。<br><br><li>（オブジェクトに適用する Adapter パターンのみ）既存のサブクラスを複数利用したいが、それらすべてのサブクラスをさらにサブクラス化することで、そのインタフェースを適合させることが現実的でない場合。オブジェクトに適用する Adapter パターンでは、その親クラスのインタフェースを適合させればよい。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　クラスに適用する Adapter パターンは、一方のインタフェースを他方に適合させるために多重継承を使う。<br><br><br><p align="center"><img src="img/pics/adapt106.gif"></p><br><br><br><br><font style="text-indent:10pt">　オブジェクトに適用する Adapter パターンは、オブジェクトコンポジションを使う。<br><br><br><p align="center"><img src="img/pics/adapt104.gif"></p><br><br><br></font></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Target クラス</b> （ Shape クラス）<ul><li>Client クラスが利用する、ドメインに特化したインタフェースを定義する。</ul><br><br><li><b>Client クラス</b> （ DrawingEditor クラス）<ul><li>Target クラスのインタフェースに従ったオブジェクトと協力する。</ul><br><br><li><b>Adaptee クラス</b> （ TextView クラス）<ul><li> 適合させる必要のある既存のインタフェースを持つ。</ul><br><br><li><b>Adapter クラス</b> （ TextShape クラス）<ul><li>Adaptee クラスのインタフェースを Target クラスのインタフェースに適合させる。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Client オブジェクトが Adapter クラスのインスタンスに対してオペレーションの呼び出しを行う。すると、Adapter クラスのインスタンスは、その要求を実行する Adaptee クラスのオペレーションを呼び出す。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　クラスに適用する Adapter パターンとオブジェクトに適用する Adapter パターンには、それぞれ異なるトレードオフがある。クラスに適用する Adapter パターンでは、次にあげるトレードオフが生じる。<br><br><ul><li>Adaptee クラスの Target クラスへの適合を、具象クラス Adapter に任せる。結果として、あるクラス、およびそのすべてのサブクラスを適合させたいときに、クラスに適用する Adapter パターンではうまくいかない。<br><br><li>Adapter クラスが Adaptee クラスのサブクラスとなるため、Adapter クラスは Adaptee クラスの振る舞いをオーバーライドできる。<br><br><li>1つのオブジェクトを導入するだけであり、Adaptee オブジェクトをアクセスするためにポインタのような間接的な手段を導入する必要がない。　オブジェクトに適用する Adapter パターンでは、次にあげるトレードオフが生じる。<br><br><li>1つの Adapter オブジェクトが、多くの Adaptee オブジェクト、すなわち Adaptee クラスのオブジェクトや（もし存在していれば）そのサブクラスのオブジェクトを適合させることができる。また一度にすべての Adaptee オブジェクトに機能を追加することもできる。<br><br><li>Adaptee クラスの振る舞いをオーバーライドするのが困難である。これを実現するには Adaptee クラスをサブクラス化し、Adapter クラスが、Adaptee クラスのオブジェクトではなく、そのサブクラスのオブジェクトを参照するようにしておく必要がある。</ul><br><br><font style="text-indent:10pt">　以下に、Adapter パターンを使用する際に考慮しなければならないその他の問題点をあげる。<br><br><ol><li>Adapter クラスがどれだけの適合を行うのか。Adapter クラスが、Adaptee クラスを Target クラスのインタフェースに一致させるために行う作業の量は、場合により異なる。その作業の範囲は、オペレーションの名前を変えるだけの簡単なインタフェースの変更から、まったく異なるオペレーションの集合をサポートすることまでが考えられる。Adapter クラスが行う作業の量は、Target クラスのインタフェースがどれだけ Adaptee クラスのインタフェースに似ているかにより決まる。<br><br><li>pluggable adapter 。あるクラスを利用するために、他のクラスが守らなければならない仮定を少なくすれば、そのクラスはより再利用しやすくなる。インタフェースの適合機能をクラスに組み込むことで、他のクラスが常に同じインタフェースに従わなければならないという仮定を消去できる。言い換えると、インタフェースの適合機能により、任意のクラスを、別のインタフェースを要求している既存のシステムに組み込むことができるようになる。ObjectWorks /Smalltalk［Par90］では、インタフェースの適合機能が作り込まれているクラスを pluggable adapter と呼んでいる。<br><font style="text-indent:10pt">　木構造を図式的に表示することができる TreeDisplay ウィジェットについて考えてみよう。もし、このウィジェットが1つのアプリケーションだけで使用される特別な目的を持ったものならば、TreeDisplay ウィジェットが表示するオブジェクトが、ある特定のインタフェースを持つように要求してもよいだろう。つまり、TreeDisplay ウィジェットが表示するオブジェクトは、すべて抽象クラス Tree を継承しなければならないことにしてもよい。ところが、TreeDisplay ウィジェットを再利用できるようにしたければ（たとえば、便利なウィジェットを集めたツールキットにこのウィジェットを加えたければ）、この要求は望ましくない。アプリケーションでは、それぞれで独自の木構造のクラスが定義されるだろう。それらのアプリケーションは、特定の抽象クラス Tree を利用することを強制されるべきではない。異なる木構造は異なるインタフェースを持つことになるだろう。<br><font style="text-indent:10pt">　たとえば、ディレクトリ階層では、1つ下のディレクトリを GetSubdirectories オペレーションでアクセスするかもしれない。それに対して、継承階層では、これに対応するオペレーションを GetSubclasses と呼ぶかもしれない。再利用可能な TreeDisplay ウィジェットは、この両種の階層で、たとえ異なるインタフェースが用いられていたとしても、両方を表示できなければならない。言い換えると、TreeDisplay ウィジェットはインタフェース適合機能を内部に組み込むべきなのである。<br><font style="text-indent:10pt">　インタフェース適合機能をクラスへ組み込むいくつかの方法を、「実装」の節で取り上げる。<br><br><li>透過性を提供するための両方向 adapter の利用。adapter の潜在的な問題は、すべてのクライアントに対して透過性がないことである。適合されたオブジェクトは、もはや Adaptee クラスのインタフェースには従っていない。そのため、本来の Adaptee オブジェクトと同じように使用することはできなくなる。両方向 adapter は透過性を提供する。両方向 adapter は特に、2つの異なるクライアントが、あるオブジェクトを別々に参照する必要がある場合に有効である。<br><font style="text-indent:10pt">　図形エディタのフレームワークである Unidraw［VL90］と、制約解決ツールキットの QOCA［HHMV92］を統合する両方向 adapter を考えてみよう。どちらのシステムも、明示的に変数を表現するクラスを持っている。すなわち、Unidraw は StateVariable クラス、QOCA は ConstraintVariable クラスを持つ。Unidraw を QOCA と組み合わせて動作させるためには、ConstraintVariable クラスを StateVariable クラスに適合させなければならず、逆に、QOCA がその解を Unidraw に伝えるためには、StateVariable クラスを ConstraintVariable クラスに適合させなければならない。<br><br><br><p align="center"><img src="img/pics/adapt107.gif"></p><br><br><br><br><font style="text-indent:10pt">　このための解法として、クラスを基にした両方向 adapter である ConstraintStateVariable クラスを利用することになる。この ConstraintStateVariable クラスは StateVariable クラスと ConstraintVariable クラスの両方のサブクラスであり、2つの親クラスのインタフェースを互いに適合させる。この場合、適合されるクラスのインタフェースがまったく異なっているため、多重継承が1つの有効な解法となる。クラスを基にした両方向 adapter は2つのクラスをお互いに相手に対して適合させるため、どちらのシステムにおいても動作可能になる。</ol></font></font></font></font></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Adapter パターンの実装は通常は簡単だが、以下に留意すべき問題点をあげる。<br><br><ol><li><b>クラスを基にした adapter のC++による実装。</b>クラスを基にした adapter のC++による実装では、Adapter クラスは Target クラスを公開で継承し、Adaptee クラスを私的に継承する。したがって、Adapter クラスは Target クラスのサブタイプとなるが、Adaptee クラスのサブタイプとはならない。<br><br><li><b>pluggable adapter。</b>pluggable adapter の実装にはいくつかの方法がある。1つの例として、階層構造を自動的に配置し表示する前述の TreeDisplay ウィジェットを実装する3つの方法について見てみよう。<br><font style="text-indent:10pt">　ここで議論される3つの実装のすべてに共通な最初のステップは、Adaptee クラスの narrow インタフェース、すなわち、適合させなければならない最小限のオペレーションの集合を見つけることである。なぜならば、オペレーションが少数しかないインタフェースの方が、多数のオペレーションを持つインタフェースよりも適合させやすいからである。TreeDisplay クラスにとって、adaptee は任意の階層構造である。したがって、最小のインタフェースは次の2つのオペレーションから構成されるだろう。1つは木の中のノードを表示する方法を定義するオペレーション、もう1つはあるノードの子ノードを取り出すオペレーションである。<br><font style="text-indent:10pt">　この narrow インタフェースの実装に対して可能な、3つのアプローチを以下に示す。　<br><br><ol type="a"><li><b>抽象オペレーションを用いる。</b>TreeDisplay クラスの中で、Adaptee クラスの narrow インタフェースに対応させて、抽象オペレーションを宣言する。その抽象オペレーションを実装して、木構造を表す具象オブジェクトを適合させるのは、サブクラスで行うことにする。たとえば DirectoryTreeDisplay サブクラスは、ディレクトリ構造にアクセスすることにより、これらのオペレーションを実装する。<br><br><br><p align="center"><img src="img/pics/adapt103.gif"></p><br><br><br><font style="text-indent:10pt">　DirectoryTreeDisplay クラスでは、そのクライアントである DirectoryBrowser クラスがディレクトリ構造を表示できるようにするために、narrow インタフェースを特化して実装する。<br><br><li><b>delegate オブジェクトを使用する。</b>このアプローチでは、TreeDisplay クラスは、木構造にアクセスするための要求を delegate オブジェクトへ転送する。TreeDisplay クラスのクライアントは、適切な delegate を与えることで適合を調整する。<br><font style="text-indent:10pt">　たとえば、ａと同様に、TreeDisplay オブジェクトを利用する DirectoryBrowser オブジェクトがあるとする。DirectoryBrowser クラスは、TreeDisplay クラスをディレクトリ階層構造に適合させるために、適切な delegate を生成する。Smalltalk や Objective C などの動的に型付けされる言語を用いた場合、このアプローチでは delegateをadapter に登録するためのインタフェースのみが必要になる。そして、TreeDisplay クラスは、登録された delegate に要求を転送するだけになる。NEXTSTEP［Add94］は、サブクラス分割を減らすためにこのアプローチを多用している。<br><br><br><p align="center"><img src="img/pics/adapt102.gif"></p><br><br><br><font style="text-indent:10pt">　C++のような静的に型付けされる言語では、delegate のために明示的なインタフェースの定義が必要になる。TreeDisplay クラスが要求する narrow インタフェースを、純粋抽象クラス TreeAccessorDelegate の中に入れることで、インタフェースの明示化を行う。そして継承により、delegate（この場合には DirectoryBrowser オブジェクト）にこのインタフェースを組み込むようにする。その際、DirectoryBrowser が親クラスを持たない場合には単純継承を、親クラスを持つ場合には多重継承を用いることになる。この方法は、新たに TreeDisplay のサブクラスを導入し、そのオペレーションをそれぞれ実装するよりも簡単である。<br><br><li><b>パラメータ化された adapter。</b>Smalltalk で pluggable adapter をサポートする通常の方法は、1つ以上のブロックで adapter をパラメータ化することである。ブロック構造は、サブクラス化を行わずに、適合をサポートする。1つのブロックは1つの要求を適合させることができる。そして、adapter は、要求ごとにブロックを持つことができる。これまでの例で考えると、TreeDisplay クラスが、あるノードを GraphicNode オブジェクトへ変換するためのブロックと、あるノードの子ノードにアクセスするためのブロックを持つということを意味している。<br><font style="text-indent:10pt">　たとえば、ディレクトリ階層について TreeDisplay クラスを作成するには、次のように記述する。<p><pre>    directoryDisplay :=        (TreeDisplay on: treeRoot)             getChildrenBlock:                 [:node | node getSubdirectories]             createGraphicNodeBlock:                 [:node | node createGraphicNode].</pre><p><font style="text-indent:10pt">　もし、インタフェースの適合機能をクラスの中に作り込むのであれば、このアプローチはサブクラス化の代わりになる便利な方法である。</ol></ol></font></font></font></font></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　「動機」の節の例で取り上げた、クラスを基にした adapter とオブジェクトを基にした adapter の実装を簡単に示す。まず最初に、Shape クラスと TextView クラスの実装を示す。<p><pre>    class Shape {    public:        Shape();        virtual void BoundingBox(            Point&amp; bottomLeft, Point&amp; topRight        ) const;        virtual Manipulator* CreateManipulator() const;    };        class TextView {    public:        TextView();        void GetOrigin(Coord&amp; x, Coord&amp; y) const;        void GetExtent(Coord&amp; width, Coord&amp; height) const;        virtual bool IsEmpty() const;    };</pre><p><font style="text-indent:10pt">　Shape クラスは対角の点で定義される境界線を持っている。それに対し TextView クラスは、原点、高さ、幅で定義されている。また Shape クラスでは、Manipulator オブジェクトを生成するための CreateManipulator オペレーションが宣言されている。この Manipulator オブジェクトには、ユーザが Shape オブジェクトをオペレーションするときにこの Shape オブジェクトをどう動作させるかが記述されている。TextView クラスには、これと等価なオペレーションは定義されていない。TextShape クラスは、これらの異なるインタフェース間の adapter となる。<br><font style="text-indent:10pt">　クラスを基にした adapter では、インタフェースを適合させるために多重継承を用いる。このパターンの特徴は、一方の継承をインタフェースを継承するために用い、他方の継承を実装を継承するために用いることである。C++では、インタフェースを公開で継承し、実装を私的に継承することで区別するのが普通である。ここでは、adapter となる TextShape クラスを定義するためにこの方法を用いる。<p><pre>    class TextShape : public Shape, private TextView {    public:        TextShape();            virtual void BoundingBox(            Point&amp; bottomLeft, Point&amp; topRight        ) const;        virtual bool IsEmpty() const;        virtual Manipulator* CreateManipulator() const;    };</pre><p><font style="text-indent:10pt">　BoundingBox オペレーションは、TextView クラスのインタフェースを Shape クラスのインタフェースに従うように変換する。<p><pre>    void TextShape::BoundingBox (        Point&amp; bottomLeft, Point&amp; topRight    ) const {        Coord bottom, left, width, height;            GetOrigin(bottom, left);        GetExtent(width, height);            bottomLeft = Point(bottom, left);        topRight = Point(bottom + height, left + width);    }</pre><p><font style="text-indent:10pt">　IsEmpty オペレーションは、TextView クラスの同名のオペレーションを呼ぶ（これは、adapter のオペレーションの実装では共通に行われることである）。<p><pre>    bool TextShape::IsEmpty () const {        return TextView::IsEmpty();    }</pre><p><font style="text-indent:10pt">　最後に、CreateManipulator オペレーション（ TextView クラスではサポートされていない）を初めから定義する。このアプローチでは、TextShape オブジェクトのオペレーションをサポートする TextManipulator クラスがすでに実装されていると仮定する。<p><pre>    Manipulator* TextShape::CreateManipulator () const {        return new TextManipulator(this);    }</pre><p><font style="text-indent:10pt">　オブジェクトを基にした adapter は、異なるインタフェースを持つクラスを組み合わせるために、合成オブジェクトを使用する。このアプローチでは、adapter である TextShape オブジェクトが TextView オブジェクトへのポインタを保持する。<p><pre>    class TextShape : public Shape {    public:        TextShape(TextView*);            virtual void BoundingBox(            Point&amp; bottomLeft, Point&amp; topRight        ) const;        virtual bool IsEmpty() const;        virtual Manipulator* CreateManipulator() const;    private:        TextView* _text;    };</pre><p><font style="text-indent:10pt">　TextShape クラスは、TextView クラスのインスタンスへのポインタを初期化しなければならないが、それはコンストラクタで行う。また TextShape クラスは、自身のオペレーションが呼ばれたときは、TextView オブジェクトの対応するオペレーションを呼び出さなければならない。この例では、クライアントが TextView オブジェクトを生成し、それを TextShape のコンストラクタへ渡すと仮定する。<p><pre>    TextShape::TextShape (TextView* t) {        _text = t;    }        void TextShape::BoundingBox (        Point&amp; bottomLeft, Point&amp; topRight    ) const {        Coord bottom, left, width, height;            _text->GetOrigin(bottom, left);        _text->GetExtent(width, height);            bottomLeft = Point(bottom, left);        topRight = Point(bottom + height, left + width);    }        bool TextShape::IsEmpty () const {        return _text->IsEmpty();    }</pre><p><font style="text-indent:10pt">　CreateManipulator オペレーションは、一から実装され、既存の TextView クラスの機能を再利用しないので、クラスを基にした adapter のものと変わらない。<p><pre>    Manipulator* TextShape::CreateManipulator () const {        return new TextManipulator(this);    }</pre><p><font style="text-indent:10pt">　このコードを、クラスを基にした adapter のコードと比較してみよう。オブジェクトを基にした adapter の方が、コードの作成では若干の労力が必要になるが、より柔軟なものになっている。たとえば、オブジェクトを基にした adapter としての TextShape クラスは、TextView クラスだけでなく TextView のサブクラスともうまく働く。これにより、クライアントは単に TextView のサブクラスのインスタンスを TextShape クラスのコンストラクタへ渡すだけでよい。</p></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　「動機」の節の例は、ET++［WGM88］を基にした描画アプリケーションET++Draw を題材にしている。ET++Draw は、テキスト編集のためにET++のクラスを再利用している（ adapter のクラスとして、TextShape を使用している）。<br><font style="text-indent:10pt">　InterViews 2. 6 は、スクロールバー、ボタン、メニューなどのユーザインタフェース要素のために、抽象クラス Interactor を定義している［VL88］。また、直線、円、多角形、スプラインなどの構造化されたグラフィックオブジェクトのために、抽象クラス Graphic も定義している。Interactor クラスと Graphic クラスはどちらもグラフィックの要素を扱っているが、これらのインタフェースと実装は互いに異なっており（共通の親クラスを持たない）、そのため互換性がない。たとえば、構造化されたグラフィックオブジェクトをダイアログボックスの中に直接置くことはできない。<br><font style="text-indent:10pt">　その代わりに InterViews 2. 6 では、GraphicBlock クラスと呼ばれる、オブジェクトを基にした adapter が定義されている。GraphicBlock クラスは、Graphic クラスのインスタンスを含む Interactor のサブクラスである。GraphicBlock クラスは、Graphic クラスのインタフェースを Interactor クラスのインタフェースに適合させる。GraphicBlock クラスにより、Interactor クラスで表される要素内で、Graphic クラスのインスタンスを表示、スクロール、ズームすることが可能になる。<br><font style="text-indent:10pt">　pluggable adapter は ObjectWorks /Smalltalk［Par90］では一般的である。標準の Smalltalk は1つの値を表示するビューのために ValueModel クラスを定義している。ValueModel クラスは値にアクセスするためのインタフェース value とvalue: を定義している。これらは抽象化されたメソッドである。ところが、アプリケーションは、値にアクセスするために width や width: のようなドメインに特化した名前を用いる。しかし、アプリケーションに特化したこのような名前を ValueModel クラスのインタフェースに適合させるためだけに、ValueModel クラスをサブクラス化することがないようにすべきである。<br><font style="text-indent:10pt">　そのために、ObjectWorks /Smalltalk では、PluggableAdaptor と呼ばれる ValueModel のサブクラスを用いる。PluggableAdaptor オブジェクトは、他のオブジェクトを ValueModel クラスのインタフェース（ value、value: ）に適合させる。このオブジェクトは、要求する値を得たり設定したりするために、ブロックを用いてパラメータ化される。PluggableAdaptor クラスは、インタフェース value と value: を実装するためにこれらのブロックを内部で用いている。また構文的な便利さのために、PluggableAdaptor により任意の名前（たとえば、width、width: ）で直接アクセスすることもできるようにしている。PluggableAdaptor クラスは、これらの任意の名前を対応するブロックに自動的に変換する。<br><br><br><p align="center"><img src="img/pics/plugg021.gif"></p><br><br><br><font style="text-indent:10pt">　ObjectWorks /Smalltalk のもう1つの例として TableAdaptor クラスがある。TableAdaptor オブジェクトは、オブジェクトの列を表の形式に適合させることができる。表は行ごとに1つのオブジェクトを表示する。クライアントは、表がオブジェクトから列の値を得るために使うメッセージの集合を用いて、TableAdaptor クラスをパラメータ化する。<br><font style="text-indent:10pt">　NeXT の AppKit［Add94］のクラスの中には、インタフェースを適合させるために、delegate を使用しているものがある。たとえば、データの階層化されたリストを表示する NXBrowser クラスがそれにあたる。NXBrowser クラスは、データにアクセスし適合させるために delegate を用いている。<br><font style="text-indent:10pt">　Meyer の“便宜的な結婚”［Mey88］は、クラスを基にした adapter の1つである。Meyer は、FixedStack クラスが Array クラスの実装を Stack クラスのインタフェースに適合させる方法について述べている。その結果、要素のオブジェクトの数が一定のスタックが得られる。</font></font></font></font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="07.html" target="down">Bridge パターン</a>: このパターンは、オブジェクトを基にした adapter によく似た構造をしているが、目的が異なっている。<a href="07.html" target="down">Bridge パターン</a>の目的は、インタフェースと実装を分離して、それらを容易にかつ独立して変更できるようにすることである。Adapter パターンの目的は、“既存の”オブジェクトのインタフェースを変換することである。<br><font style="text-indent:10pt">　<a href="09.html" target="down">Decorator パターン</a>: このパターンでは、インタフェースを変更することなく、オブジェクトに対して機能の追加を行う。アプリケーションにとっては、adapter よりも decorator の方が透過性が高い。その結果 <a href="09.html" target="down">Decorator パターン</a>は、純粋な adapter では不可能な、再帰的なオブジェクト構造をサポートする。<br><font style="text-indent:10pt">　<a href="12.html" target="down">Proxy パターン</a>: このパターンでは、他のオブジェクトに対する代表あるいは代理を定義するが、その際にインタフェースを変更することはない。</font></font></font><br><br><br></body></html>