<html><head><title>DECORATOR</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/dec.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　オブジェクトに責任を動的に追加する。Decorator パターンは、サブクラス化よりも柔軟な機能拡張方法を提供する。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Wrapper</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　あるクラス全体に対してではなく、個々のオブジェクトに責任を追加したくなることがある。たとえば、グラフィックユーザインタフェースツールキットでは、境界線やスクロール機能などを任意のユーザインタフェースコンポーネント（以下、component と呼ぶ）に追加できるようになっているべきである。<br><font style="text-indent:10pt">　責任を追加する方法の1つに継承の利用がある。たとえば、別のクラスから境界線を継承すれば、そのサブクラスのすべてのインスタンスのまわりに境界線を付けることができる。しかし、この方法では境界線を付けるかどうかの選択が静的になされるため、柔軟性に欠ける。すなわちこの方法では、いつ、どうやって component に境界線を追加するかをクライアントは制御できない。<br><font style="text-indent:10pt">　継承の利用よりも柔軟なアプローチに、境界線を追加する機能を持つ別のオブジェクトで component を囲んでしまう方法がある。囲っているオブジェクトのことを decorator と呼ぶ。decorator のインタフェースは、それが装飾している component のインタフェースと一致している。そのため、component のクライアントにとっては decorator の存在は透明になる。decorator は component に対して要求を転送し、その転送の前か後にさらにアクション（たとえば、境界線を引く処理など）を実行することがある。decorator の存在を透明にしているため decorator を再帰的にネストでき、したがって、追加できる責任の数に制限はなくなる。<br><br><br><p align="center"><img src="img/pics/decor066.gif"></p><br><br><br>例として、ウィンドウにテキストを表示する TextView オブジェクトを考えよう。常にスクロールバーが必要とは限らないので、TextView クラスにはデフォルトではスクロールバーは付かない。スクロールバーが必要になったときには、 ScrollDecorator オブジェクトを用いてスクロールバーを追加することができる。さらに TextView オブジェクトのまわりに太くて黒い境界線を追加したい場合にも、同様に、BorderDecorator オブジェクトを利用して境界線を追加することができる。このように、decorator を TextView オブジェクトと組み合わせるだけで欲しい結果を得ることができる。<br><font style="text-indent:10pt">　次のインスタンスダイアグラムは、境界線とスクロール機能を持つ TextView オブジェクトを作るために、TextView オブジェクトを BorderDecorator オブジェクトや ScrollDecorator オブジェクトとどのように組み合わせるのかを示している。<br><br><br><p align="center"><img src="img/pics/decor065.gif"></p><br><br><br>ScrollDecorator クラスと BorderDecorator クラスは、Decorator のサブクラスである。Decorator クラスは他の VisualComponent クラスを装飾するための抽象クラスである。<br><br><br><p align="center"><img src="img/pics/decor064.gif"></p><br><br><br>VisualComponent クラスはビジュアルなオブジェクトのための抽象クラスで、表示やイベント処理のインタフェースを定義している。Decorator クラスがどのように draw 要求を component に転送するのか、また Decorator のサブクラスがどのようにこのオペレーションを拡張するのかに注意してほしい。<br><font style="text-indent:10pt">　Decorator のサブクラスには、そのサブクラス固有の機能を実現するためのオペレーションを自由に追加できる。たとえば、もし他のオブジェクトが、ScrollDecorator オブジェクトがインタフェース内に存在していることを知っていれば、ScrollDecorator クラスの ScrollTo オペレーションを使ってそのインタフェースをスクロールさせることができる。このパターンで重要なのは、VisualComponent オブジェクトを利用できる場所であればどこでも decorator を利用できる点である。この方法では、クライアントは decorator で装飾された component と装飾されていない component を区別する必要がないので、decorator による装飾にはまったく依存しないで済む。</font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のような場合に Decorator パターンを利用する。<br><br><ul><li>個々のオブジェクトに責任を動的、かつ透明に（すなわち、他のオブジェクトには影響を与えないように）追加する場合。<br><br><li>責任を取りはずすことができるようにする場合。<br><br><li>サブクラス化による拡張が非実用的な場合。非常に多くの独立した拡張が起こり得ることがある。このような場合、サブクラス化によりすべての組み合わせの拡張に対応しようとすると、莫大な数のサブクラスが必要になるだろう。また、クラス定義が隠ぺいされている場合や入手できない場合にも、このパターンを利用できる。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<p align="center"><img src="img/pics/decor067.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Component クラス</b> （VisualComponent クラス）<ul><li>責任を動的に追加できるようになっているオブジェクトのためのインタフェースを定義する。</ul><br><br><li><b>ConcreteComponent クラス</b> （TextView クラス）<ul><li> 責任を追加できるようになっているオブジェクト（component）を定義する。</ul><br><br><li><b>Decorator クラス</b><ul><li>component または decorator への参照を保持し、また Component クラスのインタフェースと一致したインタフェースを定義する。</ul><br><br><li><b>ConcreteDecorator クラス</b> （BorderDecorator クラス、ScrollDecorator クラス）<ul><li>component に責任を追加するオブジェクト（decorator）を定義する。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　　ConcreteDecorator オブジェクトは、それが装飾している ConcreteComponent オブジェクトに要求を転送する。ConcreteDecorator オブジェクトは、要求を転送する前後にさらにオペレーションを実行することもある。</font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Decorator パターンには、少なくとも2つの主要な利点と2つの欠点がある。<br><br><ol><li><b>静的な継承よりも柔軟である。</b>Decorator パターンはオブジェクトに責任を追加する方法を提供するが、この方法は静的な（多重）継承よりも柔軟である。Decorator パターンを用いると、decorator を付けたりはずしたりして、実行時に簡単に責任の追加や削除ができる。一方、継承を用いると、追加する責任ごとに新たなクラス（たとえば BorderedScrollableTextView クラス、BorderedTextView クラスなど）を作らなければならない。これでは多くのクラスが必要になり、システムも複雑になる。さらに、1つの Component クラスに対して種々の Decorator クラスを用意しておくと、いろいろな責任を合わせて、要求にかなう責任を作り出していくことが可能になる。<br><font style="text-indent:10pt">　decorator を用いると、1つの性質を2回追加することも容易になる。たとえば、TextView オブジェクトに境界線を二重に与えるには、BorderDecorator オブジェクトを2つ付けるだけでよい。一方、Border クラスを2回継承する方法ではエラーが起きやすい。<br><br><li><b>機能を満載したクラスを階層構造の上層で定義することを避けられる。</b>Decorator パターンは責任の追加に関して“現金払い”のアプローチを提供する。このパターンを使わずに、複雑でカスタマイズ可能な1つのクラスで、予想できるすべての特徴をサポートする方法も考えられる。しかし、このパターンではそのような方法をとる代わりに、1つの単純なクラスを定義し、decorator を用いて機能を段階的に追加していく。これにより、オブジェクトの機能を単純な部品を用いて組み立てることができるようになる。その結果、アプリケーションはそれが利用しない性質まで取り込む必要はなくなる。また、当初予想していなかったような拡張を行う場合でも、拡張するオブジェクトのクラスとは独立に、新たな種類の Decorator クラスを簡単に定義できる。一方、複雑なクラスを拡張しようとすると、追加しようとしている責任とは無関係なクラス内の詳細部分をさらすことになりかねない。<br><br><li><b>decorator とそれが装飾している component は同一ではない。</b>decorator は透明な囲いのように振る舞う。しかし、オブジェクトの同一性という観点では、装飾された component は component 自体と同一ではない。したがって、decorator を利用するときには、オブジェクトの同一性に依存すべきではない。<br><br><li><b>多くの小さなオブジェクト。</b>Decorator パターンを利用して設計したシステムは、しばしば同じように見える多くの小さなオブジェクトから構成されることになる。それらのオブジェクトは相互の関連のしかたが異なるだけで、所属するクラスや変数の値は同じである。このようなシステムは、それを理解している人にとってはカスタマイズが容易だが、それを学んだりデバッグしたりするのは困難になることがある。</ol></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Decorator パターンを適用するときには、いくつかの問題を考慮すべきである。<br><br><ol><li><b>インタフェースの一致。</b>decorator のインタフェースは、それが装飾する component のインタフェースと一致していなければならない。したがって、（少なくともC++では）ConcreteDecorator クラスは1つの共通なクラスを継承しなければならない。<br><br><li><b>抽象クラス Decorator の省略。</b>責任を1つしか追加する必要がないときには、抽象クラス Decorator を定義する必要はない。新たなクラス階層を設計しているときよりも、既存のクラス階層を扱っているときに、しばしばこのような状況になる。この場合、要求を component に転送するという Decorator クラスの責任を ConcreteDecorator クラスに持たせてしまい、Decorator クラスを省略することができる。<br><br><li><b>Component クラスを軽く保つ。</b>インタフェースの一致を保証するために、component と decorator は共通の Component クラスを継承しなければならない。この共通のクラスを軽く保つことは重要である。すなわち、Component クラスではインタフェースの定義に焦点をあてるべきであり、データの保存には焦点をあてるべきでない。データ表現はサブクラスにおいて定義すべきである。そうしないと、Component クラスが複雑になり、そのために decorator が重くなりすぎて、多くの decorator を使うことはできなくなるだろう。また、Component クラスで多くの機能を定義すると、具象サブクラスが必要でない性質まで取り込まなければならなくなる可能性が増えてしまう。<br><br><li><b>殻の変更と中身の変更。</b>decorator はオブジェクトの振る舞いを変更するための殻のようなものと考えられる。一方、オブジェクトの振る舞いを変更する別の方法に、オブジェクトの中身を変更する方法もある。<a href="21.html" target="down">Strategy パターン</a>は中身を変更するパターンの良い例である。<br><font style="text-indent:10pt">　Component クラスが本質的に重く、そのため Decorator パターンを適用するにはコストがかかりすぎるような状況では、<a href="21.html" target="down">Strategy パターン</a>を選択する方がよい。<a href="21.html" target="down">Strategy パターン</a>では、component はその振る舞いのいくつかを別の strategy に転送することになる。この strategy を取り替えることにより、component の機能を変更したり拡張することができる。<br><font style="text-indent:10pt"></font>　たとえば、component が境界線の描画を Border オブジェクトに行わせるようにすれば、異なるスタイルの境界線をサポートできる。この Border オブジェクトは境界線描画の戦略をカプセル化した strategy である。1つの strategy だけでなく、複数の strategy をリスト状につなげるように拡張すれば、decorator を再帰的にネストしたのと同じ効果が得られる。<br><font style="text-indent:10pt"></font>　たとえば、MacApp 3. 0［App89］と Bedrock［Sym93a］では、グラフィックコンポーネント（view と呼ばれる）は adorner オブジェクトのリストを保持する。adorner オブジェクトは view オブジェクトに境界線などの装飾を追加することができる。view オブジェクトが adorner オブジェクトを持っていれば、view オブジェクトはそれらに追加分の装飾を描画する機会を与える。view のクラスは重いので、MacApp と Bedrock はこのアプローチをとらなければならない。境界線を追加するためだけにすべての機能がそろっている view のクラスを利用していては、コストがかかりすぎるであろう。<br><font style="text-indent:10pt">　Decorator パターンでは component を外側から変更するだけなので、component は decorator について何も知らなくてよい。つまり、decorator は component にとって透明である。<br><br><br><p align="center"><img src="img/pics/deco-069.gif"></p><br><br><br>一方、strategy を用いる場合には、可能な拡張については component 自身が知っている。したがって、component は対応する strategy への参照を保持しておかなければならない。<br><br><br><p align="center"><img src="img/pics/deco-068.gif"></p><br><br><br><a href="21.html" target="down">Strategy パターン</a>に基づくアプローチでは、新たな拡張に適応するように component を修正しなければならないこともある。その一方で、decorator のインタフェースが component のインタフェースと一致しなければならないのに対して、strategy はそれに特化したインタフェースを持つことができる。たとえば、境界線を描画する strategy のクラスは、境界線を描画するためのインタフェース（DrawBorder、GetWidth など）だけを定義すればよい。これは、たとえ Component クラスが重くても strategy のクラスを軽くできることを意味している。<br><font style="text-indent:10pt">　MacApp と Bedrock は、view を装飾する目的以外にもこのアプローチを利用している。すなわち、イベント処理に関してオブジェクトの振る舞いを追加するために <a href="21.html" target="down">Strategy パターン</a>を用いている。どちらのシステムでも、view オブジェクトは behavior オブジェクトのリストを保持している。behavior オブジェクトは、イベントを修正したり、さえぎったりすることができる。view オブジェクトはリストに登録された各 behavior オブジェクトに、登録されていない behavior オブジェクトよりも先にイベントを処理する機会を与える。これにより、たとえば、キーイベントをさえぎったり処理したりする behavior オブジェクトを登録することで、view オブジェクトに特別なキーボード処理機能を与えられるようになる。</ol></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　ユーザインタフェースのための decorator をC++で実装する方法を以下に示す。ここでは、VisualComponent と呼ばれる Component クラスが存在していると仮定する。<br><br><pre>    class VisualComponent {    public:        VisualComponent();            virtual void Draw();        virtual void Resize();        // ...    };</pre><br><br><font style="text-indent:10pt"></font>　Decorator クラスを VisualComponent のサブクラスとして定義する。後にこの Decorator のサブクラスを用いてさまざまな decorator を得る。<br><br><pre>    class Decorator : public VisualComponent {    public:        Decorator(VisualComponent*);            virtual void Draw();        virtual void Resize();        // ...    private:        VisualComponent* _component;    };</pre><br><br><font style="text-indent:10pt"></font>　Decorator クラスは、インスタンス変数-component で参照している VisualComponent オブジェクトを装飾する。このインスタンス変数はコンストラクタで初期化される。VisualComponent クラスのインタフェース内の各オペレーションについて、Decorator クラスはデフォルトで各オペレーション要求を-component にそのまま転送するように実装している。<br><br><pre>    void Decorator::Draw () {        _component->Draw();    }        void Decorator::Resize () {        _component->Resize();    }</pre><br><br><font style="text-indent:10pt"></font>　Decorator の各サブクラスはある特定の装飾を定義する。たとえば BorderDecorator クラスは、それが囲っている component に境界線を追加する。この BorderDecorator クラスは Decorator のサブクラスであり、境界線を引くために Draw オペレーションをオーバーライドしている。また、BorderDecorator クラスは境界線の描画を補助する私的なオペレーション DrawBorder を定義している。その他のすべてのオペレーションの実装は Decorator クラスから継承する。<br><br><pre>    class BorderDecorator : public Decorator {    public:        BorderDecorator(VisualComponent*, int borderWidth);            virtual void Draw();    private:        void DrawBorder(int);    private:        int _width;    };        void BorderDecorator::Draw () {        Decorator::Draw();        DrawBorder(_width);    }</pre><br><br><font style="text-indent:10pt"></font>　スクロール機能を追加するための ScrollDecorator クラスや、ドロップシャドウを追加するための DropShadowDecorator クラスも、BorderDecorator クラスと同様に実装されるだろう。<br><font style="text-indent:10pt"></font>　このように、異なる装飾機能を提供しているクラスのインスタンスは、組み合わせて利用することができる。次のコードは境界線とスクロール機能の付いた TextView オブジェクトを生成するために、decorator をどのように利用できるのかを例示している。<br><font style="text-indent:10pt">　まず最初に、Window オブジェクト内に VisualComponent オブジェクトを配置する方法が必要である。そこで、Window クラスにはそのための SetContents オペレーションが備わっていると仮定する。<br><br><pre>    void Window::SetContents (VisualComponent* contents) {        // ...    }</pre><br><br><font style="text-indent:10pt">　さて、これで TextView オブジェクトとそれを配置する Window オブジェクトを生成できる。<br><br><pre>    Window* window = new Window;    TextView* textView = new TextView;</pre><br><br><font style="text-indent:10pt">　TextView クラスは VisualComponent のサブクラスであるから、TextView オブジェクトを次のようにして Window オブジェクト内に配置することができる。<br><br><pre>    window->SetContents(textView);</pre><br><br><font style="text-indent:10pt">　しかし、我々が必要としているのは境界線とスクロール機能を持つ TextView オブジェクトである。そこで、TextView オブジェクトをウインドウ内に配置する前にそれに装飾を加える。<br><br><pre>    window->SetContents(        new BorderDecorator(            new ScrollDecorator(textView), 1        )    );</pre><br><br><font style="text-indent:10pt">　Window オブジェクトは、VisualComponent クラスのインタフェースを通して component にアクセスするので、decorator の存在には気付かない。しかしたとえば、TextView クラスのオペレーションのうち、VisualComponent クラスのインタフェースには含まれないものを実行したいこともある。このようにクライアントが TextView オブジェクトと直接やりとりしなければならない場合には、TextView オブジェクトを直接参照するようにしておくこともできる。また、component の同一性に依存しているクライアントも、component を直接参照すべきである。</font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　多くのオブジェクト指向ユーザインタフェースツールキットは、ウィジェットにグラフィカルな装飾を追加するために decorator を利用している。InterViews［LVC89、LCI+92］、ET++［WGM88］、ObjectWorks /Smalltalk クラスライブラリ［Par90］などがその例である。一方、Decorator パターンの風変わりな適用例としては、InterViews の DebuggingGlyph クラスや ParcPlaceSmalltalk の PassivityWrapper クラスがある。DebuggingGlyph オブジェクトは、それが修飾している component へレイアウトに関する要求を転送する前後に、デバッグ情報をプリントアウトする。複雑に組み合わされたオブジェクトのレイアウトに関する振る舞いを解析したりデバッグしたりする際に、この情報のトレースを利用できる。一方、PassivityWrapper オブジェクトは、ユーザが component とやりとりすることを可能にしたり不可能にしたりする。<br><font style="text-indent:10pt">　しかし、次の例（ET++のストリームに関するクラスに基づく［WGM88］）に示すように、Decorator パターンの利用はグラフィックユーザインタフェースに限定されるわけではない。<br><font style="text-indent:10pt">　ストリームはほとんどの I/O 機構に存在する基本的な抽象概念である。ストリームはオブジェクトをバイト列や文字列に変換するためのインタフェースを提供する。ストリームを使うと、オブジェクトをファイルやメモリ内のストリングに転写しておき、後で取り出すことができるようになる。これを素直に実現するには、まず抽象クラス Stream を定義し、そのサブクラスとして MemoryStream クラスや FileStream クラスを定義する方法が考えられる。しかし、さらに次にあげるような機能も実現できるようにしたいとする。<br><br><ul><li>異なる圧縮アルゴリズム（run-length encoding、Lempel-Ziv など）を用いてストリームデータを圧縮する。<br><br><li>ASCII 通信チャンネルで送信できるように、ストリームデータを7ビット ASCII 文字に変換する。</ul><br><font style="text-indent:10pt">　Decorator パターンはストリームにこれらの責任を追加するための簡潔な方法を提供する。次ページのダイアグラムがこの問題に対する1つの解を示している。<br><font style="text-indent:10pt">　抽象クラス Stream は内部バッファを保持し、データをストリーム上に格納するオペレーション（PutInt、PutString）を提供する。バッファがいっぱいになると、Stream オブジェクトは抽象化されたオペレーション HandleBufferFull を起動する。このオペレーションが実際にデータを転送する。たとえば FileStream クラスでは、バッファをファイルに転送するように、このオペレーションをオーバーライドする。<br><br><br><p align="center"><img src="img/pics/strea010.gif"></p><br><br><br>ここでキーとなるのは、StreamDecorator クラスである。このクラスは、Stream オブジェクトへの参照を保持し、そのオブジェクトに要求を転送する。StreamDecorator の各サブクラスは HandleBufferFull オペレーションをオーバーライドしており、StreamDecorator クラスの HandleBufferFull オペレーションを呼び出す前に付加的なアクションを実行する。<br><font style="text-indent:10pt">　たとえば、CompressingStream クラスはデータを圧縮し、ASCII7Stream クラスはデータを7ビット ASCII に変換する。データを圧縮し、かつ、圧縮したデータを7ビット ASCII に変換する FileStream オブジェクトを生成するには、FileStream オブジェクトを CompressingStream オブジェクトと ASCII7Stream オブジェクトで修飾すればよい。<br><br><pre>    Stream* aStream = new CompressingStream(        new ASCII7Stream(             new FileStream("aFileName")        )    );    aStream->PutInt(12);    aStream->PutString("aString");</pre></font></font></font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="06.html" target="down">Adapter パターン</a>: decorator は adapter とは異なる。decorator はそれが装飾しているオブジェクトの責任を変えるだけで、インタフェースまでは変えない。adapter はオブジェクトにまったく新しいインタフェースを与える。<br><font style="text-indent:10pt">　<a href="08.html" target="down">Composite パターン</a>: decorator は component を1つしか持たない退化した composite と見なすことができる。しかし、decorator は新たな責任を追加する。オブジェクトの集約が目的ではない。<br><font style="text-indent:10pt">　<a href="21.html" target="down">Strategy パターン</a>: decorator はオブジェクトの殻を変える。一方、strategy はオブジェクトの中身を変える。オブジェクトを変化させる方法には、この2通りが考えられる。</font></font></font><br><br><br></body></html>