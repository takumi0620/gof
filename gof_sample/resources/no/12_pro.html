<html><head><title>PROXY</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/prox.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　あるオブジェクトへのアクセスを制御するために、そのオブジェクトの代理、または入れ物を提供する。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Surrogate</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　オブジェクトへのアクセスを制御する理由の1つとして、そのオブジェクトを実際に利用する必要が生じるまで、そのオブジェクトの生成と初期化にコストをかけるのを延期することがあげられる。例として、文書中にグラフィックオブジェクトを埋め込むことが可能な文書エディタを考えてみよう。大きなラスター画像のように、グラフィックオブジェクトの中には生成に高いコストがかかるものもある。しかし、文書はエディタ上にすばやく開くようにしたい。そこで文書を開く際には、生成に高いコストのかかるオブジェクトをすべて同時に生成するのは避けることにする。実際、すべてを同時に生成する必要はない。なぜならば、これらのオブジェクトがすべて同時に文書中に表示されるわけではないからである。<br><font style="text-indent:10pt">　このような制約のもとでは、コストのかかるオブジェクトは“要求があり次第”生成するということが考えられる。要求があり次第とは、文書エディタの例では画像が表示されるときに、ということである。しかし、要求があるまで画像を生成しないとすると、文書の中には画像の代わりに何を置いておけばよいのだろうか。また、エディタの実装を複雑にしないように、要求があり次第画像が生成されるという事実を隠ぺいするにはどうしたらよいのだろうか。この最適化は、たとえば、文書の表示や整形のためのコードには影響を与えるべきではない。<br><font style="text-indent:10pt">　この問題は画像 proxy を導入することで解決できる。画像 proxy は実画像の代理として振る舞う。つまり、proxy は画像のように振る舞い、要求に応じてその画像をインスタンス化するための準備をしている。<br><br><br><p align="center"><img src="img/pics/proxy016.gif"></p><br><br><br>文書エディタが画像 proxy の Draw オペレーションを呼び出して画像の表示を要求したときにのみ、画像 proxy は実画像を生成する。その後は、画像 proxy は引き続いて起こる要求を画像に直接転送する。そのため、画像 proxy は画像を生成した後、その画像への参照を保持しなければならない。<br><font style="text-indent:10pt">　各画像は別々のファイルに保存されていると仮定しよう。この場合、ファイル名を実オブジェクトへの参照として利用することができる。画像 proxy は画像の大きさ（extent（幅と高さ））も格納している。画像 proxy は、この大きさを用いて、実際に画像をインスタンス化することなく、文書整形部からの画像サイズに関する問い合わせに答えることができる。<br><font style="text-indent:10pt">　次のクラスダイアグラムはこの例をより詳細に示している。<br><br><br><p align="center"><img src="img/pics/proxy-eg.gif"></p><br><br><br>文書エディタは、抽象クラス Graphic で定義されたインタフェースを通して、文書中に埋め込まれた画像にアクセスする。ImageProxy クラスは、要求があり次第生成される画像のためのクラスである。ImageProxy クラスは、ディスク上の画像への参照としてファイル名を保持している。このファイル名は ImageProxy クラスのコンストラクタに引数として渡される。<br><font style="text-indent:10pt">　ImageProxy クラスは、画像の境界枠と、実画像を表す Image クラスのインスタンスへの参照も格納している。ImageProxy オブジェクトが実画像をインスタンス化するまでは、この参照は無効である。Draw オペレーションは、画像にその要求を転送する前に、その画像を必ずインスタンス化しておく。GetExtent オペレーションは、画像がインスタンス化されていれば、その要求を画像に転送する。画像がインスタンス化されていない場合には、ImageProxy は自分が格納している大きさを返す。</font></font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　オブジェクトへの単なるポインタよりも多機能で精巧な参照が必要なときには、いつでも Proxy パターンが適用可能である。ここでは、Proxy パターンが適用可能な一般的な状況をいくつかあげる。<br><br><ol><li>remote proxy は、別のアドレス空間にあるオブジェクトのローカルな代理を提供する。NEXTSTEP［Add94］はこの目的のために NXProxy クラスを用いている。Coplien［Cop92］は、この種の proxy を“Ambassador（大使）”と呼んでいる。<br><br><li>virtual proxy は、コストの高いオブジェクトを要求があり次第生成する。「動機」の節で説明した ImageProxy オブジェクトは、virtual proxy の一例である。<br><br><li>protection proxy は、実オブジェクトへのアクセスを制御する。オブジェクトごとに異なるアクセス権が必要なときには、この protection proxy は有用である。たとえば、Choices オペレーティングシステム［CIRM93］の KernelProxy オブジェクトは、オペレーティングシステムのオブジェクトへのアクセスを保護する。<br><br><li>smart reference は、通常のポインタに代わるものである。オブジェクトがアクセスされるときに、その smart reference はさらにアクションを実行する。この proxy の典型的な使い方を以下にあげる。<br><br><ul><li>参照されなくなった実オブジェクトを自動的に解放できるように、実オブジェクトへの参照個数を数えておく（smart pointer とも呼ばれる［Ede92］）。<br><br><li>永続オブジェクトが初めて参照されたときに、それをメモリ上にロードする。<br><br><li>他のオブジェクトが実オブジェクトを変更することのないように、実オブジェクトがアクセスされる前に、それがロックされていることを確認する。</ul></ol></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/proxy017.gif"></p><br><br><br><font style="text-indent:10pt">　実行時に起こり得る proxy の構造を、次のインスタンスダイアグラムに示す。<br><br><br><p align="center"><img src="img/pics/proxy015.gif"></p></font></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Proxy クラス</b> （ImageProxyクラス）<ul><li> RealSubject オブジェクトにアクセスするための参照を保持する。RealSubject クラスのインタフェースと Subject クラスのインタフェースが等しい場合には、Proxy クラスは Subject のオブジェクトを参照するようにしておくこともできる。<li>Proxy オブジェクトを RealSubject オブジェクトと置き換えられるように、Subject クラスと同一のインタフェースを提供する。<li>RealSubject オブジェクトへのアクセスを制御する。また、RealSubject オブジェクトの生成や消去に責任を持つこともある。<li>他の責任は proxy の種類に依存する。<ul><li>remote proxy は、要求と引数を符合化し、それを別のアドレス空間に存在する RealSubject オブジェクトに送る。<li>virtual proxy は、RealSubject オブジェクトへのアクセスを延期できるように、RealSubject オブジェクトに関する追加情報をキャッシュしておく。たとえば、「動機」の節であげた ImageProxy オブジェクトは、実画像の大きさをキャッシュしている。<li>protection proxy は、呼び出し側がその要求を実行するのに必要なアクセス権を持っているかどうかをチェックする。</ul></ul><br><br><li><b>Subject クラス </b>（Graphic クラス）<ul><li>RealSubject オブジェクトを利用できるところならばどこでも Proxy オブジェクトを利用できるように、RealSubject クラスと Proxy クラスに共通のインタフェースを定義する。</ul><br><br><li><b>RealSubject クラス </b>（Image クラス）<ul><li>Proxy オブジェクトがその代理を務めることになる実オブジェクトを定義する。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Proxy オブジェクトは、その種類により、適切なタイミングで RealSubject オブジェクトに要求を転送する。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Proxy パターンを用いると、オブジェクトへのアクセスがある程度間接的になる。この間接的なアクセスは、proxy の種類によりさまざまな使われ方をする。<br><br><ol><li>remote proxy では、あるオブジェクトが異なるアドレス空間に属しているという事実を隠すことができる。<br><br><li>virtual proxy では、要求があり次第オブジェクトを生成する、といった最適化を行うことができる。<br><br><li>protection proxy と smart reference では、あるオブジェクトがアクセスされるときに、管理上の処理を追加して行うことができる。</ol><br><font style="text-indent:10pt">　これらの他にも、Proxy パターンがクライアントには見せずに行える最適化がある。それは copy-on-write と呼ばれるもので、要求があり次第オブジェクトを生成することと関連がある。大きくて複雑なオブジェクトをコピーするオペレーションはコストがかかる。しかし、もしコピーされたオブジェクトが変更されないのであれば、このコストを発生させる必要はない。コピーするプロセスを延期するために proxy を使えば、そのオブジェクトが変更されたときにのみ、そのオブジェクトをコピーすればよいようにできる。<br><font style="text-indent:10pt">　copy-on-write を機能させるためには、コピー元のオブジェクトが自身への参照数を数えておくようにしなければならない。proxy をコピーしてもこの参照数が増えるだけで、それ以外は何も起こらない。クライアントがコピー元オブジェクトを変更するオペレーションを要求したときだけ、proxy はコピー元のオブジェクトを実際にコピーする。この場合、proxy はコピー元のオブジェクトの参照数も減らさなければならない。参照数が0になったとき、そのオブジェクトは消去される。<br><font style="text-indent:10pt">　copy-on-write は、大きくて複雑なオブジェクトのコピーにかかるコストをかなり減らすことができる。</font></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Proxy パターンは次の言語特性を活用することができる。<br><br><ol><li><b>C++において、メンバアクセスオペレータをオーバーロードする。</b>C++はメンバアクセスオペレータ operator-&gt;のオーバーロードをサポートしている。このオペレータをオーバーロードすると、オブジェクトが参照されるときに処理を追加して実行することができるようになる。これはある種の proxy の実装に役立つ。これにより、proxy をあたかもポインタのように扱うことが可能になる。<br><font style="text-indent:10pt">　このテクニックを用いて ImagePtr と呼ばれる virtual proxy を実装する方法を、次の例で示す。<br><br><pre>    class Image;    extern Image* LoadAnImageFile(const char*);        // external function        class ImagePtr {    public:        ImagePtr(const char* imageFile);        virtual ~ImagePtr();            virtual Image* operator->();        virtual Image&amp; operator*();    private:        Image* LoadImage();    private:        Image* _image;        const char* _imageFile;    };        ImagePtr::ImagePtr (const char* theImageFile) {        _imageFile = theImageFile;        _image = 0;    }        Image* ImagePtr::LoadImage () {        if (_image == 0) {            _image = LoadAnImageFile(_imageFile);        }        return _image;    }</pre><br><br><font style="text-indent:10pt">　オーバーロードされた-&gt;オペレータと*オペレータは、呼び出し元に-image を返すために LoadImage オペレーションを利用する（画像がロードされていないときには、ロードする）。<br><br><pre>    Image* ImagePtr::operator-> () {        return LoadImage();    }        Image&amp; ImagePtr::operator* () {        return *LoadImage();    }</pre><br><br><font style="text-indent:10pt">　このアプローチでは、Image クラスのオペレーションを ImagePtr クラスのインタフェースでわざわざ定義しなくても、ImagePtr オブジェクトを通してそれらを呼び出すことができるようになる。<br><br><pre>    ImagePtr image = ImagePtr("anImageFileName");    image->Draw(Point(50, 100));          // (image.operator->())->Draw(Point(50, 100))</pre><br><br><font style="text-indent:10pt">　どのようにしてこの image proxy が Image オブジェクトへのポインタのように振る舞うのか、ということに注意してほしい。また、image proxy はポインタのように振る舞うが、実際にはポインタとして宣言されてはいないということにも注意してほしい。これは、image proxy を Image オブジェクトへの本当のポインタと完全に同じものとしては利用できないことを意味している。したがって、このアプローチでは、クライアントは Image オブジェクトと ImagePtr オブジェクトを異なるものとして扱わなければならない。<br><font style="text-indent:10pt">　メンバアクセスオペレータをオーバーロードする方法は、どのような種類の proxy に対しても良い解決になるとは限らない。ある種の proxy はどのオペレーションが呼び出されたのかを正確に知る必要がある。そのような場合、メンバアクセスオペレータをオーバーロードしてもうまく機能しない。<br><font style="text-indent:10pt">　「動機」の節で例示した virtual proxy を考えてみよう。画像はある特定のタイミングで（すなわち、Draw オペレーションが呼び出されたときに）ロードされるべきであり、画像が参照されるときにいつでもロードされるわけではない。アクセスオペレータのオーバーロードではこの区別ができない。この場合には、Image オブジェクトへ要求を転送する ImageProxy オブジェクトのオペレーションを、それぞれ手作業で実装しなければならない。<br><font style="text-indent:10pt">　「サンプルコード」の節で例示するように、これらのオペレーションは互いによく似ていることが多い。典型的には、すべてのオペレーションが RealSubject オブジェクトに要求を転送する前に、要求が正当かどうか、実オブジェクトは存在しているか、などを確かめる。そのためのコードを何度も記述するのは退屈な作業である。そこで、それを自動生成するためにプリプロセッサを用いるのが普通である。<br><br><li><b>Smalltalk において doesNotUnderstand を利用する。</b>Smalltalk は次のような要求の自動転送をサポートするためにフックを提供している。クライアントがあるメッセージを送ったが、その受け手がそのメッセージに対応するメソッドを持っていないとき、Smalltalk は doesNotUnderstand:aMessage を呼び出す。Proxy クラスは、そのメッセージが RealSubject オブジェクトに転送されるように doesNotUnderstand を再定義できる。<br><font style="text-indent:10pt">　要求が RealSubject オブジェクトにきちんと転送され、Proxy オブジェクトに吸収されてしまわないことを確実にするために、Proxy クラスがいかなるメッセージも理解しないように定義することができる。そのためには Smalltalk では、スーパークラスを持たないクラスとして Proxy クラスを定義すればよい。<br><font style="text-indent:10pt">　doesNotUnderstand: には次のような欠点がある。すなわち、ほとんどの Smalltalk システムは仮想マシンにより直接扱われる特別なメッセージをいくつか持っているが、これらに対しては通常のメソッド検索は行われない。このようなメッセージのうち、Object クラス内で実装できる（したがって proxy に影響し得る）のは、identity オペレーション==だけである。<br><font style="text-indent:10pt">　Proxy クラスの実装において doesNotUnderstand: を利用するのであれば、この問題に対処するような設計をしなければならない。Proxy オブジェクトの同一性が RealSubject オブジェクトの同一性を意味するとは限らないからである。また、この他にも不利な点がある。すなわち、doesNotUnderstand: は proxy を構築するためではなく、本来はエラー処理のためのものであるため、一般にはそれほど速くはない。<br><br><li><b>Proxy オブジェクトは RealSubject の型を常に知っている必要はない。</b> Proxy クラスが RealSubject オブジェクトを抽象インタフェースを通してのみ扱うことができるのであれば、各 RealSubject クラスごとに1つずつ Proxy クラスを作る必要はない。その場合には、1つの Proxy クラスはすべての RealSubject クラスを統一的に扱うことができるからである。しかし、Proxy クラスが RealSubject クラスをインスタンス化する場合（たとえば virtual proxy のように）には、Proxy クラスはその具象クラスを知っていなければならない。<br><font style="text-indent:10pt">　実装に関するもう1つの問題は、インスタンス化される前に RealSubject オブジェクトを参照する方法である。RealSubject オブジェクトがディスク上にあろうとメモリ上にあろうと、それを参照しなければならない Proxy オブジェクトもある。そのような Proxy オブジェクトは、アドレス空間に依存しない何らかの形式のオブジェクト識別子を利用しなければならない。「動機」の節では、このための識別子としてファイル名を利用した。</ol></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　以下に2種類の proxy を実装したコードを示す。1つは「動機」の節で説明した virtual proxy、もう1つは doesNotUnderstand: を用いて実装された proxy である。<br><br><ol><li>virtual proxy 。</b>Graphic クラスはグラフィックオブジェクトのインタフェースを定義する。<br><br><pre>    class Graphic {    public:        virtual ~Graphic();            virtual void Draw(const Point&amp; at) = 0;        virtual void HandleMouse(Event&amp; event) = 0;            virtual const Point&amp; GetExtent() = 0;            virtual void Load(istream&amp; from) = 0;        virtual void Save(ostream&amp; to) = 0;    protected:        Graphic();    };</pre><br><br><font style="text-indent:10pt">　Image クラスは、画像ファイルを表示するために、Graphic クラスで定義されたインタフェースを実装する。Image クラスは、ユーザが画像のサイズをインタラクティブに変更できるようにするため、HandleMouse オペレーションをオーバーライドする。<br><br><pre>    class Image : public Graphic {    public:        Image(const char* file);  // loads image from a file        virtual ~Image();            virtual void Draw(const Point&amp; at);        virtual void HandleMouse(Event&amp; event);            virtual const Point&amp; GetExtent();            virtual void Load(istream&amp; from);        virtual void Save(ostream&amp; to);    private:        // ...    };</pre><br><br><font style="text-indent:10pt">　ImageProxy クラスは Image クラスと同じインタフェースを持つ。<br><br><pre>    class ImageProxy : public Graphic {    public:        ImageProxy(const char* imageFile);        virtual ~ImageProxy();            virtual void Draw(const Point&amp; at);        virtual void HandleMouse(Event&amp; event);            virtual const Point&amp; GetExtent();            virtual void Load(istream&amp; from);        virtual void Save(ostream&amp; to);    protected:        Image* GetImage();    private:        Image* _image;        Point _extent;        char* _fileName;    };</pre><br><br><font style="text-indent:10pt">　コンストラクタは、画像を格納しているファイルの名前のコピーを保存し、-extent と-image を初期化する。<br><br><pre>    ImageProxy::ImageProxy (const char* fileName)  {        _fileName = strdup(fileName);        _extent = Point::Zero;  // don't know extent yet        _image = 0;    }        Image* ImageProxy::GetImage() {        if (_image == 0) {            _image = new Image(_fileName);        }        return _image;    }</pre><br><br><font style="text-indent:10pt">　GetExtent オペレーションは、可能ならば、-extent にキャッシュされている画像の大きさを返すように実装される。大きさがキャッシュされていない場合は、ファイルから画像がロードされる。また、Draw オペレーションは画像をロードし、HandleMouse オペレーションはそのイベントを実画像に転送する。<br><br><pre>    const Point&amp; ImageProxy::GetExtent () {        if (_extent == Point::Zero) {            _extent = GetImage()->GetExtent();        }        return _extent;    }        void ImageProxy::Draw (const Point&amp; at) {        GetImage()->Draw(at);    }        void ImageProxy::HandleMouse (Event&amp; event) {        GetImage()->HandleMouse(event);    }</pre><br><br><font style="text-indent:10pt">　Save オペレーションは、ImageProxy がキャッシュしている画像の大きさと画像ファイル名をストリームに保存する。Load オペレーションは、この情報を取り出し、対応するメンバを初期化する。<br><br><pre>    void ImageProxy::Save (ostream&amp; to) {        to &lt;&lt; _extent &lt;&lt; _fileName;    }        void ImageProxy::Load (istream&amp; from) {        from >> _extent >> _fileName;    }</pre><br><br><font style="text-indent:10pt">　最後に、Graphic オブジェクトを取り込むことのできる TextDocument クラスがあると仮定しよう。<br><br><pre>    class TextDocument {    public:        TextDocument();            void Insert(Graphic*);        // ...    };</pre><br><br><font style="text-indent:10pt">　次のようにして ImageProxy オブジェクトを TextDocument オブジェクトに挿入することができる。<br><br><pre>    TextDocument* text = new TextDocument;    // ...    text->Insert(new ImageProxy("anImageFileName"));</pre><br><br><li><b>doesNotUnderstand を用いた proxy 。</b>Smalltalk では、スーパークラスを持たないクラスを定義し、メッセージを処理するために doesNotUnderstand: メソッドを定義することにより、一般的な proxy を作ることができる。<font style="text-indent:10pt">　次のメソッドは proxy が realSubject メソッドを持つことを仮定している。realSubject メソッドとは、RealSubject オブジェクトを返すメソッドである。ImageProxy クラスの場合、このメソッドは Image オブジェクトが生成されているかどうかを確認し、生成されていなければそのオブジェクトを生成し、最後にそのオブジェクトを返す。また、このメソッドは、RealSubject オブジェクト上のメッセージを実行するために、perform:withArguments: を利用している。<br><br><pre>    doesNotUnderstand: aMessage        ^ self realSubject            perform: aMessage selector            withArguments: aMessage arguments</pre><br><br><font style="text-indent:10pt">　doesNotUnderstand: の引数は Message クラスのインスタンスで、それは proxy に理解されないメッセージを表している。したがって、proxy では、メッセージを RealSubject オブジェクトに転送するが、その前に RealSubject オブジェクトが存在していることを確認する。<br><font style="text-indent:10pt">　doesNotUnderstand: の利点の1つは、任意の処理を実行できることである。たとえば、protection proxy を作るには、受理可能なメッセージの集合 legalMessages を特定し、proxy に次のメソッドを定義すればよい。<br><br><pre>    doesNotUnderstand: aMessage        ^ (legalMessages includes: aMessage selector)            ifTrue: [self realSubject                perform: aMessage selector                withArguments: aMessage arguments]            ifFalse: [self error: 'Illegal operator']</pre><br><br><font style="text-indent:10pt">　このメソッドは、メッセージを RealSubject オブジェクトに転送する前に、そのメッセージが許可されているものかどうかをチェックする。そのメッセージが許可されていない場合には、このメソッドは proxy に error: を送る。しかし、もしこの proxy が error: を定義していなければ、エラー処理の無限ループに陥ってしまうだろう。したがって、proxy が利用するすべてのメソッドに、Object クラスから error: の定義をコピーしておく。</ol></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　「動機」の節で述べた virtual proxy は、ET++のテキスト構築ブロックのクラスからの例である。<br><font style="text-indent:10pt">　NEXTSTEP［Add94］は、分散されている可能性のあるオブジェクトのローカルな代表として proxy（NXProxy クラスのインスタンス）を利用している。クライアントの要求に応じて、サーバはリモートオブジェクトの proxy を生成する。proxy はクライアントからのメッセージを受け取ると、それを引数とともに符号化し、その符号化されたメッセージをリモートオブジェクトに転送する。同様に、リモートオブジェクトはリターン値を符号化して、proxy に送り返す。<br><font style="text-indent:10pt">　McCullough［McC87］は、Smalltalk においてリモートオブジェクトにアクセスするために proxy を利用することについて論じている。Pascoe［Pas86］は、“Encapsulators”を用いてメソッド呼び出しとアクセス制御に二次的な作用を及ぼす方法について述べている。</font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="06.html" target="down">Adapter パターン</a>: adapter は、オブジェクトに異なるインタフェースを提供する。それとは対照的に、proxy は RealSubject オブジェクトと同じインタフェースを提供する。しかし、アクセス保護のために使われる proxy は、RealSubject オブジェクトならば実行するであろうオペレーションの実行を拒否するかもしれない。したがって、実際上は、proxy のインタフェースは Subject クラスのインタフェースの一部かもしれない。<br><font style="text-indent:10pt">　<a href="09.html" target="down">Decorator パターン</a>: decorator は proxy と似た形態で実装されるが、両者の目的は異なる。decorator はあるオブジェクトに1つ、または複数の責任を追加する。一方 proxy は、あるオブジェクトへのアクセスを制御する。proxy が decorator のように実装される程度は、proxy の種類により異なる。protection proxy はd ecorator とまったく同じように実装されるかもしれない。一方、remote proxy は RealSubject オブジェクトへの直接参照を持たず、“ホストIDとそのホスト上でのローカルアドレス”などの間接参照だけを持つであろう。virtual proxy は、生成時にはファイル名などの間接参照のみを持つが、最後には直接参照を手に入れて使うようになる。</font></font><br><br><br></body></html>