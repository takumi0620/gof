<html><head><title>MEMENTO</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/mem.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　カプセル化を破壊せずに、オブジェクトの内部状態を捉えて外面化しておき、オブジェクトを後にこの状態に戻すことができるようにする。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Token</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　オブジェクトの内部状態を記録しておく必要がある場合がある。これは、チェックポイントや取り消しメカニズム（ユーザが試しに実行したオペレーションを取り消すことを可能にしたり、エラーからの復帰に使用する）を実装する際に必要になる。オブジェクトを以前の状態に戻すことができるようにするためには、状態に関する情報をどこかに保存しておかなければならない。しかし普通、オブジェクトは自身の状態の一部、またはすべてをカプセル化しているので、他のオブジェクトからこれにアクセスすることはできないし、また外部に保存することもできない。この状態を公開することは、カプセル化の原則を破り、アプリケーションの信頼性と拡張可能性を低めることになり得る。<br><font style="text-indent:10pt">　たとえば、オブジェクト間のつながりをサポートする図形エディタを考えてみよう。このエディタでは、ユーザは2つの長方形を線で結ぶことができ、さらにユーザがどちらか一方の長方形を移動したときにも2つの長方形は結ばれたままになる。すなわち、エディタは2つの長方形の関係を保つように線をつなげるようになっている。<br><br><br><p align="center"><img src="img/pics/memen029.gif"></p><br><br><br><font style="text-indent:10pt">　オブジェクト間の接続関係を保持するよく知られた方法は、制約解決システムで使われる。この機能は ConstraintSolver オブジェクトにカプセル化することができる。ConstraintSolver クラスは、オブジェクト同士が結ばれたときにその関係を記録し、それを表す数学的な等式を生成する。また、ユーザが関係を追加したとき、またはダイアグラムを修正したときには、これらの等式を解く。ConstraintSolver クラスは、関係を正しく保持するように図形を再配置するためにこの計算結果を使用する。<br><font style="text-indent:10pt">　このようなアプリケーションにおいて取り消しをサポートすることは、思うほど簡単ではない。移動操作を取り消すための明らかな方法は、移動距離を保存しておいてオブジェクトを同じ距離だけ元に戻すというものである。しかしこの方法では、すべてのオブジェクトが以前と同じように見えるようになるとは限らない。関係線の中にゆるみがあるとしよう。この場合、単純に長方形を元の場所に戻すだけでは必ずしも期待した結果を得ることはできないだろう。<br><br><br><p align="center"><img src="img/pics/memen028.gif"></p><br><br><br><font style="text-indent:10pt">　一般に、ConstraintSolver クラスの公開されたインタフェースは、他のオブジェクトに対する影響を正確に元に戻すには不十分かもしれない。取り消しのメカニズムは以前の状態を再構築するために ConstraintSolver クラスとより密接に連携していかなければならないが、ConstraintSolver の内部データを取り消しのメカニズムに対して公開することも避けるべきである。<br><font style="text-indent:10pt">　この問題は、Memento パターンを使って解決することができる。memento は、別のオブジェクト（memento の originator）の内部状態のスナップショットを保存するオブジェクトである。取り消しのメカニズムは、originator の状態をチェックしておく必要があるときには originator に memento を要求する。originator は、その時点の状態を特徴付ける情報で memento を初期化する。originator だけが、memento に情報を保存したり取り出したりすることができる（memento は他のオブジェクトに対しては“不透明”である）。<br><font style="text-indent:10pt">　前に論じた図形エディタの例では、ConstraintSolver オブジェクトを originator にすることができる。次のようなイベントのシーケンスが取り消しのプロセスを特徴付けている。<br><br><ol><li>エディタは、移動操作の際に ConstraintSolver オブジェクトに memento を要求する。<br><br><li>ConstraintSolver オブジェクトはこの場合、SolverState クラスのインスタンスを memento として生成し、これを返す。SolverState による memento は、ConstraintSolver オブジェクト内部の等式と変数の状態を表すためのデータ構造を含んでいる。<br><br><li>後にユーザが移動操作を取り消したときには、エディタは SolverState オブジェクトを ConstraintSolver オブジェクトに戻す。<br><br><li>SolverState オブジェクト内の情報に基づき、ConstraintSolver オブジェクトは、等式と変数を正確に前の状態に戻すために内部構造を変化させる。</ol><br><br><font style="text-indent:10pt">　この取り決めにより、ConstraintSolver オブジェクトは、内部の構造や表現を公開せずに、状態を元に戻すために必要な情報を他のオブジェクトに託すことになる。</font></font></font></font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次の2点がなり立つ場合にMemento パターンを使う。<br><br><ul><li>オブジェクトの状態（の一部）のスナップショットを、後にオブジェクトをその状態に戻すことができるように、セーブしておかなければならない場合。<br><br><li>状態を得るための直接的なインタフェースが、実装の詳細を公開し、オブジェクトのカプセル化を破壊する場合。></ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/memento.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Memento クラス</b> （SolverState クラス）<ul><li>Originator オブジェクトの内部状態を保存する。Memento オブジェクトは、Originator オブジェクトの内部状態のうち必要な部分だけを Originator オブジェクトの判断により保存する。<li>Originator 以外のオブジェクトによるアクセスから保護する。Memento クラスには2つのインタフェースが効果的に備わっている。Caretaker クラスには、Memento クラスの narrow インタフェースが見えるようになっている（それは Memento オブジェクトを他のオブジェクトに渡すことができるだけである）。それとは対照的に、Originator クラスには wide インタフェースが見えるようになっている。すなわち、そのインタフェースにより、Originator オブジェクトを前の状態に戻すために必要なすべてのデータにアクセスできるようになっている。理想的には、Memento オブジェクトを生成した Originator オブジェクトだけが Memento オブジェクトの内部構造にアクセスすることを許されるようにする。</ul><br><br><li><b>Originator クラス</b> （ConstraintSolver クラス）<ul><li>内部状態のスナップショットを入れておくために Memento オブジェクトを生成する。<li>内部状態を元に戻すために Memento オブジェクトを使う。</ul><br><br><li><b>Caretaker クラス</b> （取り消しのメカニズム）<ul><li>Memento オブジェクトを保管する責任がある。<li>Memento オブジェクトの内容を操作したり調べたりすることはない。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Caretaker オブジェクトは、Originator オブジェクトに対して Memento オブジェクトを要求し、しばらくそれを保持してから Originator オブジェクトに戻す。次のインタラクションダイアグラムはこの様子を説明している。<br><br><br><p align="center"><img src="img/pics/memen027.gif"></p><br><br><br><font style="text-indent:10pt">　ときには、Originator オブジェクトを前の状態に戻す必要がないために、Caretaker オブジェクトは Memento オブジェクトを Originator オブジェクトに戻さないこともあるだろう。<br><br><li>Memento オブジェクトは受動的である。Memento オブジェクトを生成した Originator オブジェクトだけが、その状態の設定や取得を行うことができる。</ul></font></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Memento パターンを適用すると、次のような結果になる。<br><br><ol><li><b>カプセル化の境界を保つ。</b>Memento クラスを使うことにより、Originator オブジェクトだけが管理すべきにもかかわらず Originator オブジェクトの外に保存しなければならない情報を、一般に公開するのを防ぐことができる。このパターンは、複雑になり得る Originator の内部を他のオブジェクトから隠し、カプセル化の境界を保つ。<br><br><li><b>Originator クラスを簡単なものにする。</b>カプセル化を保つためのその他の設計案としては、Originator クラスがその内部状態をクライアントが要求するごとにバージョンとして保存していく、というものがある。この案では、保存したものを管理する役目を Originator クラスにすべて任せることになる。このパターンで示すように、クライアントに状態を管理させれば Originator クラスを簡単にすることができ、状態が必要なときに、クライアントが Originator オブジェクトに対してそのことを知らせなくてもよくなる。<br><br><li><b>Memento オブジェクトを使うのはコストが高くつくかもしれない。</b>もし、Originator クラスが、大量の情報を Memento オブジェクト内に保存するためにコピーしなければならなかったり、クライアントが、Memento オブジェクトをしばしば生成してこれを Originator オブジェクトに戻すということを行っていれば、Memento オブジェクトはかなりのオーバーヘッドを引き起こすことになるだろう。もし、Originator オブジェクトの状態がカプセル化されており復元にコストがかかるとすると、このパターンは適切ではないかもしれない。「実装」の節で取り上げる「2. 新たな変化分のみを保存する」での議論を参照してほしい。<br><br><li><b>narrow インタフェースと wide インタフェースを定義する。</b>言語によっては、Originator オブジェクトだけが Memento オブジェクトの状態にアクセスできるようにするのは難しいかもしれない。<br><br><li><b>Memento オブジェクトを管理する際の隠れたコスト。</b>Caretaker オブジェクトには、管理している Memento オブジェクトを削除する責任がある。しかしながら Caretaker オブジェクトは、どれだけの状態がその Memento オブジェクトの中に入っているのかを知らない。したがって、本来小規模な Caretaker オブジェクトが Memento オブジェクトを保存する際に大きなコストがかかることになるかもしれない。</ol></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Memento パターンを実装するときに考えなければならない問題が2つある。<br><br><ol><li>言語のサポート。</b>Memento クラスには2つのインタフェースがある。すなわち、Originator オブジェクトのための wide インタフェースと、他のオブジェクトのための narrow インタフェースである。実装言語がこのような静的な保護の2つのレベルをサポートしているというのが理想である。C++では、Originator クラスを Memento のフレンドクラスにして Memento の wide インタフェースを私的に宣言することでこれを行う。narrow インタフェースだけが公開で宣言されるべきである。たとえば、次のようになる。<br><br><pre>    class State;        class Originator {    public:        Memento* CreateMemento();        void SetMemento(const Memento*);        // ...    private:        State* _state;      // internal data structures        // ...    };        class Memento {    public:        // narrow public interface        virtual ~Memento();    private:        // private members accessible only to Originator        friend class Originator;        Memento();            void SetState(State*);        State* GetState();        // ...    private:        State* _state;        // ...    };</pre><br><br><li><b>新たな変化分のみを保存する。</b>複数の Memento オブジェクトが生成され、これらがあらかじめ決められたシーケンスで Originator オブジェクトに戻されていくときには、Memento オブジェクトは、Originator オブジェクトの内部状態に関して新たな変化分のみを保存しておけばよい。<br><font style="text-indent:10pt">　たとえば、履歴リスト内の取り消し可能な Command オブジェクトは、実際に取り消しが行われたときに元の状態を正確に復元することができるように、Memento オブジェクトを使うことができる（<a href="14.html" target="down">Command パターン</a>を参照）。履歴リストは、Command オブジェクトを取り消したり再実行することができるように、特別の順番を定義している。このため、Memento オブジェクトは各オブジェクトの状態をすべて保存するのではなく、Command オブジェクトが新たに変化を加えた状態のみを保存しておけばよいことになる。先に与えた「動機」の節の例では、ConstraintSolver オブジェクトは、長方形や線の絶対的な位置を保存するのではなく、線が常に長方形をつなぐ形で引かれるようにするために変えなければならない内部構造のみを保存すればよい。</ol></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　ここであげるC++のコードは、先に論じた ConstraintSolver クラスの例を説明している。図形オブジェクトを1つの場所から別の場所に移動する MoveCommand オブジェクト（<a href="14.html" target="down">Command パターン</a>を参照）を使う。図形エディタは MoveCommand オブジェクトに対して、図形オブジェクトを移動するために Execute オペレーション、移動を取り消すために Unexecute オペレーションを呼び出す。MoveCommand オブジェクトは、操作対象、移動距離、ConstraintSolver オブジェクトの状態を保存する memento として、ConstraintSolverMemento クラスのインスタンスを保持している。<br><br><pre>    class Graphic;        // base class for graphical objects in the graphical editor        class MoveCommand {    public:        MoveCommand(Graphic* target, const Point&amp; delta);        void Execute();        void Unexecute();    private:        ConstraintSolverMemento* _state;        Point _delta;        Graphic* _target;    };</pre><br><br><font style="text-indent:10pt">　接続に関する制約は ConstraintSolver クラスにより確立される。キーとなるメンバ関数は Solveであり、これは AddConstraint オペレーションにより登録された制約を解く。取り消しをサポートするため、CreateMemento オペレーションにより、ConstraintSolver オブジェクトの状態を外部の ConstraintSolverMemento オブジェクトの中に保存しておくことができる。SetMemento オペレーションを呼び出すことにより、ConstraintSolver オブジェクトを前の状態に戻すことができる。<br><font style="text-indent:10pt">　ConstraintSolver は Singleton クラスである。<br><br><pre>    class ConstraintSolver {    public:        static ConstraintSolver* Instance();            void Solve();        void AddConstraint(            Graphic* startConnection, Graphic* endConnection        );        void RemoveConstraint(            Graphic* startConnection, Graphic* endConnection        );            ConstraintSolverMemento* CreateMemento();        void SetMemento(ConstraintSolverMemento*);    private:        // nontrivial state and operations for enforcing        // connectivity semantics    };        class ConstraintSolverMemento {    public:        virtual ~ConstraintSolverMemento();    private:        friend class ConstraintSolver;        ConstraintSolverMemento();            // private constraint solver state    };</pre><br><br><font style="text-indent:10pt">　これらのインタフェースの中で、MoveCommand クラスのメンバである Execute と Unexecute は、次のように実装することができる。<br><br><pre>    void MoveCommand::Execute () {        ConstraintSolver* solver = ConstraintSolver::Instance();        _state = solver->CreateMemento(); // create a memento        _target->Move(_delta);        solver->Solve();    }        void MoveCommand::Unexecute () {        ConstraintSolver* solver = ConstraintSolver::Instance();        _target->Move(-_delta);        solver->SetMemento(_state); // restore solver state        solver->Solve();    }</pre><br><br><font style="text-indent:10pt">　Execute オペレーションは、図形を移動する前に ConstraintSolverMemento オブジェクトを取得する。Unexecute オペレーションは、図形を元の位置に戻し、ConstraintSolver オブジェクトに前の状態を設定し、最終的に ConstraintSolver オブジェクトに制約を解くように指示を出す。</font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　「サンプルコード」の節の例は、Unidraw における CSolver クラス［VL90］を使った接続性のサポートを基にしている。<br><font style="text-indent:10pt">　Dylan［App92］のコレクションクラスは、Memento パターンを反映した iteration のためのインタフェースを提供している。Dylan のコレクションクラスは“状態”オブジェクトの概念を持っている。このオブジェクトは iteration の状態を表現する memento である。各コレクションクラスは、iteration の状態を、選択した方法で表現することができる。その表現はクライアントから完全に隠されている。Dylan での iteration のアプローチは、C++に次のように変換されるだろう。<br><br><pre>    template &lt;class Item>    class Collection {    public:        Collection();            IterationState* CreateInitialState();        void Next(IterationState*);        bool IsDone(const IterationState*) const;        Item CurrentItem(const IterationState*) const;        IterationState* Copy(const IterationState*) const;            void Append(const Item&amp;);        void Remove(const Item&amp;);        // ...    };</pre><br><br><font style="text-indent:10pt">　CreateInitialState オペレーションは、Collection オブジェクトのために、初期化した IterationState オブジェクトを返す。Next オペレーションは、 IterationState オブジェクトが iter ation の次のステップを表現するように書き換える。事実上、このオペレーションが iteration のインデックスを増やしていくことになる。IsDone オペレーションは、Next オペレーションが Collection オブジェクトの最後の要素を越えてさらに先に進もうとした場合、true を返す。CurrentItem オペレーションは、IterationState オブジェクトを参照して、それが指している Collection オブジェクト内の要素を返す。Copy オペレーションは、引数で与えられた IterationState オブジェクトのコピーを返す。これは iteration のある時点での状態をマークしておくのに便利である。<br><font style="text-indent:10pt">　ItemType クラスが与えられたとき、そのインスタンスからなる Collection オブジェクト上で、次のように iteration をかけることができる。<br><br><pre>    class ItemType {    public:        void Process();        // ...    };        Collection&lt;ItemType*> aCollection;    IterationState* state;        state = aCollection.CreateInitialState();        while (!aCollection.IsDone(state)) {        aCollection.CurrentItem(state)->Process();        aCollection.Next(state);    }    delete state;</pre><br><br><font style="text-indent:10pt">　memento に基づいた iteration のインタフェースには、2つの興味深い利点がある。<br><br><ol><li>複数の状態を同一のコレクションオブジェクトに対して作用させることができる（<a href="16.html" target="down">Iterator パターン</a>にも同じことが言える）。<br><br><li>iteration をサポートするために、コレクションオブジェクトのカプセル化を破る必要はない。memento は、コレクションオブジェクトにより解釈されるだけである。他のオブジェクトはこれにアクセスしない。iteration に関する他のアプローチとしては iterator クラスの導入が考えられるが、その場合には iterator クラスをコレクションクラスのフレンドクラスにするために、カプセル化を破ることになる（<a href="16.html" target="down">Iterator パターン</a>を参照）。この状況は memento に基づいた実装では逆になる。すなわち、Collection クラスを IteratorState クラスのフレンドクラスにする。</ol><br><br><font style="text-indent:10pt">　QOCA 制約解決ツールキットでは、状態の中で新たに変化した部分の情報を memento に保存する［HHMV92］。クライアントは、システムの制約に対するその時点での解を記述した memento を得ることができる。その memento には、制約変数の中で1つ前の解から変わったものだけが入っている。通常は、新たな解が出されるたびに制約変数のほんの一部が変わるにすぎない。この一部を記録しておくだけで solver を1つ前の解に戻すことができる。さらに前の解に戻すためには、その間の解を記録した memento を使って1つ1つ前の解に戻していく必要がある。したがって、memento を適当な順番に並べることはできない。QOCA では、以前の解に戻れるようにするために履歴メカニズムを使っている。</font></font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="14.html" target="down">Command パターン</a>: command は、取り消し可能なオペレーションのために状態を保存しておくのに memento を使うことができる。<br><font style="text-indent:10pt">　<a href="16.html" target="down">Iterator パターン</a>: 前に述べたように、memento を iteration のために使うことができる。</font></font><br><br><br></body></html>