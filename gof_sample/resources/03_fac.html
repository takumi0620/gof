<html><head><title>FACTORY METHOD</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/fac.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　オブジェクトを生成するときのインタフェースだけを規定して、実際にどのクラスをインスタンス化するかはサブクラスが決めるようにする。Factory Method パターンは、インスタンス化をサブクラスに任せる。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Virtual Constructor</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　フレームワークでは、オブジェクト間の関係を定義したり維持するために、抽象クラスを用いている。また、フレームワークにオブジェクトの生成を行う責任がしばしば与えられる。<br><font style="text-indent:10pt">　ユーザに複数の文書を提示することのできるアプリケーションのためのフレームワークを考えよう。このフレームワークで重要なのは、Application クラスと Document クラスの抽出という点である。この両者は抽象クラスであるため、これらを利用するクライアントは、アプリケーションに特化した実装を実現するために、それらをサブクラス化しなければならない。たとえば、描画アプリケーションを作成するためには、DrawingApplication クラスと DrawingDocument クラスを定義する。Application クラスは Document のオブジェクトの管理を担当し、たとえばユーザがメニューから Open や New を選択した場合に、Document のオブジェクトを生成することになる。<br><font style="text-indent:10pt">　インスタンス化される Document のサブクラスはアプリケーションに特化されたものなので、Application クラスは Document のどのサブクラスがインスタンス化されるのかを事前に知ることはできない。Application クラスが知っているのは、いつ Document のオブジェクトを新たに生成すべきかということだけである。このことは、フレームワークはクラスをインスタンス化しなければならないにもかかわらず、インスタンス化することができない抽象クラスに関する情報だけしか持たない、というジレンマを生む。</font></font></font><br><br><br><p align="center"><img src="img/pics/fmeth049.gif" hspace="40"></p><br><br><br><font style="margin-left:40px;text-indent:10pt">　Factory Method パターンは、この問題に対する解決策を提供する。このパターンでは、Document のどのサブクラスをインスタンス化するのかに関する知識を隠ぺいして、これをフレームワークの外に出している。<br><font style="text-indent:10pt">　Application のサブクラスでは、Application クラスのオペレーション CreateDocument を、Document の適切なサブクラスのインスタンスを返すように再定義する。Application のサブクラスはひとたびインスタンス化されると、アプリケーションに特化した Document のサブクラスを、そのクラスについては何も知らないままインスタンス化することができる。このような CreateDocument オペレーションのことを factory method と呼ぶ。その理由は、これがオブジェクトを“生産”するための factory （工場）のように使われるからである。</font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Factory Method パターンは、次のような場合に用いることができる。<p><ul><li>クラスが、生成しなければならないオブジェクトのクラスを事前に知ることができない場合。<p><li>サブクラス化により、生成するオブジェクトを特定化する場合。<p><li>クラスが責任をいくつかのサブクラスの中の1つに委譲するときに、どのサブクラスに委譲するのかに関する知識を局所化したい場合。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><p align="center"><img src="img/pics/fmethod.gif" hspace="40"></p><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Product クラス </b>（ Document クラス）<ul> <li>factory method が生成するオブジェクトのインタフェースを定義する。</ul><br><br><li><b>ConcreteProduct クラス </b>（ MyDocument クラス）<ul><li>Product クラスのインタフェースを実装する。</ul><br><br><li><b>Creator クラス </b>（ Application クラス）<ul><li>Product 型のオブジェクトを返す factory method を宣言する。また、ある Concrete Product オブジェクトを返すように factory method の実装をデフォルトで定義することもある。<li>Product のオブジェクトを生成するために factory method を呼び出す。</ul><br><br><li><b>ConcreteCreator クラス </b>（ MyApplication クラス）<ul><li>ConcreteProduct クラスのインスタンスを返すように、factory method をオーバーライドする。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Creatorクラスは、そのサブクラスで、factory method を用いて適切な ConcreteProduct クラスのインスタンスを返すように定義している。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　factory method は、アプリケーションに特化したクラスをコード内に埋め込む必要がないようにする。コード内では、Product クラスのインタフェースしか扱わないため、ユーザが定義する任意の ConcreteProduct クラスと強調させることが可能になる。<br><font style="text-indent:10pt">　factory method の潜在的な問題点として、特定の ConcreteProduct オブジェクトを生成するために、クライアントが Creator のサブクラスを作らなければならない、ということがあげられる。この点は、クライアントが Creator のサブクラス化をどうしても行わなければならない場合には問題にならないが、そうでない場合には改良を考えなければならない。<br><font style="text-indent:10pt">　さらに、Factory Method パターンの結果を説明する。<br><br><ol><li><b>サブクラスに手がかりを提供する。</b>クラス内部でオブジェクトを生成する場合、直接生成するよりも factory method を使う方が柔軟性を高めることになる。factory method は、オブジェクトを拡張する場合の手がかりをサブクラスに提供している。<br><font style="text-indent:10pt">　Document クラスの例では、既存の文書をオープンする際にデフォルトのファイルダイアログオブジェクトを生成する CreateFileDialog という factory method が、Document クラスに定義される。Document のサブクラスでは、この factory method をオーバーライドすることにより、アプリケーションに特化したファイルダイアログを定義することができる。この場合には、factory method は抽象的なものではなく、適当な実装をデフォルトで提供するものになっている。<p><li><b>パラレルなクラス階層をつなぐ。</b>これまでに見てきた例では、factory method は Creator のオブジェクトのみから呼び出される。しかし、このような使い方に限定されているわけではなく、特にパラレルなクラス階層が存在する場合に、クライアントにとって factory method は有効である。<br><font style="text-indent:10pt">　パラレルなクラス階層は、あるクラスがその責任の一部を別のクラスに委譲する場合に発生する。マウスを使って拡大したり、移動したり、回転させたりといった対話的な操作が可能な図形オブジェクトを考えよう。このような対話的な操作の実装は容易なわけではない。ある時点におけるオ操作の状態を記録した情報を保存/更新する必要がしばしば起こる。このような状態は、操作のときにだけ必要になるので、図形オブジェクト内部に保持しておく必要はない。さらに、図形が異なるとユーザが操作したときの動作が異なる。たとえば、直線オブジェクトの拡大操作では終点が移動するが、テキストオブジェクトの拡大操作では行間隔が拡大される。<br><font style="text-indent:10pt">　このような状況では、対話的な操作を実装し、各操作ごとに必要になる状態を維持するために、Manipulator クラスを使うのが適切である。図形が異なれば、Manipulator の異なるサブクラスが特定の対話的な操作を扱うために使われる。結果的に、Figure クラス階層と（少なくとも部分的に）パラレルな Manipulator クラス階層ができあがることになる。<br><br><br><p align="center"><img src="img/pics/fmeth048.gif" hspace="0"></p><br><br><br><font style="text-indent:10pt">　クライアントが Figure のオブジェクトに応じた Manipulator のオブジェクトを生成することができるように、Figure クラスは、factory method として CreateManipulatorFigure を提供している。Figure のサブクラスは、Manipulator の適切なサブクラスのインスタンスを返すように、この factory method をオーバーライドする。また、Figure クラスの CreateManipulator を、デフォルトで Manipulator クラスのインスタンスを返すように実装しておき、Figure のサブクラスには単にそれを継承させるようにすることもできる。この場合には、Figure のサブクラスは対応する Manipulator のサブクラスを必要としない。したがって、2つのクラス階層は部分的にパラレルであるにすぎない。<br><font style="text-indent:10pt">　factory method が2つのクラス階層の間の関係をどのように定義しているかに注意してほしい。それはクラスの組み合わせに関する知識を局所化している。</ol></font></font></font></font></font></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Factory Method パターンを適用する場合には、次の問題を考慮する。<p><ol><li><b>2通りの実現方法がある。</b>Factory Method パターンには、代表的な実現方法が2通りある。(1) Creator が抽象クラスであり、宣言される factory method に対して実装を与えない方法と、(2) Creator が具象クラスであり、factory method にデフォルトの実装を与える方法である。抽象クラスでデフォルトの実装を定義しておくことも可能だが、前記の2つの方法に比べて一般的ではない。<br><font style="text-indent:10pt">　(1)の方法では、デフォルトで与えておくべき実装が存在しないので、サブクラスごとに実装を定義する必要がある。これは、振る舞いを予測できないクラスをインスタンス化しなければならないというジレンマを回避することになる。(2)の方法では、具象クラスである Creator は主に柔軟性のために factory method を利用することになる。これは、“オブジェクトの生成は、サブクラスでその生成方法をオーバーライドできるように、1つのオペレーション内にまとめておく”というルールに従っていることになる。このルールに従えば、サブクラスの設計者は、必要に応じて、親クラスがインスタンス化するオブジェクトのクラスを変更できるようになる。<p><li><b>factory method をパラメータ化する。</b>このパターンの変形として、factory method が数種類の ConcreteProduct オブジェクトを生成できるようにしておくこともできる。factory method は、生成するオブジェクトの種類を識別するためにパラメータを取る。factory method が生成するすべてのオブジェクトは共通して Product クラスのインタフェースを持つことになる。先の Document クラスの例では、アプリケーションはさまざまな種類の文書を扱うことになるだろう。そこで、作成すべき文書の種類を示す特別なパラメータを CreateDocument オペレーションに渡すことにする。<br><font style="text-indent:10pt">　Unidraw の図形編集フレームワーク［VL90］では、ディスク上に保存されているオブジェクトを再生成するためにこのアプローチを採用している。Unidraw では、Creator クラスで、factory method として、クラス識別子をパラメータに取る Create を定義している。クラス識別子はインスタンス化すべきクラスを表している。Unidraw がオブジェクトをディスク上に保存する場合には、クラス識別子をまず初めに書き込み、次にインスタンス変数を書き込む。ディスクからオブジェクトを再生成する場合には、クラス識別子が最初に読み込まれる。<br><font style="text-indent:10pt">　ひとたびクラス識別子が読み込まれると、このフレームワークはその識別子をパラメータとして Create オペレーションを呼び出す。Create オペレーションはその識別子に対応するクラスのコンストラクタを探して、それをオブジェクトのインスタンス化に利用する。最終的には、Create オペレーションはオブジェクトの Read オペレーションを呼び出し、ディスク上の残りの情報を読み込んで、オブジェクトのインスタンス変数を初期化する。<br><font style="text-indent:10pt">　パラメータ化された factory method は次のような一般形を持つ。ここで、MyProduct と YourProduc tは Product のサブクラスである。<p><pre>    class Creator {    public:        virtual Product* Create(ProductId);    };        Product* Creator::Create (ProductId id) {        if (id == MINE)  return new MyProduct;        if (id == YOURS) return new YourProduct;        // repeat for remaining products...            return 0;    }</pre><p><font style="text-indent:10pt">　パラメータ化された factory method をオーバーライドすることで、Creator クラスが作成するオブジェクトの種類を増やしたり変えたりすることが容易に行えるようになる。新たなクラスに対して新たな識別子を与えることもできるし、既存の識別子を別のクラスに割り当て直すこともできる。<br><font style="text-indent:10pt">　たとえば、サブクラス MyCreator において、MyProduct クラスと YourProduct クラスを取り換えたり、新たなサブクラス TheirProduct を扱えるようにすることができる。<p><pre>    Product* MyCreator::Create (ProductId id) {        if (id == YOURS)  return new MyProduct;        if (id == MINE)   return new YourProduct;            // N.B.: switched YOURS and MINE            if (id == THEIRS) return new TheirProduct;            return Creator::Create(id); // called if all others fail    }</pre><p><font style="text-indent:10pt">　上記のコードにおいて、最後に親クラスの Create オペレーションが呼び出されていることに注意してほしい。これは、MyCreator::Create オペレーションが親クラスとは異なった処理を行うのは、YOURS、MINE、THEIRS の場合だけだからである。それ以外のクラスについては関与しない。そこで、MyCreator クラスは、生成されるオブジェクトの種類を増やし、自分が関与しないクラスについては、そのインスタンス化を行う責任を親クラスに委譲する。<p><li><b>実装言語に特有の変形と問題点。</b>実装に用いる言語により、興味深い変形や注意すべき点が生じる。<br><font style="text-indent:10pt">　Smalltalk プログラムではしばしば、インスタンス化されるクラスを返すメソッドを使う。Creator クラスの factory method はこのメソッドの値をオブジェクトを生成するために利用し、ConcreteCreator クラスがこの値を格納したり、場合によっては計算したりする。これにより、インスタンス化される ConcreteProduct の型を実行時に決められるようになる。<br><font style="text-indent:10pt">　Document クラスの例を Smalltalk で実現する場合には、Application クラスに documentClass メソッドを定義することができる。documentClass メソッドは、Document オブジェクトを生成するために Document クラスを返す。MyApplication クラスにおける documentClass メソッドの実装では、MyDocument クラスを返すようになっている。したがって、Application クラスは次のようになる。<p><pre>    clientMethod        document := self documentClass new.        documentClass        self subclassResponsibility</pre><p><font style="text-indent:10pt">　MyApplication クラスでは、インスタンス化する Mydocument クラスを Application クラスに返す次のような部分がある。<p><pre>    documentClass        ^ MyDocument</pre><p><font style="text-indent:10pt">　パラメータ化された factory method に類似の柔軟な方法として、Application クラスのクラス変数に、インスタンス化するクラスを格納しておくことがあげられる。この方法では、生成するオブジェクトを変えるために Application クラスをサブクラス化する必要はなくなる。<br><font style="text-indent:10pt">　C++による factory method は、常に仮想関数であり、さらに純粋仮想関数である場合も多い。Creator クラスのコンストラクタ内で factory method を呼び出さないように注意しなければならない。なぜならば、ConcreteCreator クラスの factory method を利用することはまだできないからである。<br><font style="text-indent:10pt">　ConcreteProduct オブジェクトにアクセスする際には、要求に応じて ConcreteProduct オブジェクトを生成するアクセスオペレーションを通してのみ行うように注意することで、この問題を回避することができる。コンストラクタは ConcreteProduct オブジェクトを生成する代わりに、単に0に初期化することだけを行う。アクセスオペレーションが ConcreteProduct オブジェクトを返す。その際に、まず初めに ConcreteProduct オブジェクトが実際に存在することを確認し、存在しない場合にはアクセスオペレーションがそれを生成する。このテクニックは、lazy initialization と呼ばれる。次に示すコードは典型的な実装例である。　　　　　<p><pre>    class Creator {    public:        Product* GetProduct();    protected:        virtual Product* CreateProduct();    private:        Product* _product;    };        Product* Creator::GetProduct () {        if (_product == 0) {            _product = CreateProduct();        }        return _product;    }</pre><p><li><b>テンプレートを用いてサブクラス化を避ける。</b>先に述べたように、factory method の潜在的な問題点として、適切な ConcreteProduct オブジェクトを生成するためにサブクラスを作成しなければならない点をあげることができる。C++でこれを回避するための方法として、Product のクラスによりパラメータ化されるCreator のテンプレートサブクラスを用意することがあげられる。<p><pre>    class Creator {    public:        virtual Product* CreateProduct() = 0;    };        template &lt;class TheProduct>    class StandardCreator: public Creator {    public:        virtual Product* CreateProduct();    };        template &lt;class TheProduct>    Product* StandardCreator&lt;TheProduct>::CreateProduct () {        return new TheProduct;    }</pre><p><font style="text-indent:10pt">　このテンプレートを用いる場合、クライアントは Product のクラスだけを提供すればよい。Creator のサブクラスは必要なくなる。<p><Pre>    class MyProduct : public Product {    public:        MyProduct();        // ...    };        StandardCreator&lt;MyProduct> myCreator;</pre><p><li><b>名前の付け方に関する慣習。</b>factory method を使っていることが明らかになるように、命名規則を決めてそれに従うようにすると便利である。たとえば、Macintosh の MacApp［App89］では、factory method を定義する抽象オペレーションを常に Class* DoMakeClass（）で宣言するようにしている。ここで、ClassはProduct のクラスである。</ol></ol></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　CreateMaze オペレーション（92ページ）は、迷路を作成してそれを返す。このオペレーションの問題点は、迷路、部屋、ドア、壁の各クラスがコード上に直接現れていることである。factory method を使って、これらの要素の選択をサブクラスが行えるようにする。<br><font style="text-indent:10pt">　まず最初に、MazeGame クラスで、迷路、部屋、壁、ドアの各オブジェクトを生成するために、factory method を定義する。<p><pre>    class MazeGame {    public:        Maze* CreateMaze();        // factory methods:            virtual Maze* MakeMaze() const            { return new Maze; }        virtual Room* MakeRoom(int n) const            { return new Room(n); }        virtual Wall* MakeWall() const            { return new Wall; }        virtual Door* MakeDoor(Room* r1, Room* r2) const            { return new Door(r1, r2); }    };</pre><p><font style="text-indent:10pt">　各 factory method は、指定された型の迷路の要素を返す。MazeGame クラスでは、もっとも単純な迷路、部屋、壁、ドアを返す実装がデフォルトで与えられる。<br><font style="text-indent:10pt">　この factory method を使って、CreateMaze オペレーションを書き換えると次のようになる。<p><pre>    Maze* MazeGame::CreateMaze () {        Maze* aMaze = MakeMaze();            Room* r1 = MakeRoom(1);        Room* r2 = MakeRoom(2);        Door* theDoor = MakeDoor(r1, r2);            aMaze->AddRoom(r1);        aMaze->AddRoom(r2);            r1->SetSide(North, MakeWall());        r1->SetSide(East, theDoor);        r1->SetSide(South, MakeWall());        r1->SetSide(West, MakeWall());            r2->SetSide(North, MakeWall());        r2->SetSide(East, MakeWall());        r2->SetSide(South, MakeWall());        r2->SetSide(West, theDoor);            return aMaze;    }</pre><p><font style="text-indent:10pt">　迷路の要素を変更して別のゲームを作成するためには、MazeGame のサブクラスを作ればよい。サブクラスでは、生成する要素を変えるために、factory method の一部あるいは全体を再定義する。たとえば、BombedMazeGame クラスにおいては、Room クラスや Wall クラスが爆弾を扱うことができるように再定義される。<p><pre>    class BombedMazeGame : public MazeGame {    public:        BombedMazeGame();            virtual Wall* MakeWall() const            { return new BombedWall; }            virtual Room* MakeRoom(int n) const            { return new RoomWithABomb(n); }    };</pre><p><font style="text-indent:10pt">　同様に、EnchantedMazeGame クラスにおいては、次のように定義されるだろう。<p><pre>    class EnchantedMazeGame : public MazeGame {    public:        EnchantedMazeGame();            virtual Room* MakeRoom(int n) const            { return new EnchantedRoom(n, CastSpell()); }            virtual Door* MakeDoor(Room* r1, Room* r2) const            { return new DoorNeedingSpell(r1, r2); }    protected:        Spell* CastSpell() const;    };</pre></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　factory method は、ツールキットやフレームワークの中で広く使用されている。先に説明した Document クラスの例は、MacApp や ET++［WGM88］での典型的な使用例である。図形操作の例は、Unidraw から採用した。<br><font style="text-indent:10pt">　Smalltalk-80 における Model / View / Controller フレームワーク中の View クラスは、Controller オブジェクトを生成する defaultController メソッドを持っており、これは factory method として捉えることもできる［Par90］。　しかし、View のサブクラスごとに defaultControllerClass メソッドを、defaultController メソッドでインスタンス化されるクラスを返すように定義しているので、実際には、defaultControllerClass が factory method、すなわちサブクラスがオーバーライドすべきメソッドになっていると言える。<br><font style="text-indent:10pt">　Smalltalk-80 におけるより複雑な例としては、Behavior クラス（クラスを表現するすべてのオブジェクトのスーパークラス）により定義される factory method である parserClass がある。これにより、あるクラスが自身のソースコードのために専用パーザを使うことが可能になる。たとえばクライアントは、SQL 文が埋め込まれているソースコードを持つクラスを解析するために、SQLParser クラスを定義することができる。Behavior クラスでは、Smalltalk における標準の Parser クラスを返すように parserClass を実装している。そこで、SQL 文が埋め込まれているクラスでこのメソッドを（クラスメソッドとして）オーバーライドして、SQLParser クラスを返すようにする。<br><font style="text-indent:10pt">　IONA Technologies 社の OrbixORB システム［ION94］では、あるオブジェクトがリモートオブジェクトへの参照を要求した場合に、適切な型の proxy（ <a href="12.html" target="down">Proxy パターン</a>を参照）を生成するために Factory Method パターンを用いている。Factory Method パターンにより、デフォルトの proxy を、たとえばクライアント側でリモートオブジェクトの内容を一時的にキャッシュしておくような proxy に置き換えることが容易になる。</font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="01.html" target="down">Abstract Factory パターン</a>: factory method を使って実装されることが多い。<a href="01.html" target="down">Abstract Factory パターン</a>の「動機」の節の例では、Factory Method パターンについても説明している。<br><font style="text-indent:10pt">　<a href="22.html" target="down">Template Method パターン</a>: factory method は通常、template method の中で呼ばれる。Document クラスの例では、NewDocument オペレーションが template method である。<br><font style="text-indent:10pt">　<a href="04.html" target="down">Prototype パターン</a>: <a href="04.html" target="down">Prototype パターン</a>により、Creator クラスをサブクラス化する必要はなくなるが、代わりに Product クラスにしばしば初期化オペレーションが必要になる。一方、Factory Method パターンでは初期化オペレーションは必要ない。</font><br><br><br></body></html>