<html><head><title>FACADE</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/faca.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　サブシステム内に存在する複数のインタフェースに1つの統一インタフェースを与える。Facade パターンはサブシステムの利用を容易にするための高レベルインタフェースを定義する。</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　1つのシステムを複数のサブシステムに分割して構築することは、システムの複雑さを軽減するのに役立つ。このサブシステム化においては、サブシステム間のやりとりや依存関係を最小にすることが共通の設計目標である。この目標を達成する方法の1つに facade オブジェクトの導入がある。facade オブジェクトはサブシステムの持つより汎用的な機能に、1つの単純なインタフェースを提供する。<br><br><br><p align="center"><img src="img/pics/facad057.gif"></p><br><br><br>例として、コンパイラサブシステムを持ち、そのコンパイラサブシステムにアプリケーションがアクセスできるようなプログラミング環境を考えよう。このサブシステムは、コンパイラを実装するクラスとして Scanner クラス、Parser クラス、ProgramNode クラス、BytecodeStream クラス、ProgramNodeBuilder クラスなどを含んでいる。ある特殊なアプリケーションはこれらのクラスに直接アクセスする必要があるかもしれない。しかし、通常このコンパイラのクライアントのほとんどは、構文解析やコード生成などの詳細には関心がない。ほとんどのクライアントは単にコードをコンパイルしてほしいだけである。そのようなクライアントにとっては、コンパイラサブシステムの強力だが低レベルなインタフェースは、彼らの作業を複雑にするだけである。<br><font style="text-indent:10pt">　そこで、クライアントがこれらのクラスを直接扱わなくても済むような高レベルインタフェースを提供するために、このコンパイラサブシステムは Compiler クラスを持つ。Compiler クラスはコンパイラの機能に統一のインタフェースを定義しており、facade として振る舞う。すなわち、Compiler クラスはコンパイラサブシステムへの1つの単純なインタフェースをクライアントに提供する。Compiler クラスはコンパイラの機能を実装しているクラスをまとめているが、それらのクラスを完全には隠していない。つまり、コンパイラの facade はほとんどのプログラマの作業を簡単にし、しかも、低レベルな機能を必要としている少数のプログラマに対してそれらの機能を隠すようなことはしない。<br><br><br><p align="center"><img src="img/pics/facad058.gif"></p></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のような場合に Facade パターンを利用する。<br><br><ul><li>複雑なサブシステムに単純なインタフェースを提供したい場合。サブシステムは発展するにつれて、より複雑になっていく。たいていのパターンは、適用するとたくさんの小さなクラスが導入されることになる。それにより、サブシステムの再利用性が増し、カスタマイズも容易になる。しかしその一方で、サブシステムをカスタマイズする必要のないクライアントにとっては、そのサブシステムの利用が難しくなる。このような場合に、facade はサブシステムの単純なデフォルトのビューを提供してくれる。ほとんどのクライアントにとってはこのデフォルトのビューだけで十分である。サブシステムをカスタマイズする必要のあるクライアントだけが、facade を越えてサブシステムの内部まで見ることになる。<br><br><li>ある抽象を実装しているクラスとクライアントの間に多くの依存関係がある場合。あるサブシステムをクライアントや他のサブシステムから切り離して、独立性や移植性を高めるために facade を導入する。<br><br><li>サブシステムを階層化したい場合。各階層の各サブシステムへの入り口を定義するために facade を使う。複数のサブシステムが依存し合っている場合、それらのサブシステムが互いに facade を通してのみやりとりを行うようにすれば、それらの依存関係を単純にすることができる。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/facade.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Facade クラス</b> （Compiler クラス）<ul><li>サブシステム内のどのクラスがクライアントからの要求に対して責任を負っているのかを知っている。<li>クライアントからの要求をサブシステム内の適当なオブジェクトに委譲する。</ul><br><br><li><b>サブシステム内のクラス</b> （Scanner クラス、Parser クラス、ProgramNode クラスなど）<ul><li>サブシステムの機能を実装している。<li>Facade オブジェクトにより割り当てられた仕事を処理する。<li>Facade オブジェクトについては何も知らない。つまり、サブシステム内のクラスは Facade オブジェクトへの参照を保持しない。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>クライアントは Facade オブジェクトに要求を送信してサブシステムとやりとりする。Facade オブジェクトはその要求をサブシステム内の適当なオブジェクトに転送する。実際の仕事はサブシステム内のオブジェクトが実行するが、Facade オブジェクト自身もそのインタフェースをサブシステム内のオブジェクトのインタフェースに変換しなければならないことがある。<br><br><li>Facade オブジェクトを使うクライアントは、サブシステム内のオブジェクトに直接アクセスする必要はない。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Facade パターンを使うと次のような利点が得られる。<br><br><ol><li><b>Facade パターンはクライアントからサブシステムの構成要素を隠す。</b>そのため、クライアントが扱うオブジェクトの数は少なくなり、そのサブシステムの利用が容易になる。<br><br><li><b>Facade パターンはサブシステムとそのクライアントの間の結合を弱める。</b>サブシステム内の構成要素はしばしば強く結合している。サブシステムとそのクライアント間の結合が弱ければ、クライアントに影響を与えずにサブシステム内の構成要素を変更することができる。また、facade はシステムの階層化とオブジェクト間の依存関係の階層化にも役立つ。facade により、複雑な依存関係や循環する依存関係を排除することができる。このことは、サブシステムとそのクライアントが独立に実装されるときには、重要な意義を持つ。<br><font style="text-indent:10pt">　大規模なソフトウェアシステムにおいては、コンパイルの依存関係を減らすことはきわめて重要である。サブシステム内のクラスを変更したときの再コンパイルを最小限に抑えて、時間を節約したいものである。facade を用いてコンパイル依存関係を小さくすれば、重要なサブシステム内での小さな変更により必要となる再コンパイルを制限することができる。また、facade は他のプラットフォームへのシステムの移植を容易にする。なぜならば、1つのサブシステムのビルドにより他のすべてのサブシステムのビルドが必要になる、ということが起こりにくくなるからである。<br><br><li><b>アプリケーションがサブシステム内のクラスを直接利用する必要があれば、facade はそれを妨げはしない。</b>したがって、facade を導入するとサブシステムを簡単に利用できるようになり、しかもサブシステムの汎用性も失われない。</ol></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　facade を実装するときには以下の問題を考慮する。<br><br><ol><li><b>クライアントとサブシステムの間の結合を減らす。</b>Facade を抽象クラスとし、サブシステムの異なる実装ごとに具象サブクラスを用意すれば、クライアントとサブシステムの間の結合をさらに減らすことができる。このようにすると、クライアントは抽象クラス Facade のインタフェースを通してサブシステムとやりとりすることができる。このように抽象クラスを用いて結合すれば、サブシステムのどの実装が使われているのかをクライアントは知らなくて済む。<br><font style="text-indent:10pt">　上述のサブクラス化とは別の方法に、サブシステム内の異なるオブジェクトを使って facade を構築する方法がある。この方法において facade をカスタマイズするには、サブシステム内のオブジェクトのいくつかを単に置き換えるだけでよい。<br><br><li><b>サブシステム内のクラスの公開、非公開。</b>サブシステムとクラスは、両者ともインタフェースを持ち、何かをカプセル化している（クラスは状態とオペレーションをカプセル化しており、サブシステムはクラスをカプセル化している）という点で類似している。そこで、クラスのインタフェースに関して公開と非公開を考えるのが有用であるのと同様に、サブシステムのインタフェースに関しても公開と非公開を考えることができる。<br><font style="text-indent:10pt">　サブシステムの公開インタフェースは、すべてのクライアントがアクセスできるクラスからなる。一方、非公開インタフェースへはサブシステム内のクラスしかアクセスできない。Facade クラスはもちろん公開インタフェースの一部であるが、公開インタフェースは Facade クラスだけとは限らない。サブシステム内の他のクラスも通常は公開される。たとえば、コンパイラサブシステムの Parser クラスや Scanner クラスは公開インタフェースの一部である。<br><font style="text-indent:10pt">　サブシステム内のあるクラスを非公開にすることは有用であろうが、そのような機構をサポートしているオブジェクト指向言語はほとんどない。C++と Smalltalk は、従来からクラスに対してグローバルなネームスペースを採用してきた。しかし最近C++標準化委員会は、この言語に、サブシステム内の公開クラスだけをサブシステム外部に見せることを可能にする新たなネームスペースを追加した［Str94］。</ol></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　コンパイラサブシステムに facade を導入する方法をもう少し詳しく見てみよう。<br><font style="text-indent:10pt">　このコンパイラサブシステムは、Bytecode オブジェクトのストリームを実装する BytecodeStream クラスを定義している。Bytecode オブジェクトはマシン命令を特定できるバイトコードをカプセル化している。また、このサブシステムは、プログラミング言語のトークンをカプセル化するオブジェクトのために、Token クラスも定義している。<br><font style="text-indent:10pt">　Scanner クラスは文字のストリームを受け取り、一度に1トークンずつ生成しながら、トークンのストリームを形成していく。<br><br><pre>    class Scanner {    public:        Scanner(istream&amp;);        virtual ~Scanner();            virtual Token&amp; Scan();    private:        istream&amp; _inputStream;    };</pre><br><br><font style="text-indent:10pt">　Parser クラスは、Scanner クラスのトークンから構文解析木を構築するために、ProgramNodeBuilder クラスを使う。<br><br><pre>    class Parser {    public:        Parser();        virtual ~Parser();            virtual void Parse(Scanner&amp;, ProgramNodeBuilder&amp;);    };</pre><br><br><font style="text-indent:10pt">　Parser クラスは、構文解析木を段階的に構築するために ProgramNodeBuilder クラスを呼び出す。これらのクラスは <a href="02.html" target="down">Builder パターン</a>に従ってやりとりする。<br><br><pre>    class ProgramNodeBuilder {    public:        ProgramNodeBuilder();            virtual ProgramNode* NewVariable(            const char* variableName        ) const;            virtual ProgramNode* NewAssignment(            ProgramNode* variable, ProgramNode* expression        ) const;            virtual ProgramNode* NewReturnStatement(            ProgramNode* value        ) const;            virtual ProgramNode* NewCondition(            ProgramNode* condition,            ProgramNode* truePart, ProgramNode* falsePart        ) const;        // ...            ProgramNode* GetRootNode();    private:        ProgramNode* _node;    };</pre><br><br><font style="text-indent:10pt">　構文解析木は、ProgramNode のサブクラス（StatementNode クラスやExpressionNode クラスなど）のインスタンスから作られる。ProgramNode クラスの階層構造は <a href="08.html" target="down">Composite パターン</a>の例である。ProgramNode クラスは、プログラムノードと（もし存在すれば）その子ノードを操作するインタフェースを定義する。<br><br><pre>    class ProgramNode {    public:        // program node manipulation        virtual void GetSourcePosition(int&amp; line, int&amp; index);        // ...            // child manipulation        virtual void Add(ProgramNode*);        virtual void Remove(ProgramNode*);        // ...            virtual void Traverse(CodeGenerator&amp;);    protected:        ProgramNode();    };</pre><br><br><font style="text-indent:10pt">　Traverse オペレーションは CodeGenerator オブジェクトを引数として受け取る。ProgramNode のサブクラスはこのオブジェクトを利用して、マシンコードを BytecodeStream オブジェクト上の Bytecode オブジェクトの形式で生成する。この CodeGenerator オブジェクトは visitor（<a href="23.html" target="down">Visitor パターン</a>を参照）である。<br><br><pre>    class CodeGenerator {    public:        virtual void Visit(StatementNode*);        virtual void Visit(ExpressionNode*);        // ...    protected:        CodeGenerator(BytecodeStream&amp;);    protected:        BytecodeStream&amp; _output;    };</pre><br><br><font style="text-indent:10pt">　CodeGenerator クラスは StackMachineCodeGenerator クラスや RISCCodeGenerator クラスなどのサブクラスを持つ。これらのサブクラスは異なるハードウェアアーキテクチャのためのマシンコードを生成する。<br><font style="text-indent:10pt">　ProgramNode の各サブクラスの Traverse オペレーションは、自分の子にあたる ProgramNode オブジェクトの Traverse オペレーションを呼び出すように実装される。各子オブジェクトはさらに、自分の子にあたるオブジェクトに対して同様のことを行い、それが再帰的に繰り返される。たとえば、ExpressionNode クラスは Traverse オペレーションを次のように実装する。<br><br><pre>    void ExpressionNode::Traverse (CodeGenerator&amp; cg) {        cg.Visit(this);            ListIterator<ProgramNode*> i(_children);            for (i.First(); !i.IsDone(); i.Next()) {            i.CurrentItem()->Traverse(cg);        }    }</pre><br><br><font style="text-indent:10pt">　ここまで議論してきたクラスがコンパイラサブシステムを構成する。そこで、これらの部品をすべてまとめる facade として、Compiler クラスを導入する。この Compiler クラスはソースをコンパイルし、ある特定のマシン用のコードを生成するためのわかりやすいインタフェースを提供する。<br><br><pre>    class Compiler {    public:        Compiler();            virtual void Compile(istream&amp;, BytecodeStream&amp;);    };        void Compiler::Compile (        istream&amp; input, BytecodeStream&amp; output    ) {        Scanner scanner(input);        ProgramNodeBuilder builder;        Parser parser;            parser.Parse(scanner, builder);            RISCCodeGenerator generator(output);        ProgramNode* parseTree = builder.GetRootNode();        parseTree->Traverse(generator);    }</pre><br><br><font style="text-indent:10pt">　プログラマがターゲットのアーキテクチャを設定しないで済むように、この実装では利用する CodeGenerator オブジェクトのタイプが固定されている。ターゲットのアーキテクチャが1つしか存在しなければ、この実装は合理的であろう。そうでない場合には、CodeGenerator オブジェクトをパラメータとするように Compiler クラスのコンストラクタを変更したくなるかもしれない。そうすれば、プログラマは Compiler クラスをインスタンス化するときに、どの CodeGenerator オブジェクトを利用するかを指定することができる。同様に、コンパイラの facade は Scanner クラスや ProgramNodeBuilder クラスなど、コンパイルに利用している他のクラスもパラメータ化することができる。ただし、そのようにすると、Compiler クラスの柔軟性は増すが、通常の利用時のインタフェースを単純にするという Facade パターンの目的は損なわれる。</font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　「サンプルコード」の節のコンパイラの例は、ObjectWorks /Smalltalk のコンパイラシステム［Par90］に従ったものである。<br><font style="text-indent:10pt">　ET++アプリケーションフレームワーク［WGM88］では、アプリケーションに組み込みブラウザツールを持たせることができる。このブラウザツールにより、実行時のオブジェクトの状態を外部から見ることができるようになる。<br><font style="text-indent:10pt">　このブラウザツールは独立したサブシステムとして実装されており、ProgrammingEnvironment と呼ばれる Facade クラスを持つ。この Facade クラスは、InspectObject オペレーションや InspectClass オペレーションなど、ブラウザにアクセスするためのオペレーションを定義している。<br><font style="text-indent:10pt">　ET++のアプリケーションはこの組み込みブラウザのサポートを利用しなくてもよい。利用しない場合には、ProgrammingEnvironment クラスはブラウザへのアクセス要求をヌルオペレーション（何もしないオペレーション）として実装する。ETProgrammingEnvironment クラスというサブクラスだけが、要求に対応したブラウザを表示するオペレーションを用いてそれらの要求を実装している。アプリケーションはブラウザ環境が利用可能かどうかを知らなくてもよい。なぜならば、アプリケーションとブラウザサブシステムの間は抽象的に結合されているからである。<br><font style="text-indent:10pt">　Choices オペレーティングシステム［CIRM93］は、多くのフレームワークを1つに組み合わせるために facade を利用している。Choices でキーとなる抽象化はプロセス、記憶装置、およびアドレス空間である。Choices はこれらの抽象化に対応するサブシステムを持ち、それぞれがフレームワークとして実装されている。これにより、さまざまな異なるハードウェアプラットフォームへの Choices の移植がサポートされる。これらのサブシステムのうち2つは“代表”（つまり facade ）を持つ。すなわち、記憶装置の代表は FileSystemInterface クラス、アドレス空間の代表は Domain クラスである。<br><br><br><p align="center"><img src="img/pics/facad059.gif"></p><br><br><br>たとえば、仮想メモリフレームワークは facade として Domain クラスを持つ。Domain オブジェクトはアドレス空間を表現しており、仮想アドレスと、メモリオブジェクトやファイルやバッキングストアへのオフセットの間のマッピングを提供する。Domain クラスの主なオペレーションでは、あるアドレスにメモリオブジェクトを追加したり、メモリオブジェクトを削除したり、ページフォールトを処理したりする。<br><br>前のダイアグラムに示すように、仮想メモリサブシステムは内部で次のクラスを利用している。<br><br><ul><li>MemoryObject クラスはデータストアを表現する。<br><br><li>MemoryObjectCache クラスは MemoryObject オブジェクトのデータを実メモリ内にキャッシュする。この MemoryObjectCache クラスはキャッシュの戦略を1か所にまとめる Strategy クラス（<a href="21.html" target="down">Strategy パターン</a>）である。<br><br><li>AddressTranslation クラスはアドレス変換ハードウェアをカプセル化している。</ul><br><br><font style="text-indent:10pt">　RepairFault オペレーションはページフォールト割り込みが発生したときに呼ばれる。Domain オブジェクトは、フォールトを引き起こしたアドレスの MemoryObject オブジェクトを見つけ、そのオブジェクトと関連している MemoryObjectCache オブジェクトに RepairFault オペレーションを委譲する。Domain オブジェクトはその構成要素を換えることによりカスタマイズできる。</font></font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="01.html" target="down">Abstract Factory パターン</a>: サブシステムとは独立した方法でサブシステム内のオブジェクトを生成するインタフェースを提供するために、Facade パターンと一緒に利用することができる。また、プラットフォームに特化したクラスを隠ぺいするという点で、Facade パターンに対する代替案として利用することもできる。<br><font style="text-indent:10pt">　<a href="17.html" target="down">Mediator パターン</a>: 既存のクラスの機能を抽出しているという点で Facade パターンと似ている。しかし、<a href="17.html" target="down">Mediator パターン</a>の目的は Colleague オブジェクト間のやりとりを抽出することであり、それらの機能を1か所に集中させて、Colleague オブジェクトには機能を持たせないようにする。Colleague オブジェクトは mediator の存在を知っており、Colleague オブジェクト同士で直接やりとりをする代わりに mediator とやりとりをする。一方 facade は、サブシステム内のオブジェクトの利用を容易にするために、そのインタフェースを抽出するだけである。facade は新たな機能を定義しないし、サブシステム内のクラスは facade の存在を知らない。<br><font style="text-indent:10pt">　<a href="05.html" target="down">Singleton パターン</a>: 通常、facade には唯一性が要求される。したがって、facade にはしばしば <a href="05.html" target="down">Singleton パターン</a>が適用される。</font></font></font><br><br><br></body></html>