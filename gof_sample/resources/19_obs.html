<html><head><title>OBSERVER</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/obs.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　あるオブジェクトが状態を変えたときに、それに依存するすべてのオブジェクトに自動的にそのことが知らされ、また、それらが更新されるように、オブジェクト間に一対多の依存関係を定義する。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Dependents、Publish-Subscribe</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　1つのシステムを、協調動作するクラスの集まりに分割する際の一般的な副作用は、関連するオブジェクト間で無矛盾性を保つ必要があるということである。しかし、無矛盾にするためにクラス間の結合性を高めるようなことはしたくない。なぜならば、それはクラスの再利用性を低めるからである。<br><font style="text-indent:10pt">　たとえば、多くのグラフィックユーザインタフェースツールキットは、ユーザインタフェースの表示に関する部分を、基にあるアプリケーションデータから分離している［KP88、LVC89、P+88、WGM88］。アプリケーションデータを定義しているクラスと表示を定義しているクラスは、それぞれ独立に再利用することができる。また、それらを一緒に働かせることもできる。スプレッドシートオブジェクトとバーチャートオブジェクトは、異なる表示形式で同じアプリケーションデータの情報を表現することができる。スプレッドシートとバーチャートは互いに関与し合っているわけではないので、必要な方だけを再利用すればよい。しかし、それらはあたかも関与し合っているかのように振る舞う。ユーザがスプレッドシートの情報を変えたときに、バーチャートでもその変化が即座に反映される。また、逆も同様である。 <br><br><br><p align="center"><img src="img/pics/obser023.gif"></p><br><br><br><font style="text-indent:10pt">　この振る舞いは、スプレッドシートとバーチャートがデータオブジェクトに依存しており、したがって、データオブジェクトの状態が変わったときにはそのことがスプレッドシートとバーチャートに知らされることを意味している。このとき、データオブジェクトに依存しているオブジェクトの数を2つに限定する理由はない。つまり、同じデータに対して異なるユーザインタフェースがいくつあってもかまわない。<br><font style="text-indent:10pt">　Observer パターンではこれらの関係を確立する方法を述べる。このパターンのキーとなるオブジェクトは、subject と observer である。subject には、それに依存する observer を任意の数だけ持たせることができる。subject の状態を変化させたときには常に、すべての observer にそのことが知らされるようになっている。それに反応して各 observer は、自身の状態をsubjectの状態に対応させるために subject に対して問い合わせを行う。<br><font style="text-indent:10pt">　この種のインタラクションは publish-subscribe としても知られている。subject は通知を発行（publish）する。この通知を送る際には、observer がどのようなオブジェクトなのかを知っている必要はない。任意の数の observer を、通知を受け取れるように登録（subscribe）しておくことができる。</font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のような状況で Observer パターンを使う。<br><br><ul><li>抽象化により、2つの面が、一方が他方に依存しているという形で現れる場合。これらの面をそれぞれ別々のオブジェクトにカプセル化することにより、それらを独立に変更したり、再利用することが可能になる。<br><br><li>1つのオブジェクトを変化させるときに、それに伴いその他のオブジェクトも変化させる必要があり、しかも変化させる必要があるオブジェクトを固定的に決められない場合。<br><br><li>オブジェクトが、他のオブジェクトに対して、それがどのようなものなのかを仮定せずに通知できるようにする場合。別の言い方をすると、これらのオブジェクトを密に結合したくない場合。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/observer.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Subjectクラス</b><ul><li>observer を知っている。任意の数の observer が subject の変化に対応している。<li>observer を加えたりはずしたりするためのインタフェースを提供する。</ul><br><br><li><b>Observer クラス</b><ul><li>subject 内の変化が通知されたときのために、更新のインタフェースを定義する。</ul><br><br><li><b>ConcreteSubject クラス</b><ul><li>ConcreteObserver オブジェクトに影響する状態を保存している。<li>状態が変わったときに ConcreteObserver オブジェクトに通知を送る。</ul><br><br><li><b>ConcreteObserver クラス</b><ul><li>ConcreteSubject オブジェクトへの参照を保持している。<li>その状態を ConcreteSubject オブジェクトの状態と矛盾しないようにして保存している。<li>その状態を ConcreteSubject オブジェクトの状態と矛盾しないようにしておくために、Observer クラスで宣言した更新のインタフェースを実装する。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>ConcreteSubject オブジェクトは、ConcreteObserver オブジェクトの状態と矛盾するような変化が自身の状態に起こったときには、そのことを ConcreteObserver オブジェクトに知らせる。<br><br><li>ConcreteSubject オブジェクト内での変化を知らされた後、ConcreteObserver オブジェクトは ConcreteSubject オブジェクトに対して情報の問い合わせを行う。ConcreteObserver オブジェクトは、自身の状態を ConcreteSubject オブジェクトの状態と一致させるためにこの情報を使う。</ul><br><br><font style="text-indent:10pt">　次のインタラクションダイアグラムは、ConcreteSubject クラスのインスタンス aConcreteSubject と、ConcreteObserver クラスのインスタンス aConcreteObserver、anotherConcreteObserver の間の協調を表している。<br><br><br><p align="center"><img src="img/pics/obser022.gif"></p><br><br><br>aConcreteSubject の状態を変化させるように要求を出した aConcreteObserver が、aConcreteSubject から通知を得るまでは自身の状態の更新を延ばしている点に注意してほしい。Notify オペレーションは、常に subject により呼び出されるとは限らない。observer やその他のオブジェクトにより呼び出されることもある。「実装」の節で、一般的なバリエーションをいくつか論じる。</font></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Observer パターンを使うことで、subject と observer を独立に変更することができるようになる。observer を再利用せずに subject を再利用することができるし、また、逆も可能である。observer を、subject やその他の observer を修正せずに新たに追加することも可能になる。<br><font style="text-indent:10pt">　Observer パターンには、さらに次のような利点と欠点がある。<br><br><ol><li><b>Subject クラスとObserver クラスの間の抽象的結合。</b>subject は、observer のリストを持ち、それぞれが抽象クラス Observer の簡単なインタフェースに従っている、ということだけを知っている。subject は、各 observer がどの具象クラスのインスタンスなのかは知らない。したがって、subject と observer の結合は抽象的であり極小である。<br><font style="text-indent:10pt">　Subject クラスと Observer クラスは密接には結合していないので、それらはシステム内で異なる抽象度の階層に属していてもよい。抽象度の低い subject が抽象度の高い observer と通信して、変化が起こったことを知らせ、それによりシステムの階層を保つことができる。もし、Subject クラスと Observer クラスがひとかたまりにされていれば、そのオブジェクトは2つの階層にかからなければならない（そして、階層を壊す）か、または、どちらか一方の階層に無理にでも収めるようにしなければならない（それは、抽象化の階層に妥協を与えることになるかもしれない）。<br><br><li><b>ブロードキャスト通信のサポート。</b>通常の要求とは異なり、subject が送る通知ではその受け手について明確にしておく必要はない。通知は、登録されているすべてのオブジェクトに自動的にブロードキャストされる。subject にとって、関係するオブジェクトがいくつ存在するのかは問題ではなく、observer への通知を責任を持って行いさえすればよい。このことは、いつでも自由に observer を加えたり外したりすることを可能にする。通知に応ずるのか無視するのかは、observer に任されている。<br><br><li><b>不慮の更新。</b>observer 同士は互いに相手の存在を知らないため、subject の変化に伴うコストの総計を observer が予測することはできない。subject 上の特に問題がないように見えるオペレーションが、observer とそれに依存するオブジェクトに対して更新を次々に引き起こしていくことになるかもしれない。さらに、依存関係の規準がしっかりと定義されていないか、または保守されていなければ、見せかけだけの更新が起こりかねないが、これを調べて見つけ出すのは難しい。</ol><br><font style="text-indent:10pt">　簡単な更新プロトコルでは、subject の中で何が変わったのかについて詳しい情報を提供していないため、この問題はさらに悪化する。何が変わったのかについて observer がわかるようにするためのプロトコルを新たに追加しなければ、この変化を演繹するために observer はかなりの処理を強いられることになるだろう。</ul></font></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　この節では、依存メカニズムの実装に関係したいくつかの問題を論じる。<br><br><ol><li><b>subject を observer にマッピングする。</b>subject が、通知すべき observer を管理するためのもっとも簡単な方法は、それらへの参照を subject 内に明示的に保存しておくことである。しかしながら、そのように保存しておくことは、subject が多くて observer が少ないときにはコストが高くつくことになるだろう。1つの解決策として、subject から observer へのマッピングを保持する共同の検索テーブル（たとえば、ハッシュテーブル）を使うことにより、スペースのコストと時間のコストをトレードすることが考えられる。この方法だと、observer が存在しない subject が保存のためのオーバーヘッドを被ることはなくなる。一方このアプローチでは、observer にアクセスする際のコストが増えることになる。<br><br><li><b>observer を複数の subject に登録する。</b>ある状況では、1つの observer が複数の subject に依存していることが考えられるだろう。たとえば、スプレッドシートは複数のデータソースに依存しているかもしれない。そのような場合、どの subject が通知を送ったのかを observer に知らせるように、Update オペレーションインタフェースを拡張する必要がある。subject は自身を Update オペレーションの中で引数として与え、それにより observer はどの subject を調べればよいのかがわかることになる。<br><br><li><b>どのオブジェクトが更新のきっかけを作るのか。</b>subject と observerは、両者の間で矛盾が起こらないようにするために通知メカニズムを使っている。しかし、更新のきっかけを作るために、実際にどのオブジェクトが Notify オペレーションを呼び出すことになるのか。この問いに対する答えとして、次の2つの選択肢がある。<br><br><ol type="a"><li>Subject クラスで定義された状態を設定するオペレーションが、状態を変化させた後に、Notify オペレーションを呼び出す。このアプローチの有利な点は、クライアントが subject に対して Notify オペレーションを呼び出すことを覚えておく必要がないという点である。不利な点は、複数のオペレーションを連続して実行すると、それぞれに対して更新も連続して起こることになり非効率的であるという点である。<br><br><li>クライアントが適当なタイミングで Notify オペレーションを呼び出すことにする。このアプローチの有利な点は、クライアントが状態の一連の変化が終わるまで更新を待つことで、不必要な中間段階の更新を省けるという点である。不利な点は、クライアントに更新のきっかけを作る責任をさらに持たせなければならない点である。クライアントは Notify オペレーションを呼び出すことを忘れるかもしれないので、その分エラーが起こりやすくなる。</ol><br><br><li><b>削除された subject へのダングリング参照。</b>subject を削除したときに、observer 内にダングリング参照が作られるべきではない。ダングリング参照を防ぐ1つの方法は、subject が削除される際に、observer に対して、subject への参照をリセットするように通知を出すようにすることである。一般に、observer を単に削除するという方法は選択肢にはならない。なぜならば、他のオブジェクトがそれを参照しているかもしれないし、その observer は他の subject にも同様に登録されているかもしれないからである。<br><br><li><b>通知の前に subject の状態をそれ自体で矛盾がないようにしておく。</b>Notify オペレーションを呼び出す前に、subject の状態をそれ自体で矛盾がないようにしておくことは重要である。なぜならば、observer が状態を更新する際に subject に対して状態の問い合わせを行うからである。<br><font style="text-indent:10pt">　この無矛盾性の規則は、Subject のサブクラスのオペレーションが、継承したオペレーションを呼び出すときに、意図しない形で簡単に破られることがある。たとえば、次のようなコード列では、subject の状態にまだ矛盾があるうちに通知が出されることになる。<br><br><pre>    void MySubject::Operation (int newValue) {        BaseClassSubject::Operation(newValue);            // trigger notification            _myInstVar += newValue;            // update subclass state (too late!)    }</pre><br><br><font style="text-indent:10pt">　抽象クラス Subject の template method（<a href="22.html" target="down">Template Method パターン</a>）から通知を送ることで、この落とし穴を防ぐことができる。primitive operation をサブクラスでオーバーライドするように定義しておき、template method 内の最後で Notify オペレーションを呼び出すようにしておけば、サブクラスが Subject クラスのオペレーションをオーバーライドするときにもオブジェクト内で矛盾が起こらないようにすることができる。<br><br><pre>    void Text::Cut (TextRange r) {         ReplaceRange(r);       // redefined in subclasses         Notify();    }</pre><br><br><font style="text-indent:10pt">　ところで、Subject クラスのどのオペレーションが通知のきっかけを作るのかは、文書化しておくのがよい。<br><br><li><b>observer ごとに更新プロトコルが異なるようなことは避ける（push モデルと pull モデル）。</b>Observer パターンの実装では、しばしば subject に、変化についての付加的な情報をブロードキャストさせるようにする。subject はこの情報を Update オペレーションの引数として渡す。やりとりの方法により、情報量にはかなりの差が生じるだろう。<br><font style="text-indent:10pt">　1つの極端な場合として、push モデルと呼ばれているものがある。このモデルでは、observer が望むかどうかにかかわらず、subject は変化についての詳細な情報を observer に送る。もう1つの極端な場合は、pull モデルと呼ばれている。すなわち、subject は observer に対して最低限の通知以外は何も送らず、詳細な情報については observer が後に明示的に問い合わせるようにする。<br><font style="text-indent:10pt">　pull モデルでは、subject が observer のことをまったく知らないということが強調されている。一方 push モデルでは、subject が observer の再利用性を低めることになるかもしれない。なぜならば、Subject クラスは Observer クラスについて仮定を置くことになり、それがどのような場合にもあてはまるとは限らないからである。一方、pull モデルは非効率的になるかもしれない。なぜならば、Observer クラスは、何が変化したのかを Subject クラスからの協力を得ずに確かめなければならないからである。<br><br><li><b>部分的な変化について明示的に仕様化する。</b>observer を特定のイベントに対して登録できるように subject のインタフェースを拡張することで、更新の効率を改善することができる。そのようなイベントが発生したとき、subject はそのイベントに対して登録されている observer にのみ通知を行う。Digitalk Smalltalk では、この方式を Model（つまり、Subject）オブジェクトに対する aspect という考え方でサポートしている。特定のイベントに対する登録を行うために、View オブジェクト（つまり、observer）は次のようなメッセージを Model オブジェクトに送る。<br><br><pre>    add: self interestIn: anAspect</pre><br><br><font style="text-indent:10pt">　そこでは、anAspect が特定のイベントを指定している。通知の際には、subject は、Update オペレーションのパラメータとして、変化した aspect を observer に提供する。たとえば、次のようになる。<br><br><pre>    observer update: theChangedAspect</pre><br><br><li><b>複雑な更新のセマンティクスをカプセル化する。</b>subject と observer の依存関係が特に複雑なときには、この関係を保持するオブジェクトが必要になるだろう。このようなオブジェクトを ChangeManager オブジェクトと呼ぶ。その目的は、subject 内の変化を observer に反映させるのに必要な作業量を最小化することである。たとえば、もしオペレーションが相互に依存し合う複数の subject に変化を及ぼすときには、observer に対する通知が何度も繰り返されないように、observer には、すべての subject が修正された後に一度だけ通知を送るようにしなければならないだろう。<br><font style="text-indent:10pt">　ChangeManager クラスには次の3つの責任がある。<br><br><ol type="a"><li>subject を observer にマッピングし、さらにこのマッピングを維持していくためのインタフェースを提供する。これにより、subject が observe への参照を保持する必要はなくなるし、また逆についても同様のことが言える。<br><br><li>更新のために特定の戦略を定義する。<br><br><li>subject からの要求により、依存するすべての observer を更新する。</ol><br><br><font style="text-indent:10pt">　次のダイアグラムは、簡単な ChangeManager クラスに基づく Observer パターンの実装を表している。ChangeManager クラスには2つの特化されたクラスが存在する。SimpleChangeManager クラスは、常に各subjectのすべての observer を更新するという点で単純である。それとは対照的に DAGChangeManager クラスでは、subject と observer の間の依存関係を表す有向循環グラフを扱う。observer が複数の subject に登録されているときには、DAGChangeManager クラスの方が SimpleChangeManager クラスよりも望ましい。なぜならば、そのような場合、2つ以上の subject で変化が起こると、冗長な更新を引き起こすことになりかねないが、DAGChangeManager クラスを使うことで、observer が更新を受信するのは1回だけになることが保証されるからである。SimpleChangeManager クラスは、更新が複数回起こることが問題にならないときに使うのがよい。<br><br><br><p align="center"><img src="img/pics/obser025.gif"></p><br><br><br><font style="text-indent:10pt">　ChangeManager クラスは <a href="17.html" target="down">Mediator パターン</a>の適用例である。一般に、ChangeManager クラスのインスタンスは1つしか存在せず、これはグローバルに宣言される。この点については <a href="05.html" target="down">Singleton パターン</a>が役に立つだろう。<br><br><li><b>Subject クラスと Observer クラスを一緒にまとめる。</b>多重継承の機能がない言語（たとえば、Smalltalk）で書かれたクラスライブラリでは、一般に Subject クラスと Observer クラスを別々に定義することはせずに、それらのインタフェースを1つのクラスに一緒にまとめてしまう。これにより、多重継承を使わなくても、subject と observer の両方として活動するオブジェクトを定義することができるようになる。たとえば Smalltalk では、Subject クラスと Observer クラスのインタフェースは継承階層のルートにあたるクラス Object で定義されており、これにより、すべてのクラスでこのインタフェースを入手できるようになっている。</ol></ol></font></font></font></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　抽象クラス Observer のインタフェースを次のように定義する。<br><br><pre>    class Subject;        class Observer {    public:        virtual ~ Observer();        virtual void Update(Subject* theChangedSubject) = 0;    protected:        Observer();    };</pre><br><br><font style="text-indent:10pt">　この実装では、各 observer に対して複数の subject をサポートする。observer が複数の subject に登録されているときには、Update オペレーションに渡される subject により、observer はどの subject が変化したのかを特定できるようになる。<br><font style="text-indent:10pt">　同様に、抽象クラス Subject のインタフェースを次のように定義する。<br><br><pre>    class Subject {    public:        virtual ~Subject();            virtual void Attach(Observer*);        virtual void Detach(Observer*);        virtual void Notify();    protected:        Subject();    private:        List&lt;Observer*> *_observers;    };        void Subject::Attach (Observer* o) {        _observers->Append(o);    }        void Subject::Detach (Observer* o) {        _observers->Remove(o);    }        void Subject::Notify () {        ListIterator&lt;Observer*> i(_observers);            for (i.First(); !i.IsDone(); i.Next()) {            i.CurrentItem()->Update(this);        }    }</pre><br><br><font style="text-indent:10pt">　ClockTimer クラスは、時刻を保存、維持していくための ConcreteSubject クラスである。それは、observer に毎秒通知を送る。ClockTimer クラスは、時間、分、秒のような個々の時間単位の値を取り出すためのインタフェースを提供している。<br><br><pre>    class ClockTimer : public Subject {    public:        ClockTimer();            virtual int GetHour();        virtual int GetMinute();        virtual int GetSecond();            void Tick();    };</pre><br><br><font style="text-indent:10pt">　Tick オペレーションは、ClockTimer クラスが正確な時間を表すベースになるように、規則的な間隔でシステム内部のタイマーにより呼び出される。Tick オペレーションは ClockTimer オブジェクトの内部状態を更新し、Notify オペレーションを呼び出すことで observer にその変化を知らせる。<br><br><pre>    void ClockTimer::Tick () {        // update internal time-keeping state        // ...        Notify();    }</pre><br><br><font style="text-indent:10pt">　ここで、時間を表示する DigitalClock クラスを定義することができる。このクラスは、ユーザインタフェースツールキットで提供されている Widget クラスからグラフィックの機能を継承している。さらに、Observer クラスを継承することによりそのインタフェースを取り込んでいる。<br><br><pre>    class DigitalClock: public Widget, public Observer {    public:        DigitalClock(ClockTimer*);        virtual ~DigitalClock();            virtual void Update(Subject*);            // overrides Observer operation            virtual void Draw();            // overrides Widget operation;            // defines how to draw the digital clock    private:        ClockTimer* _subject;    };        DigitalClock::DigitalClock (ClockTimer* s) {        _subject = s;        _subject->Attach(this);    }        DigitalClock::&nbsp;DigitalClock () {        _subject->Detach(this);    }</pre><br><br><font style="text-indent:10pt">　Update オペレーションは、時計の面を表示する前に、通知が DigitalClock オブジェクト内部に登録されている subject からのものであることを確認する。<br><br><pre>    void DigitalClock::Update (Subject* theChangedSubject) {        if (theChangedSubject == _subject) {            Draw();        }    }        void DigitalClock::Draw () {        // get the new values from the subject            int hour = _subject->GetHour();        int minute = _subject->GetMinute();        // etc.            // draw the digital clock    }</pre><br><br><font style="text-indent:10pt">　AnalogClock クラスも同様に定義することができる。<br><br><pre>    class AnalogClock : public Widget, public Observer {    public:        AnalogClock(ClockTimer*);        virtual void Update(Subject*);        virtual void Draw();        // ...    };</pre><br><br><font style="text-indent:10pt">　次のようにコーディングすることで、常に同じ時刻を表示する AnalogClock オブジェクトと DigitalClock オブジェクトを生成することができる。<br><br><pre>    ClockTimer* timer = new ClockTimer;    AnalogClock* analogClock = new AnalogClock(timer);    DigitalClock* digitalClock = new DigitalClock(timer);</pre><br><br><font style="text-indent:10pt">　timer が時を刻むたびに、2つの時計は更新され、適切な方法で再表示される。</font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Observer パターンとして、最初の、そしておそらくもっともよく知られた例は、Smalltalk 環境［KP88］のユーザインタフェースフレームワークである Model/View/Controller（MVC）に現れる。MVC の Model クラスは Subject クラスの役割を持ち、一方、View クラスは observer のための基底クラスになる。Smalltalk、ET++［WGM88］、THINK クラスライブラリ［Sym93b］では、システム中のすべてのクラスの親となるクラスに、Subject クラスと Observer クラスのインタフェースを加えることにより、依存メカニズムを一般化して提供している。<br><font style="text-indent:10pt">　このパターンを採用している他のユーザインタフェースツールキットには、InterViews［LVC89］、Andrew ツールキット［P+88］、Unidraw［VL90］がある。InterViews では、Observer と Observable（subjectにあたる）の2つのクラスを明示的に定義している。Andrew では、それぞれを、view、data object と呼んでいる。Unidraw では、図形エディタのオブジェクトを、View（observer にあたる）の部分と Subject の部分に分割している。</font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="17.html" target="down">Mediator パターン</a>: 複雑な更新のセマンティクスをカプセル化することにより、ChangeManagerオブジェクトは、subject と observer の間で mediator として働く。<br><font style="text-indent:10pt">　<a href="05.html" target="down">Singleton パターン</a>: ChangeManager オブジェクトは、自身を唯一の存在とし、グローバルにアクセスできるようにするために、<a href="05.html" target="down">Singleton パターン</a>を使う。</font></font><br><br><br></body></html>