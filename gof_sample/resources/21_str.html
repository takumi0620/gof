<html><head><title>STRATEGY</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/str.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　アルゴリズムの集合を定義し、各アルゴリズムをカプセル化して、それらを交換可能にする。Strategy パターンを利用することで、アルゴリズムを、それを利用するクライアントからは独立に変更することができるようになる。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Policy</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　テキストストリームを行に分解していくためのアルゴリズムは、多数存在している。そのような機能を必要とするクラスに、これらのアルゴリズムを埋め込んでしまうことは、次のようないくつかの理由により望ましくない。<br><br><ul><li>改行を必要とするクライアントがそのためのコードを持つとすると、そのクライアントはより複雑なものになってしまう。これにより、クライアントは大きくなり、保守が非常に難しくなる（特に、改行について複数のアルゴリズムをサポートする場合）。<br><br><li>アルゴリズムにはそれぞれに適した状況というものがある。しかし、もしアルゴリズムの使い分けをしないのであれば、複数のアルゴリズムをサポートしなくなるだろう。<br><br><li>改行がクライアントにとって重要な部分である場合、新しいアルゴリズムを追加したり、既存のアルゴリズムに変更を加えることは難しくなる。</ul><br><br><font style="text-indent:10pt">　改行アルゴリズムをカプセル化するクラスをアルゴリズムごとに定義することにより、これらの問題を回避することができる。このようにカプセル化されたアルゴリズムを strategy と呼ぶ。<br><br><br><p align="center"><img src="img/pics/strat011.gif"></p><br><br><br>テキストビューアに表示されるテキストの改行を維持、更新する責任を持つ Composition クラスを考える。改行に関する strategy は、Composition クラスにより実装されているのではない。その代わりに、抽象クラス Compositor のサブクラスにより別々に実装されているのである。つまり、Compositor のサブクラスは別々の strategy を実装している。<br><br><ul><li>SimpleCompositor クラスは、1行ごとにそこに入れるテキストを決めていく簡単な strategy を実装している。<br><br><li>TeXCompositor クラスは、改行を付けるところを見つけ出すために TEX アルゴリズムを実装している。この strategy は、全体の観点から改行を最適化しようとする。つまり、段落ごとに改行位置を決めていく。<br><br><li>ArrayCompositor クラスは、各行が固定の項目数を持つように区切りを入れていく strategy を実装している。たとえば、アイコンの集合を行に分解していく場合に有効である。</ul><br><br><font style="text-indent:10pt">　Composition オブジェクトは、Compositor のオブジェクトに対する参照を保持する。Composition オブジェクトが改めてテキストをフォーマットするときには、Compositor のオブジェクトに対してこの責任を委譲する。Composition クラスのクライアントは、必要な Compositor クラスを Composition クラスの中にインストールすることで、どのサブクラスが利用されるのかを特定する。</font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Strategy パターンは次のような場合に利用する。<br><br><ul><li>関連する多くのクラスが振る舞いのみ異なっている場合。Strategy パターンは、多くの振る舞いの中の1つでクラスを構成する方法を提供する。<br><br><li>複数の異なるアルゴリズムを必要とする場合。たとえば、空間と時間のトレードオフを反映する複数のアルゴリズムを定義する場合が考えられる。このとき、複数のアルゴリズムをクラス階層［HO87］として実装していく際に、Strategy パターンを利用することができる。<br><br><li>アルゴリズムが、クライアントが知るべきではないデータを利用している場合。Strategy パターンを利用することにより、複雑でアルゴリズムに特有なデータ構造を公開するのを避けることができる。<br><br><li>クラスが多くの振る舞いを定義しており、これらがオペレーション内で複数の条件文として現れている場合。このとき、多くの条件文を利用する代わりに、条件分岐後の処理を Strategy クラスに移し換える。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/strategy.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Strategy クラス</b> （Compositor クラス）<ul><li>サポートするすべてのアルゴリズムに共通のインタフェースを宣言する。Context クラスは、ConcreteStrategy クラスにより定義されるアルゴリズムを呼び出すためにこのインタフェースを利用する。</ul><br><br><li><b>ConcreteStrategy クラス</b> （SimpleCompositor クラス、TeXCompositor クラス、ArrayCompositor クラス）<ul><li>Strategy クラスのインタフェースを利用して、アルゴリズムを実装する。</ul><br><br><li><b>Context クラス</b> （Composition クラス）<ul><li>ConcreteStrategy オブジェクトを備えている。<li>Strategy のオブジェクトに対する参照を保持する。<li>Strategy クラスが Context クラスのデータにアクセスするためのインタフェースを定義してもよい。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>Strategy クラスと Context クラスは、選ばれたアルゴリズムを実装するために相互に作用し合う。アルゴリズムが呼び出されたときに、Context オブジェクトはアルゴリズムに必要なすべてのデータを Strategy のオブジェクトに対して送るかもしれない。また、別の方法として、Context オブジェクトは Strategy クラスのオペレーションの引数として自身を渡すこともできる。これにより Strategy のオブジェクトは、必要に応じて Context オブジェクトに呼び出しをかけることができるようになる。<br><br><li>Context オブジェクトは、クライアントからの要求を Strategy のオブジェクトに送る。クライアントは通常、ConcreteStrategy オブジェクトを生成し、これを Context オブジェクトに渡す。その後、クライアントは Context オブジェクトだけとやりとりする。しばしば、ConcreteStrategy クラスとしてさまざまなものが用意されており、クライアントはこの中から選択をすることになる。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Strategy パターンには、次に示す利点と欠点がある。<br><br><ol><li><b>関連するアルゴリズムの集合。</b>アルゴリズムや振る舞いの集合を、Context オブジェクトが再利用できるように、Strategy クラスの階層により定義している。継承がアルゴリズムの共通の機能を取り出す際の助けになる。<br><br><li><b>サブクラス化の代替案。</b>継承は、アルゴリズムや振る舞いの多様性をサポートするもう1つの方法を提供する。すなわち、Context クラスを直接サブクラス化して、異なる振る舞いを与えることができるのである。しかしこの方法では、Context クラスの中に振る舞いを埋め込んでしまうことになる。この方法では、アルゴリズムの実装と Context クラスの実装が混ざってしまい、Context クラスを理解し、保守し、拡張することをより難しくしてしまう。さらに、アルゴリズムを動的に変えることはできなくなってしまう。また、クラス間の違いは採用しているアルゴリズムや振る舞いが異なっているだけ、というクラスをたくさん導入することになってしまう。そこで、Strategy のサブクラスに別々にアルゴリズムをカプセル化することにより、Context オブジェクトとは独立にアルゴリズムを変更することができるようになる。これは、アルゴリズムを切り替え、理解し、拡張することを容易にする。<br><br><li><b>Strategy パターンは条件文を排除する。</b>Strategy パターンは、必要となる振る舞いを選択するための条件文に対する代替案を提供する。異なる振る舞いを1つのクラスにまとめる場合には、正しい振る舞いを選択するために条件文を利用せざるを得ない。そこで、異なる振る舞いを Strategy の別々のサブクラスにカプセル化することによりこれらの条件文を排除する。<br><font style="text-indent:10pt">　たとえば、Strategy パターンを導入しない場合には、テキストを行に分解するコードは次のようになる。<br><br><pre>    void Composition::Repair () {        switch (_breakingStrategy) {        case SimpleStrategy:            ComposeWithSimpleCompositor();            break;        case TeXStrategy:            ComposeWithTeXCompositor();            break;        // ...        }        // merge results with existing composition, if necessary    }</pre><br><br><font style="text-indent:10pt">　Strategy パターンでは、Strategy のオブジェクトに行への分解に関する処理を委譲することにより、この CASE 文を排除する。<br><br><pre>    void Composition::Repair () {        _compositor->Compose();        // merge results with existing composition, if necessary    }</pre><br><br><font style="text-indent:10pt">　多くの条件文を含むコードは、しばしば Strategy パターンを適用する必要があることを示している。<br><br><li><b>実装の選択。</b>Strategy パターンでは、同じ振る舞いに対して異なる実装を提供することができる。クライアントは、ConcreteStrategy クラスの中から、時間と空間のトレードオフにより適切な実装を選択することができる。<br><br><li><b>クライアントは、複数の ConcreteStrategy クラスの相違点を把握しておかなければならない。</b>このパターンには、適切な ConcreteStrategy クラスを選択する前に、クライアントはそれぞれの ConcreteStrategy クラスがどのように異なっているのかを理解しておかなければならないという潜在的な欠点がある。クライアントは、実装上の問題にさらされることになるだろう。したがって、振る舞いの種類がクライアントに関連がある場合にのみ、Strategy パターンを利用するべきである。<br><br><li><b>Strategy クラスと Context クラス間の通信に関するオーバーヘッド。</b>Strategy クラスのインタフェースは、実装するアルゴリズムが平凡か複雑かにかかわらず、すべての ConcreteStrategy クラスにより共有される。このことから、いくつかの ConcreteStrategy クラスが、このインタフェースを通して送られるすべての情報を利用しないことは十分にあり得る。簡単な ConcreteStrategy クラスはまったく情報を利用しないだろう。これは、利用することのないパラメータを Context クラスが生成し、初期化することを意味している。もしこれが問題ならば、Strategy クラスと Context クラスの間により密な結合が必要になる。<br><br><li><b>増加するオブジェクトの数。</b>Strategy パターンは、アプリケーションにおけるオブジェクトの数を増加させる。ときには、Context オブジェクト間で共有可能にするため、状態を持たないオブジェクトとして Strategy のオブジェクトを実装することによって、このオーバーヘッドを減らすことができる。残さなければならない状態は Context オブジェクトの側に持たせ、ConcreteStrategy オブジェクトに対して要求を出す際にこれを一緒に渡すようにする。共有される Strategy のオブジェクトには、さまざまなオブジェクトからの呼び出しにおいて状態を共有化できたとしても、そのような状態を持たせるべきではない。<a href="11.html" target="down">Flyweight パターン</a>では、より詳細にこのアプローチについて述べている。</ol></font></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　実装上の問題として、次に示す点を考える。<br><br><ol><li><b>Strategy クラスとContext クラスのインタフェースの定義。</b>Strategy クラスと Context クラスのインタフェースは、Context オブジェクトのどのようなデータに対しても、ConcreteStrategy オブジェクトが効果的にアクセスできるようにしなければならない。また、その逆もなり立っていなければならない。<br><font style="text-indent:10pt">　1つのアプローチは、Strategy クラスのオペレーションの引数を使って Context クラスがデータを渡す方法である（言い換えれば、ConcreteStrategy オブジェクトにデータを持っていくということである）。これは、Strategy クラスと Context クラスを未結合の状態に保つことである。しかし、その一方で、Context クラスは ConcreteStrategy オブジェクトが必要としないデータを送る可能性もある。<br><font style="text-indent:10pt">　これとは別に、Context オブジェクトに引数として自身を送らせ、これを受け取った ConcreteStrategy オブジェクトがその Context オブジェクトに対してデータを明示的に要求する、という方法がある。また、さらに別な方法として、Strategy のオブジェクトに Context オブジェクトに対する参照を持たせて、どのような情報の受け渡しも必要がないようにすることもできる。どちらの方法でも、Strategy のオブジェクトは必要な情報だけを要求できるようになる。しかしこのとき、Context クラスはデータに対する凝ったインタフェースを定義しなければならなくなり、これにより Strategy クラスと Context クラスはより密に結合することになる。<br><font style="text-indent:10pt">　上記の方法にはそれぞれ一長一短があるので、特定のアルゴリズムの必要性やそれに対するデータ要求に応じて最善の方法を選ぶことになる。<br><br><li><b>テンプレートパラメータとしての Strategy クラス。</b>C++では、あるクラスの構成要素として Strategy クラスを持たせるためにテンプレートを使うことができる。この技術は次のような場合にのみ適用可能である。(1) Strategy クラスをコンパイル時に選択できる。(2) Strategy クラスを実行時に変更する必要がない。この場合、構築されるクラス（たとえば Context クラス）は、Strategy クラスをパラメータとして持つテンプレートクラスとして定義される。<br><br><pre>    template &lt;class AStrategy>    class Context {        void Operation() { theStrategy.DoAlgorithm(); }        // ...    private:        AStrategy theStrategy;    };</pre><br><br><font style="text-indent:10pt">　このクラスには、インスタンス化される際に、パラメータとして Strategy クラスが与えられる。<br><br><pre>    class MyStrategy {    public:        void DoAlgorithm();    };        Context&lt;MyStrategy> aContext;</pre><br><br><font style="text-indent:10pt">　テンプレートを利用すれば、Strategy クラスに対するインタフェースを定義している抽象クラスを定義する必要がなくなる。また、テンプレートパラメータとして Strategy クラスを利用することで、Strategy クラスを Context クラスに静的に結合することができ、これにより実行効率を上げることができる。<br><br><li><b>Strategy のオブジェクトのオプション化。</b>もし Strategy のオブジェクトを持たないことに重要な意味があるのならば、Context クラスを簡単なものにしてもよい。Context クラスは、Strategy のオブジェクトにアクセスする前にそれを持っているのかどうかをチェックする。もし Strategy のオブジェクトが存在するならば、Context クラスはそのオブジェクトを普通に利用する。もし Strategy のオブジェクトが存在しないのならば、Context クラスはデフォルトの振る舞いを実行する。このアプローチの利点は、クライアントがデフォルトの振る舞いを好ましくないと考える場合を除き、クライアントは Strategy のオブジェクトを扱う必要がなくなるということである。</ol></ol></font></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　「動機」の節であげた例を発展させたコードを提示する。このコードは、InterViews［LCI+92］の Composition クラスと Compositor クラスの実装に基づいている。<br><font style="text-indent:10pt">　Composition クラスは、Component クラスのインスタンスの集合を保持している。このインスタンスは、文書におけるテキストやグラフィックな要素を表現している。Composition オブジェクトは、Compositor のサブクラスのインスタンスを利用して Component オブジェクトの集合を行に分解していく。このサブクラスのインスタンスは改行に関する strategy をカプセル化している。各 Component オブジェクトは、元の大きさ、拡大率、縮小率をデータとして持っている。拡大率は、Component オブジェクトをどれだけ拡大することができるのかを定義する。縮小率は、どれだけ縮小することができるのかを定義する。Composition オブジェクトは Compositor のオブジェクトにこれらの値を送り、Compositor のオブジェクトは改行にもっとも適した位置を決定するためにこれらの値を利用する。<br><br><pre>    class Composition {    public:        Composition(Compositor*);        void Repair();    private:        Compositor* _compositor;        Component* _components;    // the list of components        int _componentCount;       // the number of components        int _lineWidth;            // the Composition's line width        int* _lineBreaks;          // the position of linebreaks                                   // in components        int _lineCount;            // the number of lines    };</pre><br><br><font style="text-indent:10pt">　新しいレイアウトが必要になった場合、Composition オブジェクトは、どこで改行するのかを決めるために Compositor のオブジェクトに問い合わせを行う。Composition オブジェクトは、Component オブジェクトの元の大きさ、拡大率、縮小率を定義する3つの配列を Compositor のオブジェクトに渡す。また Composition オブジェクトは、Component オブジェクトの数、行の広さ、Compositor のオブジェクトが各改行の位置を格納するための配列も Compositor のオブジェクトに渡す。そして Compositor のオブジェクトでは、改行の位置を計算してこれを返す。<br><font style="text-indent:10pt">　Compositor クラスのインタフェースにより、Composition オブジェクトは Compositor のオブジェクトが必要とするすべての情報を渡すことができる。これは、Strategy のオブジェクトにデータを持っていく場合の例である。<br><br><pre>    class Compositor {    public:        virtual int Compose(            Coord natural[], Coord stretch[], Coord shrink[],            int componentCount, int lineWidth, int breaks[]        ) = 0;    protected:        Compositor();    };</pre><br><br><font style="text-indent:10pt">　Compositor クラスは抽象クラスであることに注意してほしい。具象サブクラスで特定の改行 strategy を定義する。<br><font style="text-indent:10pt">　Composition オブジェクトは、Repairオペレーションの中で Compositor のオブジェクトを呼び出す。Repair オペレーションは、まずそれぞれの Component オブジェクトの元の大きさ、拡大率、縮小率で配列を初期化する（それらの詳細は省略する）。次に、改行位置を得るために Compositor のオブジェクトを呼び出し、最後に、この改行位置に従って Component オブジェクトをレイアウトする（ここも省略）。<br><br><pre>    void Composition::Repair () {        Coord* natural;        Coord* stretchability;        Coord* shrinkability;        int componentCount;        int* breaks;            // prepare the arrays with the desired component sizes        // ...            // determine where the breaks are:        int breakCount;        breakCount = _compositor->Compose(            natural, stretchability, shrinkability,            componentCount, _lineWidth, breaks        );            // lay out components according to breaks        // ...    }</pre><br><br><font style="text-indent:10pt">　次に、Compositor のサブクラスを見てみよう。SimpleCompositor クラスは、どこに区切りを入れるべきかを決めるために、1行ごとにそこに入れることができる Component オブジェクトを調べる。<br><br><pre>    class SimpleCompositor : public Compositor {    public:        SimpleCompositor();            virtual int Compose(            Coord natural[], Coord stretch[], Coord shrink[],            int componentCount, int lineWidth, int breaks[]        );        // ...    };</pre><br><br><font style="text-indent:10pt">　TeXCompositor クラスは、より全体的な strategy を使う。このクラスは、Component オブジェクトの大きさと拡大率を考慮に入れて段落ごとに調べる。またこのクラスは、Component オブジェクト間の余白を最小化することにより、段落に均等な“色”を与えようとする。<br><br><pre>    class TeXCompositor : public Compositor {    public:        TeXCompositor();            virtual int Compose(            Coord natural[], Coord stretch[], Coord shrink[],            int componentCount, int lineWidth, int breaks[]        );        // ...    };</pre><br><br><font style="text-indent:10pt">　ArrayCompositor クラスは、規則的な間隔で Component オブジェクトを区切っていく。<br><br><pre>    class ArrayCompositor : public Compositor {    public:        ArrayCompositor(int interval);            virtual int Compose(            Coord natural[], Coord stretch[], Coord shrink[],            int componentCount, int lineWidth, int breaks[]        );        // ...    };</pre><br><br><font style="text-indent:10pt">　これらのクラスは、Compose オペレーションで渡されたすべての情報を利用するわけではない。SimpleCompositor クラスは Component オブジェクトの拡大率を無視し、元の大きさのみを考慮に入れている。また、TexCompositor クラスは渡されるすべての情報を利用するが、その一方で、ArrayCompositor クラスはすべてを無視する。<br><font style="text-indent:10pt">　Composition クラスをインスタンス化する際に、利用したい Compositor のオブジェクトを渡すようにする。<br><br><pre>    Composition* quick = new Composition(new SimpleCompositor);    Composition* slick = new Composition(new TeXCompositor);    Composition* iconic = new Composition(new ArrayCompositor(100));</pre><br><br><font style="text-indent:10pt">　Compositor クラスのインタフェースは、そのサブクラスが実装するであろうすべてのレイアウトアルゴリズムをサポートするために、注意深く設計されなければならない。新しいサブクラスを導入するたびに、このインタフェースを変更しなければならなくなるのは望ましくない。なぜならば、それは既存のサブクラスを変更することになるからである。一般に、Strategy クラスと Context クラスのインタフェースにより、このパターンがどれだけ目的を達成できるかが決まる。</font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　ET++［WGM88］と InterViews の両方で、ここで述べた異なる改行アルゴリズムをカプセル化した strategy を利用している。RTL Smalltalk コンパイラ［JML92］では、コンパイラコードの最適化のために、複数のレジスタアロケーションスキーマ（RegisterAllocator）と、インストラクションセットのスケジューリングに関する複数の方針（RISCscheduler、CISCscheduler）を、strategy が定義している。このことは、異なるマシンアーキテクチャのためのオプティマイザをターゲットにできるという点で柔軟性を与える。<br><font style="text-indent:10pt">　ET++スワップマネージャの計算エンジンのフレームワークは、さまざまな金融商品の価格を計算するものである［EG92］。このフレームワークでキーとなる抽象クラスは、Instrument クラスと YieldCurve クラスである。金融商品は、それぞれ Instrument のサブクラスとして実装される。YieldCurve クラスは、将来のキャッシュフローの値を表すために割引率を計算する。両方のクラスとも、一部の振る舞いを Strategy のオブジェクトに委譲する。このフレームワークでは、キャッシュフローを生成し、売買を評価し、割引率を計算するための ConcreteStrategy クラスの集合を提供している。Instrument クラスと YieldCurve クラスを構成する ConcreteStrategy オブジェクトを変えることにより、新しい計算エンジンを生成することができる。また、このアプローチでは ConcreteStrategy クラスを新たに定義するのと同様に、すでに存在する複数の ConcreteStrategy クラスの実装をミックスして調和させることもサポートしている。<br><font style="text-indent:10pt">　Booch コンポーネント［BV90］では、テンプレートの引数として strategy を利用している。Booch のコレクションクラスは、メモリ確保のための3種類の strategy をサポートしている。すなわち、managed（プール外、すなわちグローバルヒープでの確保）、controlled（確保/解放はロックによりプロテクトされている）、unmanaged（標準のメモリ確保）である。これらの strategy は、コレクションクラスのインスタンスを生成するときにテンプレートの引数として渡される。たとえば、unmanaged を利用する UnboundedCollection クラスのインスタンスを生成するときに、UnboundedCollection&lt;MyItemType*, Unmanaged&gt;と書く。<br><font style="text-indent:10pt">　RApp は、集積回路のレイアウトのためのシステムである［GA89、AG90］。RApp は、回路上のサブシステムをレイアウトし、さらにそれらを線で結ばなければならない。RApp での結線アルゴリズムは抽象クラス Router のサブクラスとして定義される。この Router クラスは Strategy クラスに相当する。<br><font style="text-indent:10pt">　Borland の ObjectWindows［Bor94］は、ユーザが正当なデータを入力していることを確認するために、ダイアログボックス内で strategy を利用している。たとえば、入力された数値がある範囲内にあることを確認しなければならないかもしれないし、また数値の入力フィールドにアラビア数字のみが入っていることを確認しなければならないかもしれない。文字列が正しいことを確かめるためには、テーブル検索が必要になるかもしれない。<br><font style="text-indent:10pt">　ObjectWindows では、確認のためのstrategyをカプセル化するために Validator クラスを利用する。Validator クラスは、Strategy クラスの例である。データの入力フィールドは、確認のための strategy をオプションで Validator のオブジェクトに委譲する。オプションの一例として、もし確認が必要ならばクライアントは入力フィールドに対して Validator のオブジェクトを結び付ける、ということがあげられる。ダイアログを閉じるときには、入力フィールドはデータの正当性を確かめるために Validator のオブジェクトに問い合わせを行う。このクラスライブラリは、数字のための RangeValidator クラスのように、よくあるケースのために Validator のサブクラスを提供している。クライアントの要求に合うような新しい確認のための strategy は、Validator をサブクラス化して容易に定義することができる。</font></font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="11.html" target="down">Flyweight パターン</a>: ConcreteStrategy オブジェクトは、しばしば有効な flyweight になる。</font><br><br><br></body></html>