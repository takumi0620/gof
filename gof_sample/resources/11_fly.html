<html><head><title>FLYWEIGHT</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/fly.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　多数の細かいオブジェクトを効率よくサポートするために共有を利用する。</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　設計段階でオブジェクトを利用することには利があるのだが、そのまま素直に実装したのでは極端にコストが高くついてしまうアプリケーションもある。<br><font style="text-indent:10pt">　たとえば、ほとんどの文書エディタはある程度モジュール化されたテキスト整形機能や編集機能を実装している。典型的なオブジェクト指向文書エディタは、表や図のように文書中に挿入される要素をオブジェクトとして表現している。しかし、文書中の文字まではオブジェクトとして扱わない。もし文字までをオブジェクトとして扱えば、アプリケーションの柔軟性はもっとも細かいレベルにまで達するであろう。たとえば、描画や整形の際に、文字と他の挿入要素を統一的に扱うことができるようになるだろう。また、アプリケーションは他の機能に影響を及ぼすことなく、新たな文字の集合をサポートすることもできるだろう。この場合、アプリケーションのオブジェクト構造は文書の物理的な構造を模写することができる。次の図は文書エディタがオブジェクトを用いて文字を表現する方法を示している。<br><br><br><p align="center"><img src="img/pics/flywe055.gif"></p><br><br><br><font style="text-indent:10pt">　このように設計する場合の欠点はそのコストである。中くらいのサイズの文書を表現するのにも、何十万個もの文字オブジェクトが必要になるかもしれない。これでは多くのメモリを消費してしまい、実行時のオーバーヘッドも許容できないものになってしまうかもしれない。Flyweight パターンは、極端なコスト高にならずに細かい粒度のオブジェクトを利用するための、オブジェクトの共有方法について述べている。<br><font style="text-indent:10pt">　flyweight とは、複数の文脈で同時に利用され得る共有オブジェクトのことである。flyweight は各文脈では独立したオブジェクトとして振る舞う。flyweight と、共有されていないオブジェクトを区別することはできない。また、flyweight はそれが利用される文脈に関して何も仮定を置くことはできない。ここでキーとなる概念は intrinsic 状態と extrinsic 状態の区別である。intrinsic 状態は flyweight の内部に格納される。この状態は、flyweight オブジェクトが利用される文脈には依存しない情報からなる。したがって、intrinsic 状態は共有できる。一方、extrinsic 状態は flyweight が利用される文脈に依存し、その文脈ごとに異なる。それゆえに、extrinsic 状態を共有することはできない。flyweight が extrinsic 状態を必要とするときには、クライアントオブジェクトがそれを flyweight に渡さなければならない。<br><font style="text-indent:10pt">　flyweight は、通常、オブジェクトで表現するには数が多すぎるような概念や実態をモデル化する。たとえば、文書エディタでは、アルファベットの各文字に対して flyweight を生成する。各 flyweight は文字コードを格納する。しかし、文書内における flyweight の座標位置やフォントは、文書中のその文字が現れる箇所で、テキスト配置アルゴリズムや整形コマンドにより決定される。この場合、文字コードは intrinsic 状態であり、他の情報は extrinsic 状態である。<br><font style="text-indent:10pt">　論理的には、文書中に文字が現れるごとに、それに対応して1つのオブジェクトが存在する。<br><br><br><p align="center"><img src="img/pics/flywe054.gif"></p><br><br><br>しかし、物理的には、文字ごとに1つの共有 flyweight オブジェクトが存在し、それが文書構造中の異なる文脈に現れる。ある1つの文字オブジェクトが複数箇所に現れる場合、その各出現は flyweight オブジェクトの共有プール内にある同じインスタンスを参照する。<br><br><br><p align="center"><img src="img/pics/flywe052.gif"></p><br><br><br>これらのオブジェクトのクラス構造を次に示す。Glyph クラスはグラフィックオブジェクトのための抽象クラスである。グラフィックオブジェクトのいくつかは flyweight かもしれない。extrinsic 状態に依存する可能性のあるオペレーションは、extrinsic 状態をパラメータとして渡される。たとえば、Draw オペレーションと Intersects オペレーションは処理を実行する前に、そのオブジェクトがどの文脈にいるのかを知らなければならない。<br><br><br><p align="center"><img src="img/pics/flywe053.gif"></p><br><br><br>たとえば、“a”という文字を表す flyweight は、対応する文字コードを格納するだけである。そのオブジェクトは位置やフォントを格納する必要はない。クライアントは、flyweight が自身を描画するのに必要となる、文脈に依存する情報を供給する。たとえば、Row オブジェクトは、自分の子オブジェクトを水平に並べるにはそれらをどこに描画すべきかを知っている。したがって、Row オブジェクトは自分の子オブジェクトに描画要求を送るときに、その位置情報を渡すことができる。<br><font style="text-indent:10pt">　異なる文字オブジェクトの数は文書中の全文字数よりもはるかに少ない。そのため、Flyweight パターンを用いた場合のオブジェクトの総数は、このパターンを用いない素朴な実装の場合に必要となるオブジェクトの総数よりも、かなり少なくなる。すべての文字が同じフォントと色で表示される文書では、その文書の長さに関係なく、100のオーダーの文字オブジェクト（ASCII 文字集合のおおよそのサイズ）が生成されることになる。また、ほとんどの文書ではフォントと色の組み合わせはたかだか10組ほどしか使われないので、文字オブジェクトの数は実際のところそれほど増えないであろう。したがって、このような形でオブジェクトを抽出しておくのは実際的である。　　　　　</font></font></font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Flyweight パターンの有効性は、それがどこで、どのように利用されるかに大きく依存する。以下のすべてがあてはまるときに Flyweight パターンを適用するとよい。<br><br><ul><li>アプリケーションが非常に多くのオブジェクトを利用する。<br><br><li>大量のオブジェクトのために、メモリ消費コストが高くつく。<br><br><li>オブジェクトの状態を構成するほとんどの情報を extrinsic にできる。<br><br><li>extrinsic 状態が取り除かれれば、オブジェクトのグループの多くを比較的少数の共有オブジェクトに置き換えることができる。<br><br><li>アプリケーションがオブジェクトの同一性に依存しない。flyweight オブジェクトは共有されている可能性があるため、概念的には異なるオブジェクトなのだが、同一性テストの結果は真になってしまうことがあるだろう。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/flywe050.gif"></p><br><br><br>次のインスタンスダイアグラムは、flyweight がどのように共有されるのかを示している。<br><br><br><p align="center"><img src="img/pics/flywe051.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Flyweight クラス</b> （Glyph クラス）<ul><li>flyweight が extrinsic 状態を受け取り、それに基づいて行動できるようにするためのインタフェースを定義する。</ul><br><br><li><b>ConcreteFlyweight クラス</b> （Character クラス）<ul><li>Flyweightクラスのインタフェースを実装し、intrinsic 状態があればその格納場所を追加する。ConcreteFlyweight オブジェクト（flyweight に該当する）は共有可能でなければならない。ConcreteFlyweight オブジェクトが格納する状態はすべて intrinsic でなければならない。すなわち、それは文脈に依存してはならない。</ul><br><br><li><b>UnsharedConcreteFlyweight クラス</b> （Row クラス、Column クラス）<ul><li>Flyweight のサブクラスのすべてが共有可能になっている必要はない。Flyweight クラスのインタフェースは共有を可能にしてはいるが、共有を強制するわけではない。UnsharedConcreteFlyweight オブジェクトは、flyweight からなるオブジェクト構造において階層を形成し、ConcreteFlyweight オブジェクトを子として管理する役目を持つのが一般的である。</ul><br><br><li><b>FlyweightFactory クラス</b><ul><li>flyweight を生成し、管理する。<li>flyweight が正しく共有されることを保証する。Client オブジェクトが flyweight を要求したとき、FlyweightFactory オブジェクトはそのインスタンスが存在する場合にはそれを与え、存在しない場合には新たに生成する。</ul><br><br><li><b>Client クラス</b><ul><li>1つ、あるいは複数の flyweight への参照を保持する。<li>flyweightのextrinsic 状態を計算するか、または格納する。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>flyweight が機能するために必要な状態は、intrinsic 状態か extrinsic 状態のどちらかに分類されなければならない。intrinsic 状態は ConcreteFlyweight オブジェクト内に格納される。一方、extrinsic 状態は Client オブジェクトにより格納されるか、または計算される。Client オブジェクトは、ConcreteFlyweight オブジェクトに対してオペレーションを呼び出すときに、extrinsic 状態を一緒に渡す。<br><br><li>Client オブジェクトは ConcreteFlyweight オブジェクトを直接インスタンス化すべきではない。ConcreteFlyweight オブジェクトが正しく共有されることを保証するために、Client オブジェクトは必ずそれらを FlyweightFactory オブジェクトから入手しなければならない。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　flyweight の導入に伴い、extrinsic 状態の受け渡しや探索、計算に関連する実行時のコストは増大するかもしれない。以前は intrinsic 状態として格納されていた状態を extrinsic 状態とした場合には、特にこのことが言える。しかし、そのようなコストはメモリ空間を節約することによって補われる。より多くのオブジェクトが flyweight として共有されるにしたがって、この節約は進んでいく。<br><font style="text-indent:10pt">　メモリ空間の節約はいくつかの要因から導き出すことができる。<br><br><ul><li>共有による全インスタンス数の減少。<br><br><li>1つのオブジェクトあたりの intrinsic 状態の量。<br><br><li>extrinsic 状態は計算されるのか、あるいは格納されているのか。</ul><br><font style="text-indent:10pt">　より多くのオブジェクトが flyweight として共有されるほど、より多くのメモリが節約されることになる。この節約は共有される状態の量とともに進んでいく。格納コストをもっとも節約できるのは、オブジェクトが intrinsic 状態と extrinsic 状態の両方についてかなりの量の情報を持ち、しかも extrinsic 状態が格納されるのではなくて計算できる場合である。この場合、メモリは次の2点から節約される。すなわち、intrinsic 状態が占めているメモリ領域を共有により減らし、また extrinsic 状態の格納にかかるコストを計算時間と交換する。<br><font style="text-indent:10pt">　共有 Leaf ノードを持つグラフとして階層構造を表現するために、Flyweight パターンはしばしば <a href="08.html" target="down">Composite パターン</a>と組み合わされる。この場合、Leaf ノードとなる flyweight は共有されるため、親オブジェクトへのポインタを格納することはできなくなる。その代わりに、親オブジェクトへのポインタは flyweight に extrinsic 状態の一部として渡される。このことは、階層構造上のオブジェクト同士の通信方法に大きな影響を及ぼす。</font></font></font></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Flyweight パターンを実装するときには次の問題を考慮する。<br><br><ol><li> extrinsic 状態を取り除く。このパターンの適用可能性は、主に、extrinsic 状態を識別してそれを共有オブジェクトから取り除くことがいかに簡単にできるかで決まる。もし共有する以前の全オブジェクト数と同じくらいに多くの種類の extrinsic 状態が存在するのであれば、extrinsic 状態を取り除いてもメモリの節約には役立たないだろう。メモリ消費量がはるかに少ない別の独立したオブジェクト構造から、extrinsic 状態を計算できるのが理想的である。<br><font style="text-indent:10pt">　文書エディタの例では、各文字オブジェクトにフォントとスタイルを格納するのではなく、別の独立した構造の中に印字情報のマップを格納しておくことができる。このマップは、同じ印字属性を持つ文字をまとめて管理している。ある文字が自身を描画するときには、このマップを走査して印字属性を受け取る。文書は、通常、異なるフォントやスタイルを少ししか使わないので、これらの情報を文字オブジェクトの外部に格納する方が、内部に格納するよりもはるかに効率的である。<br><br><li>共有オブジェクトを管理する。オブジェクトは共有されるので、クライアントがそれらを直接インスタンス化すべきではない。FlyweightFactory オブジェクトが flyweight をインスタンス化して、それをクライアントに渡すようにする。FlyweightFactory オブジェクトはしばしば共同の格納場所を1つ用意して、クライアントがその格納場所から興味のある flyweight を調べられるようにする。文書エディタの例では、FlyweightFactory オブジェクトは文字コードでインデックス付けされた flyweight の表を持っている。この FlyweightFactory オブジェクトは文字コードを与えられると、それに対応する flyweight を返す。この際、もし対応する flyweight が存在しなければ、それを生成してから返す。<br><font style="text-indent:10pt">　オブジェクトの共有では、flyweight が不要になったときにその格納場所を整理するために、何らかの形の参照数管理やガーベッジコレクションが必要になる。しかし、flyweight の数が一定で少ない場合（たとえば、ASCII 文字集合のための flyweight など）には、参照数管理もガーベッジコレクションも不要である。そのような場合には、flyweight をそのまま残しておくのがよい。</ol></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　ここでは、文書整形の例に戻る。flyweight として、グラフィックオブジェクトのための基底クラス Glyph を定義する。論理的には Glyph クラスは、グラフィック属性を持ち、自身を描画できる Composite クラス（<a href="08.html" target="down">Composite パターン</a>を参照）である。ここではフォント属性だけに着目するが、Glyph クラスが持つ他のグラフィック属性に対しても、同じアプローチが適用できる。<br><br><pre>    class Glyph {    public:        virtual ~Glyph();            virtual void Draw(Window*, GlyphContext&amp;);            virtual void SetFont(Font*, GlyphContext&amp;);        virtual Font* GetFont(GlyphContext&amp;);            virtual void First(GlyphContext&amp;);        virtual void Next(GlyphContext&amp;);        virtual bool IsDone(GlyphContext&amp;);        virtual Glyph* Current(GlyphContext&amp;);            virtual void Insert(Glyph*, GlyphContext&amp;);        virtual void Remove(GlyphContext&amp;);    protected:        Glyph();    };</pre><br><br><font style="text-indent:10pt">　Character サブクラスは文字コードのみを格納する。<br><br><pre>    class Character : public Glyph {    public:        Character(char);            virtual void Draw(Window*, GlyphContext&amp;);    private:        char _charcode;    };</pre><br><br><font style="text-indent:10pt">　glyph（Glyph の任意のサブクラスのインスタンスを glyph と呼ぶ）ごとにフォント属性の格納場所を割り当てるのを避けるために、フォント属性を GlyphContext オブジェクト内に extrinsic 状態として格納する。この GlyphContext クラスは、extrinsic 状態のリポジトリとして機能する。GlyphContext オブジェクトは、異なる文脈ごとに glyph とそのフォント（および、フォント以外にも glyph が持っているグラフィック属性）との間の簡潔なマッピングを保持している。与えられた文脈で glyph のフォントを知る必要があるオペレーションには、GlyphContext オブジェクトがパラメータとして渡される。そのオペレーションは、渡された GlyphContext オブジェクトに対して、その文脈でのフォントを問い合わせることができる。文脈は、glyph からなる構造の中の位置に依存している。そのため、Glyph クラスのオペレーションの中で、子オブジェクトに対して iteration を行うものや、子オブジェクトを操作するものは、実行されるたびに必ず GlyphContext オブジェクトを更新しなければならない。<br><br><pre>    class GlyphContext {    public:        GlyphContext();        virtual ~GlyphContext();            virtual void Next(int step = 1);        virtual void Insert(int quantity = 1);            virtual Font* GetFont();        virtual void SetFont(Font*, int span = 1);    private:        int _index;        BTree* _fonts;    };</pre><br><br><font style="text-indent:10pt">　glyph からなる構造上を走査する際には、GlyphContext オブジェクトには常に現在位置が通知されなければならない。GlyphContext::Next オペレーションは走査が進むたびに-index を増やす。Glyph のサブクラスのうち子オブジェクトを持つクラス（たとえば、Row クラスや Column クラス）は、走査の各時点で GlyphContext::Next オペレーションを呼び出すように、Next オペレーションを実装しなければならない。<br><font style="text-indent:10pt">　glyph からフォントへのマッピングはBTree構造に格納される。GlyphContext:: GetFont オペレーションは-index をその BTree 構造へのキーとして利用する。BTree 構造上の各ノードは、そのノードがフォント情報を与えている文字列の長さでラベル付けされる。BTree 構造上の Leaf ノードはフォントを指し示し、Leaf ノードに至るまでの中間ノードは部分文字列への分解を表している。<br><font style="text-indent:10pt">　glyph からなる合成構造の一部を抜粋したものを次に示す。以下ではこの例について考察する。<br><br><br><p align="center"><img src="img/pics/btree097.gif"></p><br><br><br><font style="text-indent:10pt">　フォント情報の BTree 構造は、次のようになる。<br><br><br><p align="center"><img src="img/pics/btree-1.gif"></p><br><br><br><font style="text-indent:10pt">　BTree 構造の中間ノードは glyph インデックスの範囲を定義している。フォントが変更されたときや、glyph が追加されたり削除されたりしたときに、この BTree 構造は更新される。たとえば、走査中の GlyphContext オブジェクトの-index の値が102とすると、次のコードは、“expect”という単語内の各文字に、そのまわりのテキストと同じフォント（すなわち、12ポイント Times Roman を表す Font クラスのインスタンス times12）を設定する。<br><br><pre>    GlyphContext gc;    Font* times12 = new Font("Times-Roman-12");    Font* timesItalic12 = new Font("Times-Italic-12");    // ...        gc.SetFont(times12, 6);</pre><br><br><font style="text-indent:10pt">　新たな BTree 構造は次のようになる（変化する箇所を黒で示してある）。<br><br><br><p align="center"><img src="img/pics/btree-2.gif"></p><br><br><br><font style="text-indent:10pt">　次に、“don't”という単語（その後ろの空文字も含む）を“expect”の直前に12ポイント Times Italic フォントで追加しよう。オブジェクト gcの-index の値がまだ102だと仮定すると、次のコードによりオブジェクト gc に“don't”の追加が伝えられる。<br><br><pre>    gc.Insert(6);    gc.SetFont(timesItalic12, 6);</pre><br><br><font style="text-indent:10pt">　この追加により、BTree 構造は次のようになる。<br><br><br><p align="center"><img src="img/pics/btree-3.gif"></p><br><br><br><font style="text-indent:10pt">　GlyphContext オブジェクトは、現在の glyph のフォントに関する問い合わせを受けると、そのインデックスに対応するフォントを見つけるまで、ノード上のラベルを合計しながら BTree 構造を下っていく。フォント変更の頻度は比較的少ないため、この BTree 構造の大きさは glyph からなる構造と比較して小さくて済む。したがって、検索時間が過度に増えることなく、フォント情報の格納コストを減らすことができる。<br><br><font style="text-indent:10pt">　最後に、FlyweightFactory オブジェクトが必要である。FlyweightFactory オブジェクトは、glyph を生成し、それらが正しく共有されることを保証する。GlyphFactory クラスは、Character クラスや他の Glyph クラスをインスタンス化する。この例では Character オブジェクトのみが共有される。合成オブジェクトは Character オブジェクトよりもはるかに少なく、また、いずれにせよそれらの重要な状態（すなわち、子オブジェクト）は intrinsic である。<br><br><pre>    const int NCHARCODES = 128;        class GlyphFactory {    public:        GlyphFactory();        virtual ~GlyphFactory();            virtual Character* CreateCharacter(char);        virtual Row* CreateRow();        virtual Column* CreateColumn();        // ...    private:        Character* _character[NCHARCODES];    };</pre><br><br><font style="text-indent:10pt">　-character 配列は、文字コードでインデックス付けされた Character オブジェクトへのポインタを含む。この配列はコンストラクタで0に初期化される。<br><br><pre>    GlyphFactory::GlyphFactory () {        for (int i = 0; i < NCHARCODES; ++i) {             _character[i] = 0;        }    }</pre><br><br><font style="text-indent:10pt">　CreateCharacter オペレーションは、与えられた文字をその配列内の Character オブジェクトから探し、その文字に対応する Character オブジェクトが存在する場合は、それを返却する。そのようなオブジェクトが存在しない場合には、それを生成し、配列に登録してから返却する。<br><br><pre>    Character* GlyphFactory::CreateCharacter (char c) {        if (!_character[c]) {            _character[c] = new Character(c);        }            return _character[c];    }</pre><br><br><font style="text-indent:10pt">　Character オブジェクト以外の glyph は共有されないので、他のオペレーションは呼び出されるたびに新たなオブジェクトを生成するだけである。<br><br><pre>    Row* GlyphFactory::CreateRow () {        return new Row;    }        Column* GlyphFactory::CreateColumn () {        return new Column;    }</pre><br><br><font style="text-indent:10pt">　これらのオペレーションを省略して、共有されない glyph はクライアントに直接インスタンス化させることも可能である。しかし、後にこれらの glyph も共有されるようにした場合には、クライアントのコード内でそれらを生成している箇所まで変更しなければならなくなるだろう。</font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　flyweight の概念は、InterViews 3. 0［CL90］における設計テクニックとして初めて記述され、研究された。その開発者は、この概念を立証するために、Doc と呼ばれる強力な文書エディタを構築した［CL92］。Doc は文書内の各文字を表現するために Glyph のオブジェクトを用いている。このエディタでは、各スタイル（グラフィックにかかわる属性を定義している）の各文字ごとに Glyph クラスのインスタンスを1つ生成する。したがって、文字の intrinsic 状態は文字コードとスタイル情報（スタイルテーブルへのインデックス）からなる。これは、extrinsic 状態は位置情報だけであることを意味し、これによりDocは速くなっている。文書は Document クラスとして表現される。この Document クラスは FlyweightFactory の役割も持つ。Doc に対する評価から、文字オブジェクトを flyweight として共有するのは非常に効果的であることが示された。ある典型的な例では、180，000文字を含む文書に対して、わずか480個の文字オブジェクトしか必要でなかった。<br><font style="text-indent:10pt">　ET++［WGM88］は look-and-feel からの独立をサポートするために flyweight を利用している。look-and-feel 規格はユーザインタフェース要素（たとえば、スクロールバー、ボタン、メニューなど、総称ウィジェットとして知られているもの）の配置と装飾（たとえば、シャドウや傾斜など）に関係している。ウィジェットは、配置と描画をすべて、別の Layout オブジェクトに委譲する。Layout オブジェクトを取り換えることにより、たとえ実行時であっても look-and-feel を変えることができる。<br><font style="text-indent:10pt">　各ウィジェットクラスごとに、1つの Layout クラス（たとえば、ScrollbarLayout クラス、MenubarLayout クラスなど）が対応する。しかし、Layout オブジェクトを利用するこのアプローチには、ユーザインタフェース関連のオブジェクト数が2倍になってしまうという明らかな問題がある。すなわち、ユーザインタフェース関連の各オブジェクトに対して、さらに Layout オブジェクトの追加が必要になるのである。このオーバーヘッドを避けるために、Layout オブジェクトを flyweight として実装する。Layout オブジェクトは flyweight とするのに格好のオブジェクトである。なぜならば、Layout オブジェクトは主にオブジェクトの配置や描画に関する一定の振る舞いを扱っており、さらに、その際に必要となる extrinsic 状態はわずかだからである。<br><font style="text-indent:10pt">　Layout オブジェクトは Look オブジェクトにより生成され、管理される。Look クラスは、GetButtonLayout や GetMenuLayout などのオペレーションを持つ Layout オブジェクトを規格に合わせて特定化する AbstractFactory クラスである。look-and-feel の規格ごとに、それに対応する Look のサブクラス（たとえば、MotifLook、OpenLook など）が存在し、それが規格に合った Layout オブジェクトを提供する。<br><font style="text-indent:10pt">　ところで、Layout オブジェクトは本質的には strategy（<a href="21.html" target="down">Strategy パターン</a>を参照）である。Layout オブジェクトは、flyweight として実装された strategy の例である。</font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="08.html" target="down">Composite パターン</a>: Flyweight パターンは、しばしば <a href="08.html" target="down">Composite パターン</a>と組み合わされて、共有 Leaf ノードを持つ有向非循環グラフとして論理的な階層構造を実装するために使われる。<br><font style="text-indent:10pt">　<a href="20.html" target="down">State パターン</a>、<a href="21.html" target="down">Strategy パターン</a>: これらのパターンを flyweight として実装するのは、しばしば最良の実装となる。</font></font><br><br><br></body></html>