<html><head><title>ITERATOR</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/ite.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　集約オブジェクトが基にある内部表現を公開せずに、その要素に順にアクセスする方法を提供する。</font><br><br><br><a name="betu"><img src="img/00/betu.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Cursor</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　リストのような集約オブジェクトは、その内部構造を明かすことなく、要素にアクセスする方法をユーザに対して提供するべきである。さらに、リストに対して何をしたいのかにより、リストを異なった方法で走査したくなるかもしれない。しかし、異なる走査ごとにオペレーションを用意して、List クラスのインタフェースをふくらましていくことは、たとえ必要となるオペレーションが前もってわかっていたとしても、おそらくやりたくはないだろう。また、1つのリストに対して、複数の走査が必要になるのかどうかはっきりしない、ということもあるだろう。<br><font style="text-indent:10pt">　Iterator パターンでは、このすべてをユーザに行わせる。このパターンのキーとなる考えは、リストオブジェクトからアクセスや走査のための責任を抜き出して、これを iterator オブジェクトに与えるということである。Iterator クラスは、リストオブジェクトの要素にアクセスするためのインタフェースを定義している。また iterator には、走査を記録しておく責任がある。すなわち、iterator はどの要素がすでに走査されたのかを知っている。<br><font style="text-indent:10pt">　たとえば、次の関係に示すように、List クラスは ListIterator クラスを必要とするだろう。<br><br><br><p align="center"><img src="img/pics/itera039.gif"></p><br><br><br><font style="text-indent:10pt">　ListIterator クラスをインスタンス化する前に、走査すべき List オブジェクトを与えなければならない。ListIterator オブジェクトを生成することで、List オブジェクトの要素に順番にアクセスすることができるようになる。CurrentItem オペレーションは、List オブジェクト中のカレント要素を返す。First オペレーションは、カレント要素を1つめの要素として初期化する。Next オペレーションは、カレント要素を次の要素に進める。IsDone オペレーションは、カレント要素を、最後の要素を越えてさらにその先に進めようとしていないか（すなわち、走査が終わっていないか）をテストする。<br><font style="text-indent:10pt">　走査のメカニズムを List オブジェクトから切り離すことで、List インタフェースを使って要素を列挙していく以外にも、走査について異なる方針を持った iterator を定義することができるようになる。たとえば、特別な制約を満たす要素に対してのみアクセスを与えるような FilteringListIterator クラスを考えることもできる。<br><font style="text-indent:10pt">　iterator とリストは組にされており、クライアントは走査されている集約構造がリストであることを知らなければならない、ということに注意してほしい。したがって、クライアントは特別な集約構造に依拠することになる。もしクライアントクラスのコードを変えることなく集約クラスを変えることができれば、さらに便利になるだろう。これは、iterator の概念がポリモルフィックな iteration をサポートするように一般化することにより実現できる。<br><font style="text-indent:10pt">　1つの例として、リストが SkipList クラスにより実装してあると仮定しよう。skiplist［Pug90］は、バランスツリーに類似した、文字列を格納するための確率的なデータ構造である。そこで、List オブジェクトと SkipList オブジェクトの両方に通用するコードを書くことができるようにしたい。<br><font style="text-indent:10pt">　AbstractList クラスを、リストを操作する共通のインタフェースを与えるように定義する。同様に、共通の iteration インタフェースを定義している抽象化された Iterator クラスが必要になる。これにより、リストの異なる実装ごとに Iterator の具象サブクラスを定義することができる。その結果、iteration のメカニズムを集約の具象クラスからは独立にしておくことができるようになる。<br><br><br><p align="center"><img src="img/pics/itera040.gif"></p><br><br><br><font style="text-indent:10pt">　iterator をどのように生成するのかが残された問題になる。リストの具象サブクラスからは独立したコードを書きたいので、ある特化されたクラスをインスタンス化することはできない。その代わりに、リストに対応する iterator を生成させるようにする。そのためには、CreateIterator のようなオペレーションが必要となる。CreateIterator は、クライアントが iterator オブジェクトを要求するときに使うオペレーションである。<br><font style="text-indent:10pt">　CreateIterator オペレーションは、factory method の使用例になる（<a href="03.html" target="down">Factory Method パターン</a>を参照）。クライアントが適切な iterator をリストオブジェクトに依頼するようにするために、factory method を使う。factory method によるアプローチは、2つのクラス階層を構築していくことにつながる。1つはリストのための階層であり、もう1つは iterator のための階層である。CreateIterator はこの2つの階層をつないでいる。</font></font></font></font></font></font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のような場合に Iterator パターンを使うとよい。<br><br><ul><li>集約オブジェクトの内部表現を公開せずに、その中にあるオブジェクトにアクセスしたい場合。<br><br><li>集約オブジェクトに対して、複数の走査をサポートしたい場合。<br><br><li>異なる集約構造の走査に対して、単一のインタフェースを提供したい（すなわち、ポリモルフィックな iteration をサポートしたい）場合。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/iterator.gif"></p></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Iteratorクラス</b><ul><li>要素にアクセスしたり走査したりするためのインタフェースを定義する。</ul><br><br><li><b>ConcreteIterator クラス</b><ul><li>Iterator クラスで定義したインタフェースを実装する。<li>Aggregate オブジェクトの走査の際に、カレント要素を記録する。</ul><br><br><li><b>Aggregate クラス</b><ul><li>Iterator オブジェクトを生成するためのインタフェースを定義する。</ul><br><br><li><b>ConcreteAggregate クラス</b><ul><li>Aggregate クラスで定義したインタフェースに対して、適切な ConcreteIterator クラスのインスタンスを生成して返すように実装する（ConcreteAggregate クラスのインスタンスを、総称して aggregate と呼ぶ）。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>ConcreteIterator オブジェクトは、aggregate の走査の際にカレント要素を記録し、また、走査を進めていく先を計算することができる。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Iterator パターンを適用することにより、3つの重要な結果が得られる。<br><br><ol><li><b>aggregate に対してさまざまな走査をサポートする。</b>複雑な aggregate には、走査の方法がたくさんあるだろう。たとえばコード生成とセマンティックチェックの際には、構文解析木を走査することになる。コード生成では、構文解析木を inorder に走査することもあれば、preorder に走査することもあるだろう。iterator は走査のアルゴリズムを容易に変えることができるようにする。単に、iterator を別のものに置き換えるだけでよいのである。また、新しい走査をサポートする Iterator のサブクラスを定義することもできる。<br><br><li><b>Iterator クラスは、Aggregate クラスのインタフェースを簡単なものにする。</b>Iterator クラスを導入することにより、Aggregate クラスが走査のインタフェースを備えておく必要はなくなる。したがって、Aggregate クラスのインタフェースを簡単なものにすることができる。<br><br><li><b>1つの aggregate に対して、複数の走査を実行することができる。</b>iterator は走査の状態を記録している。したがって、複数の走査を同時に実行することができる。</ol></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Iterator パターンには、実装に関して多くの方法とその変形がある。いくつかの重要な方法を紹介する。それらのトレードオフは、しばしば言語が提供している制御構造により決まる。たとえば CLU［LG86］などのように、このパターンを直接サポートしている言語もいくつかある。<br><br><ol><li><b>どのオブジェクトが iteration を制御するか。</b>基本的な問題は、iterator とその iterator を使うクライアントのどちらに、iteration を制御させるのかを決めることである。クライアントが iteration を制御するとき、その iterator は外部 iterator と呼ばれる。また、iterator がi teration を制御するときには、内部 iterator と呼ばれる。外部 iterator を使うクライアントは、走査を先に進め、iterator に対して次の要素を明示的に要求しなければならない。それとは対照的に、内部 iterator を使う場合は、クライアントは iterator に実行すべきオペレーションを渡して、iterator がそのオペレーションを aggregate の各要素に対して適用する。<br><font style="text-indent:10pt">　外部 iterator は内部 iterator に比べてより柔軟である。2つの集合が等しいことを外部 iterator を使って比べるのは容易だが、内部 iterator では実用的には不可能である。内部 iterator は、無名関数や closure や continuation を提供していない C++のような言語（Smalltalk や CLOS は提供している）には不向きである。しかし一方では、内部 iterator の方が容易に使うことができる。なぜならば、それらはユーザのために iteration のロジックを定義しているからである。<br><br><li><b>どのオブジェクトが走査のアルゴリズムを定義するのか。</b>走査のアルゴリズムを定義しているのは iterator だけではない。aggregate が走査のアルゴリズムを定義していて、iterator は単に iteration 状態を保存しておくためだけに使われるのかもしれない。我々はこのような iterator を cursor と呼ぶ。なぜならば、それは aggregate の中で参照されているところを指しているにすぎないからである。クライアントは、aggregate に対して Next オペレーションの呼び出しを行う際に、引数として cursor を与える。すると、Next オペレーションは cursor の状態を変化させる。<br><font style="text-indent:10pt">　もし iterator が走査のアルゴリズムを与えているのならば、同じ aggregate に対して異なった iteration アルゴリズムを使うことは容易になるし、また、異なった aggregate に対して同じアルゴリズムを再利用することもさらに容易になる。しかし、走査のアルゴリズムは aggregate の私的な変数にアクセスする必要があるかもしれない。もしそうだとすれば、iterator に走査のアルゴリズムを入れることは、aggregate プセル化を破壊することになる。<br><br><li><b>iterator はどれだけ頑強か。</b>走査を行っているときに aggregate に変更を加えるのは危険である。走査の最中に aggregate に要素を追加したり、または削除したりすると、ある要素に2回アクセスしてしまったり、またはまったくアクセスしなかったりということが起こりかねない。簡単な解決法は、aggregate をコピーし、走査はそのコピーに対して行うというものであるが、それは一般にコストが高くつきすぎる。<br><font style="text-indent:10pt">　robust iterator は、aggregate をコピーせずに、挿入と削除が走査を妨害しないようにする。robust iterator を実装するには多くの方法がある。ほとんどの場合、iterator を aggregate に登録しておくという方法をとっている。挿入や削除の際には、aggregate は自らが生成した iterator の内部状態をそれに適合させたり、または正しく走査が行われるように情報を内部で保管しておく。<br><font style="text-indent:10pt">　Kofler は、ET++を使って robust iterator をいかに実装するかということを論じている［kof93］。Murray は、USLStandardComponents の List クラスのための robust iterator の実装について論じている［Mur93］。<br><br><li><b>Iterator のオペレーションを追加する。</b>Iterator クラスの最小のインタフェースは、オペレーション First、Next、IsDone、CurrentItem からなる。さらにいくつかのオペレーションを追加しておくと便利かもしれない。たとえば、順序付けされた aggregate には、iterator が指している要素を1つ前に戻す Previous オペレーションを持たせることができるだろう。SkipTo オペレーションは、整列された、またはインデックス付けされた集合に対して便利である。SkipTo オペレーションは、iterator が特別な基準に合うオブジェクトを指すようにする。<br><br><li><b>C++でポリモルフィックな iterator を使う。</b>ポリモルフィックな iterator にはコストがかかる。これを使うには、factory method により、iterator が動的にヒープ上に確保されるようになっている必要がある。したがって、ポリモルフィズムが必要なところだけで使うようにすべきである。そうでなければ、iterator は、スタック上に確保されるようにして使う。<br><font style="text-indent:10pt">　ポリモルフィックな iterator には、もう1つ欠点がある。それは、クライアントが iterator を削除する責任を持たなければならないということである。これは、エラーの原因になりがちである。なぜならば、終了する際にヒープ領域に確保された iterator を解放するのを忘れやすいからである。このことは、1つのオペレーションの中に複数の exit ポイントが存在するときに、特に起こりやすい。また、もし例外処理が呼び出されると、Iterator オブジェクトは決して解放されないということも起こるだろう。<br><font style="text-indent:10pt">　<a href="12.html" target="down">Proxy パターン</a>は対処策を与える。すなわち、スタックに確保した proxy を実際の iterator に対する窓口として使うことができる。proxy は、デストラクタの中で iterator を削除する。したがって、proxy がスコープの外に出るときに、実際の iterator もそれに伴って解放されることになる。proxy オブジェクトは、例外処理の場合でもメモリを確実に解放することを保証する。これは、C++のよく知られたテクニック“resource allocation is initialization”［EZ90］の応用である。サンプルコードのところで例を示す。<br><br><li><b>iterator には、特権的なアクセス権を持たせてもよい。</b>iterator は、それを生成した aggregate の拡張と見なすことができる。iterator と aggregate は密接に結び付いている。C++ではこの密接な関係を、iterator を aggregate のフレンドクラスにすることにより表現できる。これにより、iterator が走査を効率よく実装できるようにすることのみを目的とするオペレーションを Aggregate クラスに定義する必要がなくなる。<br><font style="text-indent:10pt">　しかし、そのような特権的なアクセス権は、新しい走査を定義するのを困難にする。なぜならば、それは別のフレンドクラスを追加することになるため、aggregate のインタフェースを変えなければならないからである。この問題を避けるために、aggregate の重要だが公開されていないメンバにアクセスするために、Iterator クラスに保護的なオペレーションを入れておくこともできる。Iterator のサブクラスは、aggregate に対して特権的なアクセス権を得るために、このオペレーションを使う（これは Iterator のサブクラスだけの特徴である）。<br><br><li><b>composite オブジェクトのための iterator。</b>外部 iterator を、<a href="08.html" target="down">Composite パターン</a>で示されるような再帰的な集約構造上で実装するのは難しいだろう。なぜならば、構造内のカレント要素の位置が、ネスト化された構造の多階層に及ぶだろうからである。したがって外部 iterator は、走査を記録するために構造内でのパスを保存しておかなければならない。ときには、内部 iterator を使う方が簡単であろう。内部 iterator では、それ自体を再帰的に呼び出してパスを呼び出しのスタック中に暗黙のうちにたくわえることにより、カレント要素の位置を記録しておくことができる。<br><font style="text-indent:10pt">　もし、構造内のノードが、カレントをあるノードからその兄弟、親、子ノードに移すインタフェースを持っているならば、cursor を基にした iterator の方がよいだろう。cursor はカレントノードを記録しておくだけでよい。構造内の走査はノードのインタフェースに頼ることができる。<br><font style="text-indent:10pt">　composite の構造は、しばしば2種類以上の方法で走査する必要がある。preorder、postorder、inorder、breadth-first などの走査が一般的である。各走査は異なるクラスによりサポートすることができる。<br><br><li><b>NullIterator。</b>NullIterator は、境界条件を扱うために役立つ、変化した iterator である。定義により、NullIterator では常に走査が行われる。すなわち、IsDone オペレーションは常にtrueと評価される。<br><font style="text-indent:10pt">　NullIterator は、Composite のような木構造の aggregate を走査するのを容易にする。このような場合、走査中の各時点で、カレント要素に子ノードに対する iterator を依頼していくことになる。aggregate の要素は、通常は普通の iterator を返すが、末端の要素は NullIterator クラスのインスタンスを返す。そのようにして、構造全体を統一的な方法で走査するように実装する。</ol></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　基本ライブラリ（付録C参照）の一部である、簡単な List クラスの実装について見てみよう。Iterator クラスの実装に関して、2つの例を示す。1つは、List オブジェクトを前から後ろに向かって走査するもので、もう1つは、後ろから前に向かって走査するものである（基本クラスでは、前者しかサポートされていない）。そして、これらの iterator の使い方と、特定の実装に偏らないようにする方法について示す。その後、iterator が確実に削除されるように設計を変更する。最後の例では内部 iterator について説明し、それを外部 iterator と比較する。<br><br><ol><li><b>List クラスと Iterator クラスのインタフェース。</b>最初に、 iterator を実装するのに関係する List クラスのインタフェースの一部について見てみよう。<br><br><pre>    template &lt;class Item>    class List {    public:        List(long size = DEFAULT_LIST_CAPACITY);            long Count() const;        Item&amp; Get(long index) const;        // ...    };</pre><br><br><font style="text-indent:10pt">　List クラスは、公開部のインタフェースを通して iteration をサポートするかなり効率的な方法を提供する。それは両方の走査を実装するのに十分なものである。したがって、データ構造への特権的なアクセス権を iterator に与える必要はない。つまり、iterator のクラスを List のフレンドクラスにしなくてもよい。異なる走査を自由に使い分けることができるように、抽象クラス Iterator を定義する。そこでは、iterator のためのインタフェースを定義する。<br><br><pre>    template &lt;class Item>    class Iterator {    public:        virtual void First() = 0;        virtual void Next() = 0;        virtual bool IsDone() const = 0;        virtual Item CurrentItem() const = 0;    protected:        Iterator();    };</pre><br><br><li><b>Iterator のサブクラスを定義する。</b>ListIterator クラスは Iterator のサブクラスである。<br><br><pre>    template &lt;class Item>    class ListIterator : public Iterator&lt;Item> {    public:        ListIterator(const List&lt;Item>* aList);        virtual void First();        virtual void Next();        virtual bool IsDone() const;        virtual Item CurrentItem() const;        private:        const List&lt;Item>* _list;        long _current;    };</pre><br><br><font style="text-indent:10pt">　ListIterator クラスの実装は簡単である。それは、List オブジェクトとその List オブジェクト内へのインデックス-current を一緒に保存する。<br><br><pre>    template &lt;class Item>    ListIterator&lt;Item>::ListIterator (        const List&lt;Item>* aList    ) : _list(aList), _current(0) {    }</pre><br><br><font style="text-indent:10pt">　First オペレーションは、インデックスが先頭要素を指すようにする。<br><br><pre>    template &lt;class Item>    void ListIterator&lt;Item>::First () {        _current = 0;    }</pre><br><br><font style="text-indent:10pt">　Next オペレーションは、インデックスが次の要素を指すようにする。<br><br><pre>    template &lt;class Item>    void ListIterator&lt;Item>::Next () {        _current++;    }</pre><br><br><font style="text-indent:10pt">　IsDone オペレーションは、インデックスがListオブジェクト内の要素を指しているかどうかを確認する。<br><br><pre>    template &lt;class Item>    bool ListIterator&lt;Item>::IsDone () const {        return _current >= _list->Count();    }</pre><br><br><font style="text-indent:10pt">　最後に、CurrentItem オペレーションは、インデックスが指している要素を返す。もし iteration がすでに終了していれば、例外処理の IteratorOutOfBounds に入る。<br><br><pre>    template &lt;class Item>    Item ListIterator&lt;Item>::CurrentItem () const {        if (IsDone()) {            throw IteratorOutOfBounds;        }        return _list->Get(_current);    }</pre><br><br><font style="text-indent:10pt">　ReverseListIterator クラスの実装も同様である。ただし、First オペレーションはインデックスが List オブジェクトの最後の要素を指すようにし、Next オペレーションはインデックスが1つ前の要素を指すようにする。<br><br><li><b>iterator を使う。</b>Employee オブジェクトを要素に持つ List オブジェクトがあり、そこに含まれるすべての Employee オブジェクトを出力したいとする。Employee クラスでは、Print オペレーションを提供している。List オブジェクトのすべての要素を出力するために、iterator を引数としてとる PrintEmployees オペレーションを定義する。それは、List オブジェクトの走査と出力のために、iterator を使う。<br><br><pre>    void PrintEmployees (Iterator&lt;Employee*>&amp; i) {        for (i.First(); !i.IsDone(); i.Next()) {            i.CurrentItem()->Print();        }    }</pre><br><br><font style="text-indent:10pt">　前から後ろに向かう走査のための iterator と、後ろから前に向かう走査のための iterator の両方があるので、このオペレーションを利用して Employee オブジェクトを両方向から出力することができる。<br><br><pre>    List&lt;Employee*>* employees;    // ...    ListIterator&lt;Employee*> forward(employees);    ReverseListIterator&lt;Employee*> backward(employees);        PrintEmployees(forward);    PrintEmployees(backward);</pre><br><br><li><b>リストの特定の実装に依存するのを防ぐ。</b>List クラスを SkipList クラスに変えることにより、iteration のコードがどのように影響を受けるのかを考えてみよう。List のサブクラス SkipList は、Iterator クラスのインタフェースを実装するために SkipListIterator クラスを提供しなければならない。内部的には、SkipListIterator クラスには、iteration を効率的に行うために複数のインデックスを持たせなければならない。しかし、SkipListIterator クラスは Iterator クラスのインタフェースに従っているので、SkipList オブジェクト内に Employee オブジェクトが保存されているときには PrintEmployees オペレーションを使うことができる。<br><br><pre>    SkipList&lt;Employee*>* employees;    // ...        SkipListIterator&lt;Employee*> iterator(employees);    PrintEmployees(iterator);</pre><br><br><font style="text-indent:10pt">　このアプローチでもうまくいくのだが、リストの特定の実装（この場合だと SkipList クラス）に依存しないようにできれば、さらによいだろう。そこで、リストの異なる実装に対してインタフェースを統一するために、AbstractList クラスを導入する。List クラスと SkipList クラスは AbstractList のサブクラスになる。<br><font style="text-indent:10pt">　ポリモルフィックな iteration を可能にするために、AbstractList クラスでは、factory method として CreateIterator オペレーションを定義する。CreateIterator オペレーションは、サブクラスがオーバーライドして、対応する iterator を返すようにする。<br><br><pre>    template &lt;class Item>    class AbstractList {    public:        virtual Iterator&lt;Item>* CreateIterator() const = 0;        // ...    };</pre><br><br><font style="text-indent:10pt">　代替案としては、iterator を生成するためのインタフェースを提供する総合的な混成クラス Traversable を定義することも考えられるだろう。Aggregate クラスは、ポリモルフィックな iteration をサポートするために、Traversable クラスの中に混ぜ合わせてしまう。<br><font style="text-indent:10pt">　List クラスは、CreateIterator オペレーションをオーバーライドして、ListIterator オブジェクトを返す。<br><br><pre>    template &lt;class Item>    Iterator&lt;Item>* List&lt;Item>::CreateIterator () const {        return new ListIterator&lt;Item>(this);    }</pre><br><br><font style="text-indent:10pt">　これで、具体的な内部表現とは独立に、要素である Employee オブジェクトを出力するためのコードを書くことができるようになった。<br><br><pre>    // we know only that we have an AbstractList    AbstractList&lt;Employee*>* employees;    // ...        Iterator&lt;Employee*>* iterator = employees->CreateIterator();    PrintEmployees(*iterator);    delete iterator;</pre><br><br><li><b>iterator が確実に削除されるようにする。</b>CreateIterator オペレーションは、新たにメモリ上に確保された iterator を返す。これを使い終わったときには、削除しておかなければならない。もし削除し忘れると、メモリ上にゴミを残してしまうことになる。このようなクライアントの役割を軽くするために、iterator に対して proxy として振る舞う IteratorPtr クラスを与える。それは、スコープからはずれるときに iterator を一掃する。<br><font style="text-indent:10pt">　IteratorPtr オブジェクトは、常にスタック上に確保される。C++では、デストラクタの呼び出しは自動的に行われるが、そこで iterator の実体が削除されるようにしておく。IteratorPtr では、そのオブジェクトをあたかも iterator へのポインタのように扱えるように、operator-&gt;と operator*の両方をオーバーロードする。IteratorPtr のメンバは、すべてインラインで実装される。したがって、それらは実行時にオーバーヘッドを招くことはない。<br><br><pre>    template &lt;class Item>    class IteratorPtr {    public:        IteratorPtr(Iterator&lt;Item>* i): _i(i) { }        ~IteratorPtr() { delete _i; }            Iterator&lt;Item>* operator->() { return _i; }        Iterator&lt;Item>&amp; operator*() { return *_i; }    private:        // disallow copy and assignment to avoid        // multiple deletions of _i:            IteratorPtr(const IteratorPtr&amp;);        IteratorPtr&amp; operator=(const IteratorPtr&amp;);    private:        Iterator&lt;Item>* _i;    };</pre><br><br><font style="text-indent:10pt">　IteratorPtr クラスは、出力のためのコードを簡単にする。<br><br><pre>    AbstractList&lt;Employee*>* employees;    // ...        IteratorPtr&lt;Employee*> iterator(employees->CreateIterator());    PrintEmployees(*iterator);</pre><br><br><li><b>内部の ListIterator 。</b>最後の例として、内部の、すなわち受動的な ListIterator クラスの実装について見てみよう。この場合、iterator が iteration を制御し、各要素に対してオペレーションを適用する。<br><font style="text-indent:10pt">　この場合の問題は、各要素に対して実行したいオペレーションで iterator をパラメータ化する方法である。このような目的のために無名関数や closure を提供している言語がある一方で、C++ではそのようなサポートを行っていない。そこで、少なくとも次のような2つの選択肢がある。<br><br>(1)（グローバル、または静的な）関数に対するポインタを渡す。<br><br>(2)サブクラス化に頼る。<br><br><font style="text-indent:10pt">　(1)の場合、iterator は iteration の各時点で渡されるオペレーションを呼び出すことになる。(2)の場合、iterator は、サブクラスが特定の振る舞いを実行するためにオーバーライドするオペレーションを呼び出すことになる。<br><font style="text-indent:10pt">　どちらの方法も完璧ではない。しばしば、iteration の最中に状態を蓄積しておきたくなるのだが、関数ではこのような要求に対してしっかりと応えることはできない（状態を記憶するためには、静的な変数を使わなければならない）。Iterator のサブクラスで、蓄積された状態を保存しておくために、インスタンス変数のような便利な入れ物を用意することもできる。しかし、1つ1つの走査ごとにサブクラスを作っていくのは、さらにたいへんな作業になる。<br><font style="text-indent:10pt">　ここで、(2)のサブクラス化を行う場合の簡単な例を示す。内部 iterator を ListTraverser と呼ぶ。<br><br><pre>    template &lt;class Item>    class ListTraverser {    public:        ListTraverser(List&lt;Item>* aList);        bool Traverse();    protected:        virtual bool ProcessItem(const Item&amp;) = 0;    private:        ListIterator&lt;Item> _iterator;    };</pre><br><br><font style="text-indent:10pt">　コンストラクタ ListTraverser は、List クラスのインスタンスをパラメータとしてとる。このクラスは内部では、走査を行うために ListIterator オブジェクトを利用している。Traverse オペレーションは、走査を開始し、各要素に対して ProcessItem オペレーションを呼び出す。内部 iterator は、ProcessItem オペレーションから false が返されると走査を終了する。Traverse オペレーションは、走査が途中で終了していないかどうかを返している。<br><br><pre>    template &lt;class Item>    ListTraverser&lt;Item>::ListTraverser (        List&lt;Item>* aList    ) : _iterator(aList) { }        template &lt;class Item>    bool ListTraverser&lt;Item>::Traverse () {        bool result = false;            for (            _iterator.First();            !_iterator.IsDone();            _iterator.Next()        ) {            result = ProcessItem(_iterator.CurrentItem());                if (result == false) {                break;            }        }        return result;    }</pre><br><br><font style="text-indent:10pt">　Employee オブジェクトのリストの中から最初の10人を出力するために、ListTraverser クラスを使った例を示す。このためには、ListTraverser をサブクラス化して、ProcessItem オペレーションをオーバーライドしなければならない。このサブクラスでは、インスタンス変数の-count に、すでに出力した Employee オブジェクトの数をたくわえておくようになっている。<br><br><pre>    class PrintNEmployees : public ListTraverser&lt;Employee*> {    public:        PrintNEmployees(List&lt;Employee*>* aList, int n) :            ListTraverser&lt;Employee*>(aList),            _total(n), _count(0) { }        protected:        bool ProcessItem(Employee* const&amp;);    private:        int _total;        int _count;    };        bool PrintNEmployees::ProcessItem (Employee* const&amp; e) {        _count++;        e->Print();        return _count &lt; _total;    }</pre><br><br><font style="text-indent:10pt">　サブクラス PrintNEmployee が、リスト中の最初の10個の Employee オブジェクトを出力する様子を示す。<br><br><pre>    List&lt;Employee*>* employees;    // ...        PrintNEmployees pa(employees, 10);    pa.Traverse();</pre><br><br><font style="text-indent:10pt">　クライアントが iteration のループを記述していない点に注意してほしい。これにより、この iteration のためのロジックを再利用することができるようになる。内部 iterator では新しいクラスを定義しなければならないので、外部 iterator よりもわずかに手間がかかるが、再利用できるということが内部 iterator の主なメリットになる。この例と外部 iterator を使った場合を比較する。<br><br><pre>    ListIterator&lt;Employee*> i(employees);    int count = 0;        for (i.First(); !i.IsDone(); i.Next()) {        count++;        i.CurrentItem()->Print();            if (count >= 10) {            break;        }    }</pre><br><br><font style="text-indent:10pt">　内部 iterator は、異なる種類の iteration をカプセル化することができる。たとえば FilteringListTraverser クラスは、あるテストを通った要素のみを処理する iteration をカプセル化している。<br><br><pre>    template &lt;class Item>    class FilteringListTraverser {    public:        FilteringListTraverser(List&lt;Item>* aList);        bool Traverse();    protected:        virtual bool ProcessItem(const Item&amp;) = 0;        virtual bool TestItem(const Item&amp;) = 0;    private:        ListIterator&lt;Item> _iterator;    };</pre><br><br><font style="text-indent:10pt">　このインタフェースは、テストを定義するメンバ関数 TestItem が追加された点を除けば、ListTraverser クラスのインタフェースと同じである。サブクラスはテストの内容を明確にするために TestItem をオーバーライドする。<br><font style="text-indent:10pt">　Traverse オペレーションは、テストの結果に基づいて走査を続けることを決める。<br><br><pre>    template &lt;class Item>    void FilteringListTraverser&lt;Item>::Traverse () {        bool result = false;            for (            _iterator.First();            !_iterator.IsDone();            _iterator.Next()        ) {            if (TestItem(_iterator.CurrentItem())) {                result = ProcessItem(_iterator.CurrentItem());                    if (result == false) {                    break;                }            }        }        return result;    }</pre><br><br><font style="text-indent:10pt">　このクラスの変形として、Traverse オペレーションを、少なくとも1つの要素がテストを通ったならばリターンするように定義することもできる。</ol></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　iterator は、オブジェクト指向のシステムでは一般的である。大部分のコレクションクラスライブラリが、1つ、またはそれ以上の形式で、iterator を提供している。<br><font style="text-indent:10pt">　コレクションクラスライブラリとして人気の高い Booch コンポーネント［Boo94］から例をあげる。そこでは、キューに関して固定サイズ（上限がある）のものと、動的に成長していく（上限がない）ものの2種類の実装を提供している。キューのインタフェースは、抽象クラス Queue で定義している。実装が異なるキュー上でポリモルフィックな iteration をサポートするために、キューの iterator は、抽象クラス Queue のインタフェースを基にして実装されている。このような形でキューの実装に関する多様性を実現することで、キューの実装ごとに適切な iterator を選択させる factory method が必要なくなる、という利点がある。しかしこの方法では、抽象クラス Queue に、iterator を効率的に実装するのに十分なインタフェースを持たせておかなければならない。<br><font style="text-indent:10pt">　Smalltalk では iterator を明示的に定義する必要はない。標準的なコレクションクラス（Bag、SetDictionary、OrderedCollection、String など）で、内部 iterator のメソッドdo: を定義しているからである。do: はブロック（つまり、closure）を引数としてとる。コレクションオブジェクト内の各要素は、ブロック内のローカル変数に入れられる。そして、そのブロックが実行されるようになっている。また Smalltalk には、iterator のようなインタフェースをサポートしている Stream クラスの集合がある。たとえば、ReadStream クラスは本質的には Iterator であり、順序性のあるすべてのコレクションクラスに対して外部 iterator として振る舞う。Set クラスや Dictionary クラスのように順序性のないコレクションクラスに対しては、標準的な外部 iterator は存在しない。<br><font style="text-indent:10pt">　ポリモルフィックな iterator や前にあげたメモリの解放のための Proxy クラスは、ET++のコンテナクラス［WGM88］で提供されている。Unidraw のグラフィック編集フレームワークのクラスは、cursor に基づいた iterator［VL90］を使用している。<br><font style="text-indent:10pt">　ObjectWindow 2. 0［Bor94］は、コンテナクラスのために iterator のクラス階層を提供している。これにより、異なるコンテナの型に対して同じように iteration を行うことができる。ObjectWindow では、iteration を進めるためのインクリメントの後置オペレータ++をオーバーロードすることにより、iteration の内容を変えることができるようになっている。</font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="08.html" target="down">Composite パターン</a>: iterator は、しばしば Composite のような再帰的な構造に対して適用される。<br><font style="text-indent:10pt">　<a href="03.html" target="down">Factory Method パターン</a>: ポリモルフィックな iterator では、Iterator のサブクラスの中から適切なクラスをインスタンス化するために、factory method を使う。<br><font style="text-indent:10pt">　<a href="18.html" target="down">Memento パターン</a>: しばしば Iterator パターンとともに使われる。iterator は、iteration の状態を把握するために memento を使うことができる。この場合、iterator は memento を内部に保持する。</font></font></font><br><br><br></body></html>