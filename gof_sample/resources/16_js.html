<html><head><title>java sample code</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><img src="img/00/java.gif" hspace="10"><font style="margin-left:40px"><p><font style="text-indent:10pt">　Java には Iterator に相当するものとして java.util.Enumerationインターフェースが用意されている。このインターフェースの定義は次の通り：</font><p><pre>      public interface Enumeration {          public boolean hasMoreElements();          public Object nextElement();      }</pre><p>hasMoreElements() と nextElement() は C++ 版サンプルコードのIterator クラスの IsDone() と Next() にそれぞれ類似するメソッドである。ただし、hasMoreElements() は次の要素が控えている場合に true を返す。また、nextElement() は直接次の要素を返す点で Next() と違う。Enumeration インターフェースには First() とCurrentItem() に相当するメソッドは定義されていないが、多くの場合これらは使わないで事足りる。またここでは、C++ 版の List に相当するものとして java.util.Vector を使用する。<br><font style="text-indent:10pt">　Mixin クラスとして Traversable インターフェースを用意した。また、これを実装する java.util.Vector の子クラス TraversableVector を用意した。（ちなみに、java.util.Vector は Enumeration オブジェクト生成用のメソッド elements() をあらかじめ実装している。）Traversable と java.util.Enumeration を使うことで、特定のリストクラスに依存しないクライアントコードを書くことができる。しかし標準の Java は Traversable に相当する仕組みを予め用意していないため、標準クラスのクライアントは特定のリストクラスに依存せざるを得ない。例えば、java.util.Vector を使用するときは、クライアントはこのクラスへの参照を用いないとならない。</font><p>使用例：<pre>      Traversable employees;      // ...      java.util.Enumeration e = employees.createEnumeration();      while(e.hasMoreElements()) {              Employee emp = (Employee)e.nextElement();              emp.print();      }</pre><p><p><hr><pre>/* *  java.util.Enumeration * *  役割：&lt;Iterator&gt; * *  以下では iterator クラスとして java.util.Enumerationを使用す *  る。 */import java.util.Enumeration;/* *  NullEnumeration * *  役割：&lt;ConcreteIterator&gt;/Iterator, &lt;NullObject&gt;/Null Object * *  Null Object パターンは Pattern Languages of Program Design 3 *  (Addison-Wesley, 1998) に収録 */public class NullEnumeration implements java.util.Enumeration {    public boolean hasMoreElements() { return false; }    public Object nextElement()  throws IndexOutOfBoundsException {         throw new IndexOutOfBoundsException();    }}/* *  VectorEnumeration * *  役割：&lt;ConcreteIterator&gt; * *  java.util.Vector はあらかじめ Enumeration オブジェクトの *  factory method である elements() を実装しているが、例のため *  に Vector 用 Enumeration サブクラスをここで定義する。 */public class VectorEnumeration implements Enumeration {    public VectorEnumeration(java.util.Vector v) {        _vector = v;        _current = -1;    }    public Object nextElement() throws IndexOutOfBoundsException {        if (!hasMoreElements()) throw new IndexOutOfBoundsException();        return _vector.elementAt(++_current);    }    public boolean hasMoreElements() {        return _vector.size() &gt; _current+1;    }    private int _current;    private java.util.Vector _vector;}/* *  Traversable * *  役割：&lt;Aggregate&gt; */public interface Traversable {    public Enumeration createEnumeration();}/* *  TraversableVector * *  役割：&lt;ConcreteAggregate&gt; * *  java.util.Vector はあらかじめ Enumeration オブジェクトの *  factory method である elements() を実装しているが、例のため *  に Traversable インターフェースを実装するクラスを定義する。 */public class TraversableVector  extends java.util.Vector  implements Traversable      {    public TraversableVector(int initialCapacity,                             int capacityIncrement) {        super(initialCapacity, capacityIncrement);    }    public TraversableVector(int initialCapacity) {        super(initialCapacity);    }    public TraversableVector() { }    public Enumeration createEnumeration() {        return new VectorEnumeration(this);    }}/* *  FilteringVectorTraverser * *  役割：&lt;ConcreteAggregate&gt; * *  C++ 版サンプルコードのFilteringListTraverser と同等のものだが、 *  testElement() がデフォルトで true を返すようになっているため、 *  testElement() をオーバーライドしないでサブクラスを定義すれば *  ListTraverser と同等のものとして使用できる。 */public abstract class FilteringVectorTraverser {    public FilteringVectorTraverser(java.util.Vector v) {        _enumeration = new VectorEnumeration(v);    }    public boolean traverse() {        boolean result = false;        while(_enumeration.hasMoreElements()) {            Object element = _enumeration.nextElement();            if (testElement(element)) {                result = processElement(element);                if (!result) break;            }        }        return result;    }    protected abstract boolean processElement(Object elem);    protected boolean testElement(Object elem) { return true; }    private VectorEnumeration _enumeration;}/* *  PrintNEmployees * *  役割：&lt;ConcreteIterator&gt; * *  Internal iterator の例。 * *  使用例： * *      Vector employees; *      // ... * *      PrintNEmployees pa(employees, 10); *      pa.traverse(); * */public class PrintNEmployees extends FilteringVectorTraverser {    public PrintNEmployees(java.util.Vector v, int n) {        super(v);        _total = 0;        _count = 0;    }    protected boolean processElement(Object e) {        Employee employee = (Employee)e;        _count++;        employee.print();        return _count &lt; _total;    }    private int _total;    private int _count;}</pre><p><hr><p><font style="text-indent:10pt">　次に例として C++ 版 Iterator と同等の機能を持つインターフェースを定義する。また、これを実装する VectorIterator を示す。</font><br><font style="text-indent:10pt">　ここでは定義する Iterator は、Enumeration インターフェースを拡張し、欠けているメソッドを補う。C++ 版Iterator クラスの first() に相当するものとして rewind() を定義する。このメソッドの呼出し後最初の nextElement() は最初の要素を返すことが保証される。また C++ 版での CurrentItem() は currentElement() として定義する。rewind() 直後や全ての要素を巡回した後の currentElement() 呼び出しは例外を発生させる。</font><br><font style="text-indent:10pt">　Iterator インターフェースは java.util.Enumeration の拡張なのでこれを実装する concrete iterator は Enumeration オブジェクトとしても動作する。</font><p><hr><pre>/* *  Iterator * *  役割：&lt;Iterator&gt; */public interface Iterator extends java.util.Enumeration {    public void rewind();    // public boolean hasMoreElements(); // Enumeration で定義    // public Object nextElement();      // Enumeration で定義    public Object currentElement();}/* *  NullIterator * *  役割：&lt;ConcreteIterator&gt;/Iterator, &lt;NullObject&gt;/Null Object * *  Null Object パターンは Pattern Languages of Program Design 3 *  (Addison-Wesley, 1998) に収録 */public class NullIterator implements Iterator {    public void rewind() { }    public boolean hasMoreElements() { return false; }    public Object nextElement()  throws IndexOutOfBoundsException {         throw new IndexOutOfBoundsException();    }    public Object currentElement() throws IndexOutOfBoundsException {         throw new IndexOutOfBoundsException();    }}/* *  VectorIterator * *  役割：&lt;ConcreteIterator&gt; */public class VectorIterator implements Iterator {    public VectorIterator(java.util.Vector v) {        _vector = v;        _current = -1;    }    public void rewind() {        _current = -1;    }    public Object nextElement() throws IndexOutOfBoundsException {        if (!hasMoreElements()) throw new IndexOutOfBoundsException();        return _vector.elementAt(++_current);    }    public boolean hasMoreElements() {        return _vector.size() &gt; _current+1;    }    public Object currentElement() throws IndexOutOfBoundsException {        if (_current &lt; 0 || !hasMoreElements())            throw new IndexOutOfBoundsException();        return _vector.elementAt(_current);    }    private int _current;    private java.util.Vector _vector;}</pre><p></font></body></html>