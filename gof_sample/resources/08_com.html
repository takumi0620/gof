<html><head><title>COMPOSITE</title><meta http-equiv="Content-Type" content="text/html; charset=x-sjis"></head><body bgcolor=#ffffff text=#000000><font size="3"><img src="img/title/com.gif" hspace="10" vspace="10"><br><br><br><a name="moku"><img src="img/00/moku.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　部分―全体階層を表現するために、オブジェクトを木構造に組み立てる。Composite パターンにより、クライアントは、個々のオブジェクトとオブジェクトを合成したものを一様に扱うことができるようになる。</font><br><br><br><a name="douki"><img src="img/00/douki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　描画エディタや図表作成システムのようなグラフィックアプリケーションを使用すると、簡単な構成要素から複雑な図形を作り出すことができる。ユーザは構成要素を組み合わせて大きな構成要素を作り出すことができ、さらに、それらを組み合わせてより大きな構成要素を作り出すことができる。Text クラスや Line クラスなどのプリミティブなグラフィッククラスと、これらプリミティブなオブジェクトのコンテナとして働くクラスは、簡単に実装することができる。<br><font style="text-indent:10pt">　ところが、このアプローチには問題がある。つまり、たとえユーザがプリミティブなオブジェクトとコンテナのオブジェクトを同様に扱っていても、これらのクラスを使用するコードは、これらのオブジェクトを区別して扱わなければならない。このようにオブジェクトを区別しなければならない場合、アプリケーションはより複雑になる。Composite パターンでは、クライアントがこのような区別をする必要がなくなる再帰構成の使い方について説明する。<br><br><br><p align="center"><img src="img/pics/compo075.gif"></p><br><br><br><font style="text-indent:10pt">　Composite パターンの特徴は、1つの抽象クラスがプリミティブとコンテナの両方を表すことである。たとえば、グラフィックシステムでは、Graphic クラスがこの抽象クラスにあたる。Graphic クラスでは、各グラフィックオブジェクト（プリミティブ）に特化される Draw のようなオペレーションを宣言する。また、すべての合成オブジェクト（composite と呼ぶコンテナ）が共有するオペレーション、たとえば、子にあたるオブジェクトにアクセスしたり、それを管理するためのオペレーションなどを宣言する。<font style="text-indent:10pt">　Graphic のサブクラスである Line クラス、Rectangle クラス、Text クラスは、プリミティブなグラフィックオブジェクトを定義している（前記のクラスダイアグラムを参照）。これらのクラスではそれぞれ線、四角形、テキストを描画するように Draw オペレーションが実装される。また、これらのプリミティブなオブジェクトは、子オブジェクトを持たないため、子オブジェクトに関するオペレーションは実装しない。<font style="text-indent:10pt">　Picture クラスは Graphic オブジェクトの集約を定義するクラスである。そのため、Picture クラスでは、Draw オペレーションをその子オブジェクトの Draw オペレーションを呼び出すように実装し、またそれ以外にも、子オブジェクトに関連するオペレーションを実装する。Picture クラスのインタフェースは Graphic クラスのインタフェースに従っているため、Picture オブジェクトは別の Picture オブジェクトを再帰的に生成していくことができる。<font style="text-indent:10pt">　次の図は、Graphic オブジェクトから再帰的に構成される、典型的な Composite パターンによるオブジェクト構造を示している。<br><br><br><p align="center"><img src="img/pics/compo074.gif"></p></font></font></font></font></font></font><br><br><br><a name="teki"><img src="img/00/teki.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　次のような場合に、Composite パターンを使用する。<br><br><ul><li>オブジェクトの部分―全体階層を表現したい場合。<br><br><li>クライアントが、オブジェクトを合成したものと個々のオブジェクトの違いを無視できるようにしたい場合。このパターンを用いることで、クライアントは、composite 構造内のすべてのオブジェクトを一様に扱うことができるようになる。</ul></font><br><br><br><a name="kouzou"><img src="img/00/kouzou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><p align="center"><img src="img/pics/compo072.gif"></p><br><br><br><font style="text-indent:10pt">　Composite パターンによる典型的なオブジェクト構造は次のようになる。<br><br><br><p align="center"><img src="img/pics/compo073.gif"></p><br><br><br></font></font><br><br><br><a name="kousei"><img src="img/00/kousei.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li><b>Componen tクラス</b> （Graphic クラス）<ul><li>composite 内のオブジェクト（component と呼ぶ）のインタフェースを宣言する。<li>すべてのクラスに共通なインタフェースのデフォルトの振る舞いを適宜実装する。<li>子にあたる Component オブジェクトにアクセスしたり、それを管理するためのインタフェースを宣言する。<li>（オプション）再帰構造において、親にあたる composite にアクセスするためのインタフェースを宣言しておき、適宜実装する。</ul><br><br><li><b>Leaf クラス</b> （Rectangle クラス、Line クラス、Text クラスなど）<ul><li>composite 内の末端のオブジェクト（leaf と呼ぶ）を表す。つまり、leaf は子オブジェクトを持たない。<li>composite 内のプリミティブなオブジェクトの振る舞いを定義する。</ul><br><br><li><b>Composite クラス </b>（Picture クラス）<ul><li>子オブジェクトを持つ component（すなわち、composite）の振る舞いを定義する。<li>子にあたる component を保持する。<li> Component クラスのインタフェースで宣言された、子オブジェクトに関するオペレーションを実装する。</ul><br><br><li><b>Client クラス</b><ul><li>Component クラスのインタフェースを通して、composite 内のオブジェクトを操作する。</ul></ul></font><br><br><br><a name="kyou"><img src="img/00/kyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt"><ul><li>クライアントは、Component クラスのインタフェースを使って、composite 構造内のオブジェクトを操作する。オペレーションの受け手がleafであれば、その要求は直接処理される。composite が受け取った場合には、通常、その要求を子にあたる component に転送し、さらに転送の前後に付加的なオペレーションを実行することもある。</ul></font><br><br><br><a name="kekka"><img src="img/00/kekka.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Composite パターンを用いると、次のような結果が得られる。<br><br><ol><li><b>Leaf クラスと Composite クラスからなるクラス階層を定義する。</b>composite を使って leaf を組み合わせて複雑なオブジェクトを構成することができ、さらに、これらを再帰的に組み合わせて、より複雑なオブジェクトを構成することもできる。そして、クライアントのコードがleafを想定しているところでも、composite を扱うことができるようになる。<br><br><li><b>クライアントをわかりやすくする。</b>クライアントは composite 構造と個々のオブジェクトを一様に扱うことができる。クライアントは普通、leaf と composite のどちらを扱っているかについて知らない（また、知るべきではない）。したがって、composite を定義するクラスの関数内で場合分けを行う必要がないため、クライアントのコードはわかりやすくなる。<br><br><li><b>新しい種類の component を追加するのが容易になる。</b>新しく定義された Composite クラスや Leaf クラスは、既存の構造やクライアントのコードに自動的に取り込むことができる。したがって、新たに追加された Component クラスに対してクライアント側で変更を行う必要はない。<br><br><li><b>設計を過度に一般化してしまう。</b>つまり、新たな component を容易に追加できるため、composite 内の component を制限することが困難になるという欠点がある。composite 内に、ある特定の component だけを持たせたいこともあるだろう。しかし、Composite パターンを適用する場合には、このような制約を強制するために型チェック機構を用いることができない。その代わりに、実行時にチェックをしなければならなくなる。</ol></font><br><br><br><a name="jissou"><img src="img/00/jissou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Composite パターンを実装する際には、以下にあげる多くの点を考慮に入れなければならない。<br><br><ol><li><b>親オブジェクトへの明示的な参照。</b>子オブジェクトに親オブジェクトへの参照を持たせることにより、composite 構造の走査や管理を簡単にすることができる。つまり、親オブジェクトへの参照により、構造中を上に移動したり、component を削除したりするのが容易になる。また、親オブジェクトへの参照は、<a href="13.html" target="down">Chain Of Responsibility パターン</a>をサポートすることにもなる。<br><font style="text-indent:10pt">　親オブジェクトへの参照は、通常、Component クラスで定義する。これにより、Leaf クラスや Composite クラスは、親オブジェクトへの参照とその参照を扱うオペレーションを継承することができる。<br><font style="text-indent:10pt">　親オブジェクトへの参照を持つようにすると、あるcompositeのすべての子オブジェクトがその composite を親として持つ、という不変の制約が常に満たされていなければならない。これを保証するもっとも簡単な方法は、ある component が composite に追加されるか、あるいはそれから取り除かれるときにのみ、その component の親オブジェクトを変更する、というものである。Composite クラスの Add オペレーションや Remove オペレーションにこれを実装すれば、それらはサブクラスに継承されて、前述の不変の制約は自動的に満たされることになる。<br><br><li><b>component の共有。</b>たとえば、必要なメモリの量を減らすためには、component の共有がしばしば有効である。しかし、1つの component が親オブジェクトを1つしか持てない場合には、component の共有は困難になる。<br><font style="text-indent:10pt">　1つの方法としては、子オブジェクトが複数の親オブジェクトを保持できるようにすることが考えられる。しかし、この場合には、要求を親オブジェクトへ伝える際に曖昧さが生じることになる。<a href="11.html" target="down">Flyweight パターン</a>では、親オブジェクトをまったく保存しないように設計を改訂する方法が示されている。子オブジェクトの状態のいくつか、あるいはすべてを外部から与えられるようにすることにより、親オブジェクトへの要求の送信を避けることができる場合に、このパターンは有効である。<br><br><li><b>Component クラスのインタフェースの最大化。</b>Composite パターンの目的の1つは、使用しているクラスが特定のLeafクラスであるのか Composite クラスであるのかを、クライアントに気付かせないことである。そのために、Componentクラスでは、Composite クラスと Leaf クラスに共通のオペレーションをできるだけ多く定義すべきである。Component クラスは、通常、これらのオペレーションのデフォルトの実装を提供し、サブクラスであるLeafクラスや Composite クラスがこれらをオーバーライドする。<br><font style="text-indent:10pt">　しかしながらこの目的は、クラス階層の設計における原則に矛盾する場合がある。その原則とは、あるクラスはそのサブクラスにとって重要なオペレーションのみを定義すべきであるというものである。Component クラスでサポートされているが、Leaf クラスには無意味なオペレーションも多く存在する。Component クラスでは、これらのオペレーションをデフォルトでどのように実装すればよいのだろうか。<br><font style="text-indent:10pt">　Composite クラスでのみ意味を持つオペレーションを、Component クラスのオペレーションとして宣言し、すべての component のオブジェクトに対して実装するためには、少し工夫が必要である。たとえば、子オブジェクトにアクセスするためのインタフェースは、Composite クラスでは基本的なものであるが、Leaf クラスでは必ずしもそうではない。しかし、もしleafを子オブジェクトを持たない component と見るならば、子オブジェクトをアクセスする Component クラスのオペレーションは、デフォルトで子オブジェクトを1つも返さないオペレーションとして定義しておけばよいことになる。この場合、Leaf クラスはデフォルトの実装を利用し、Composite クラスでは子オブジェクトを返すように再実装することになる。<br><font style="text-indent:10pt">　子オブジェクトを管理するオペレーションにはさらに厄介な問題がある。これについては次項で述べる。<br><br><li><b>子オブジェクトを管理するオペレーションの宣言。</b>Composite クラスは子オブジェクトを扱うための Add オペレーションや Remove オペレーションを実装しているが、これらのオペレーションをどのクラスで宣言するか、ということは Composite パターンの重要な問題である。これらのオペレーションを、Component クラスで宣言して Leaf クラスに対しても意味を持つようにするべきなのか、それとも、Composite クラスとそのサブクラスのみで宣言し、定義するべきなのか。<br><font style="text-indent:10pt">　この決断には、安全性と透過性の間でのトレードオフが伴う。<br><br><ul><li>子オブジェクトを管理するインタフェースをクラス階層の最上位のクラスで定義すると、すべての component を一様に扱えるようになるため、透過性が得られる。しかし、クライアントが leaf に対して AddやRemove などの意味のないオペレーションを要求するかもしれないため、安全性が犠牲になる。<br><br><li>子オブジェクトを管理するインタフェースを Composite クラスで定義すると、C++などの静的に型付けされる言語では、コンパイル時に leaf に対する Add オペレーションや Remove オペレーションが発見されるため、安全性が得られる。しかし、leaf と composite のインタフェースが異なってしまうため、透過性が失われる。</ul><br><font style="text-indent:10pt">　このパターンでは安全性よりも透過性を強調してきた。安全性を重視する場合には、型情報を失うかもしれないが、component を composite に変換しなければならないだろう。しかし、型に関して安全でないキャストに頼ることなくこれを行うにはどうしたらよいのだろうか。<br><font style="text-indent:10pt">　1つの方法は、Component クラスでオペレーション Composite* GetComposite（）を宣言することである。このオペレーションはデフォルトでヌルポインタを返すように定義される。Composite クラスでは、this ポインタを用いて自身を返すオペレーションとして再定義される。<br><br><pre>    class Composite;        class Component {    public:        //...        virtual Composite* GetComposite() { return 0; }    };        class Composite : public Component {    public:        void Add(Component*);        // ...        virtual Composite* GetComposite() { return this; }    };        class Leaf : public Component {        // ...    };</pre><br><br><font style="text-indent:10pt">　この GetComposite オペレーションにより、ある component に、それが composite かどうかを問い合わせることができるようになる。そのため、このオペレーションにより返される composite に対して、Add オペレーションや Remove オペレーションを安全に実行できる。<br><br><pre>    Composite* aComposite = new Composite;    Leaf* aLeaf = new Leaf;        Component* aComponent;    Composite* test;        aComponent = aComposite;    if (test = aComponent->GetComposite()) {        test->Add(new Leaf);    }        aComponent = aLeaf;        if (test = aComponent->GetComposite()) {        test->Add(new Leaf); // will not add leaf    }</pre><br><br><font style="text-indent:10pt">　composite に対する同様のテストは、C++の dynamic-cast を使って行うこともできる。<br><font style="text-indent:10pt">　もちろん、ここでの問題は、すべての component を一様に扱えないことである。つまり、特定のアクションを実行する前に、オブジェクトの型をテストするという状況に後戻りしなければならない。<br><font style="text-indent:10pt">　透過性を得るための唯一の方法は、デフォルトの Add オペレーションと Remove オペレーションを Component クラスで定義することである。すると新たな問題が生じる。すなわち、オブジェクトの追加に失敗する可能性も考慮に入れて Component::Add オペレーションを実装しなければならなくなる。この点について何もしないままにしておくこともできるが、それでは重要な問題を見落とすことになる。つまり、leaf に何かを追加しようとしているのは、おそらくバグを意味しているということである。この場合、Add オペレーションは引数として与えられた component をゴミとして残してしまうことになる。Add オペレーションにこのゴミを削除させることもできるが、それはクライアントにとって予期せぬことになるかもしれない。<br><font style="text-indent:10pt">　通常、component が子オブジェクトを持つことを認められていない場合には Add オペレーションが失敗するようにデフォルトで定義し、Remove オペレーションの引数が component の子オブジェクトでない場合には Remove オペレーションが失敗するようにデフォルトで定義するのが望ましい（これらは、おそらく例外処理として記述されることになる）。<br><font style="text-indent:10pt">　別の方法として、“Remove”の意味を少しだけ変える方法もある。component が親オブジェクトへの参照を保持していれば、親オブジェクトからそれ自身を消去するように Component::Remove を再定義することもできるだろう。しかし、このアプローチでは、Add オペレーションに対して意味の通る解釈がない。<br><br><li><b>Component クラスに component のリストを実装するべきか。</b>子オブジェクトにアクセスしたり管理するオペレーションを宣言している Component クラスに、インスタンス変数として子オブジェクトの集合を定義したくなるかもしれない。しかし、子オブジェクトへのポインタを基底クラスで保持すると、leaf は子オブジェクトを持たないため、各 leaf でスペースの無駄が生じる。leaf が構造内に比較的少数しか存在しない場合にのみ、これは意義がある。<br><br><li><b>子オブジェクトの順番。</b>多くの設計では、composite 内で子オブジェクトの順番を明確にする。前節の Graphic クラスの例では、この順番をウィンドウの前後関係に反映させることもできる。Composite クラスが構文解析木を表す場合は、複合ステートメントが Composite クラスのインスタンスになり、その際、子オブジェクトはプログラムを反映するように順序付けられていなければならない。<br><font style="text-indent:10pt">　子オブジェクトの順番が問題になる場合は、そのシーケンスを扱うため、子オブジェクトのアクセスと管理のためのインタフェースを注意深く設計しなければならない。<a href="16.html" target="down">Iterator パターン</a>はこのためのガイドになる。<br><br><li><b>性能改善のためのキャッシュ。</b>composite 内をしばしば走査したり検索したりする必要がある場合には、Composite クラスは、その子オブジェクトに関する走査や検索のための情報をキャッシュしておくことができる。また Composite クラスは、走査や検索を実際に行った結果やそのための近道を示す情報をキャッシュしておくこともできる。たとえば、「動機」の節の例の Picture クラスでは、その子オブジェクトの境界線をキャッシュしておくことができる。描画や選択の際、Picture オブジェクトは、その子オブジェクトがカレントウィンドウの中に入っていない場合には、境界線をキャッシュすることによりその子オブジェクトに対して描画や検索を行わないようにすることができる。<br><font style="text-indent:10pt">　component に変更が起こった際には、その親オブジェクト内のキャッシュを無効にする必要がある。component がその親オブジェクトを知っていれば、この点はうまく実現できる。そこで、キャッシュを使用する場合には、composite へキャッシュが無効であることを知らせるためのインタフェースを定義する必要がある。<br><br><li><b>component を削除するのは誰か。</b>ガーベッジコレクションをサポートしていない言語では、composite に、自身が削除されるときにその子オブジェクトの削除も一緒に行わせるようにするのが、通常ではもっとも良い。この規則の例外は、leaf が状況に依存しないため多くのオブジェクトで共有されているような場合である。<br><br><li><b>component を保持するためのもっとも良いデータ構造は何か。</b>Composite クラスは子オブジェクトを保持するために、リスト、ツリー、配列、ハッシュテーブルなどさまざまなデータ構造を用いることができる。データ構造の選択は、通常と同様、その効率に依存する。実際、汎用的な目的を持つデータ構造を用いる必要はまったくない。Composite クラスは1つの子オブジェクトに対して1つの変数を持つこともある。その場合には、Composite の各サブクラスで子オブジェクトを管理するためのインタフェースを実装する必要があるのだが。その一例としては、<a href="15.html" target="down">Interpreter パターン</a>を参照してほしい。</ol></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font><br><br><br><a name="sample"><img src="img/00/sample.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　コンピュータやオーディオコンポなどの装置は、部分―全体や包含の階層を用いて組織化できる。たとえば、シャーシはディスクドライブや基板を含み、バスはカードを含み、そしてキャビネットはシャーシやバスを含んでいる。このような構造は Composite パターンを利用して自然にモデル化できる。<br><font style="text-indent:10pt">　Equipment クラスは、部分―全体階層の中のすべての装置のインタフェースを定義する。<br><br><pre>    class Equipment {    public:        virtual ~Equipment();            const char* Name() { return _name; }            virtual Watt Power();        virtual Currency NetPrice();        virtual Currency DiscountPrice();            virtual void Add(Equipment*);        virtual void Remove(Equipment*);        virtual Iterator<Equipment*>* CreateIterator();    protected:        Equipment(const char*);    private:        const char* _name;    };</pre><br><br><font style="text-indent:10pt">　Equipment クラスは、消費電力や価格などの、ある1つの装置の属性値を返すオペレーションを宣言する。これらのオペレーションは、特定の装置に対応するサブクラスで実装される。また Equipment クラスでは、集約内のオブジェクトにアクセスするための Iterator オブジェクト（付録 C を参照）を返す CreateIterator オペレーションが宣言される。このオペレーションは、デフォルトで空の集合に対して iteration を行う NullIterator オブジェクトを返すように実装される。<br><font style="text-indent:10pt">　Equipment のサブクラスには、ディスクドライブや集積回路やスイッチを表す Leaf クラスがある。<br><br><pre>    class FloppyDisk : public Equipment {    public:        FloppyDisk(const char*);        virtual ~FloppyDisk();            virtual Watt Power();        virtual Currency NetPrice();        virtual Currency DiscountPrice();    };</pre><br><br><font style="text-indent:10pt">　CompositeEquipment クラスは、他の装置から構成される装置を表すための基底クラスである。このクラスも、Equipment のサブクラスである。<br><br><pre>    class CompositeEquipment : public Equipment {    public:        virtual ~CompositeEquipment();            virtual Watt Power();        virtual Currency NetPrice();        virtual Currency DiscountPrice();            virtual void Add(Equipment*);        virtual void Remove(Equipment*);        virtual Iterator<Equipment*>* CreateIterator();        protected:        CompositeEquipment(const char*);    private:        List<Equipment*> _equipment;    };</pre><br><br><font style="text-indent:10pt">　CompositeEquipment クラスでは、構成要素をアクセスしたり管理するためのオペレーションが定義される。Add オペレーションや Remove オペレーションは、メンバ-equipment に保持されている装置のリストに対して、それぞれ装置の挿入と削除を行う。CreateIterator オペレーションはこのリストを走査するための iterator（具体的には、ListIterator クラスのインスタンス）を返す。<br><font style="text-indent:10pt">　NetPrice オペレーションのデフォルトの実装では、構成要素の正価を足し合わせるために、CreateIterator オペレーションを用いる。<br><br><pre>    Currency CompositeEquipment::NetPrice () {        Iterator<Equipment*>* i = CreateIterator();        Currency total = 0;            for (i->First(); !i->IsDone(); i->Next()) {            total += i->CurrentItem()->NetPrice();        }        delete i;        return total;    }</pre><br><br><font style="text-indent:10pt">　次に、コンピュータのシャーシを Chassis と呼ばれる CompositeEquipment のサブクラスとして表す。Chassis クラスは、子オブジェクトに関するオペレーションを CompositeEquipment クラスから継承する。<br><br><pre>    class Chassis : public CompositeEquipment {    public:        Chassis(const char*);        virtual ~Chassis();            virtual Watt Power();        virtual Currency NetPrice();        virtual Currency DiscountPrice();    };</pre><br><br><font style="text-indent:10pt">　Cabinet クラスや Bus クラスのような装置も同様の方法で定義できる。この方法で、個々の装置からパーソナルコンピュータ（かなり単純なもの）を組み立てるのに必要なすべてのものを定義できる。<br><br><pre>    Cabinet* cabinet = new Cabinet("PC Cabinet");    Chassis* chassis = new Chassis("PC Chassis");        cabinet->Add(chassis);        Bus* bus = new Bus("MCA Bus");    bus->Add(new Card("16Mbs Token Ring"));        chassis->Add(bus);    chassis->Add(new FloppyDisk("3.5in Floppy"));        cout &lt;&lt; "The net price is " &lt;&lt; chassis->NetPrice() &lt;&lt; endl;</pre></font></font></font></font></font></font></font></font></font><br><br><br><a name="siyou"><img src="img/00/siyou.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　Composite パターンの例は、ほぼすべてのオブジェクト指向システムで見られる。Smalltalk の Model/View/Controller［KP88］における初期の View クラスが Composite クラスであり、ET++（VObjects クラス［WGM88］）や InterViews（Styles クラス［LCI+92］、Graphics クラス［VL88］、Glyphs クラス［CL90］）などの、ほぼすべてのユーザインタフェースツールキットやフレームワークがこのステップに従っている。Model/View/Controller における初期の View クラスは、View クラスの別のインスタンスを子オブジェクトとして管理できるようになっていた（言い換えると、View クラスは Component クラスであり、また Composite クラスでもある）ということは興味深い特徴である。Smalltalk-80の Release4. 0では、この点を、サブクラスとして View クラスや CompositeView クラスを持つ VisualComponent クラスを用いるように改訂している。<br><font style="text-indent:10pt">　RTL Smalltalk コンパイラのフレームワーク［JML92］は、Composite パターンを拡張して用いている。RTLExpression クラスは構文解析木のための Component クラスである。このクラスは、RTLExpression オブジェクトを子として持つ BinaryExpression のようなサブクラスを持つ。これらのクラスを用いて構文解析木の合成構造を定義する。RegisterTransfer クラスは、プログラムの中間形式である Single Static Assignment（SSA）形式のための Component クラスである。RegisterTransfer クラスの Leaf にあたるサブクラスでは、次のような異なるアサインメントを定義する。<br><br><ul><li>2つのレジスタに対してオペレーションを実行し、その結果を3つめのレジスタに格納するプリミティブなアサインメント。<br><br><li>デスティネーションレジスタは用いず、ソースレジスタを用いるアサインメント。これは、レジスタが処理を終えた後に使用されることを示している。<br><br><li>ソースレジスタは用いず、デスティネーションレジスタを用いるアサインメント。これは、レジスタが処理を開始する前に割り当てられることを示している。</ul><br><font style="text-indent:10pt">　もう1つのサブクラス RegisterTransferSet は、複数のレジスタを同時に変更するアサインメントを表すための Composite クラスである。<br><font style="text-indent:10pt">　このパターンのもう1つの例が、金融関係のドメインに見られる。このドメインでは、ポートフォリオが個々の資産を集約する。ポートフォリオを個々の資産のインタフェースに一致する Composite クラスとして実装することで、これらの資産の複雑な集約をサポートできる［BE93］。<br><font style="text-indent:10pt">　<a href="14.html" target="down">Command パターン</a>では、Composite クラスである MacroCommand クラスを用いて、command オブジェクトを順に並べて合成していく方法が述べられている。</font></font></font></font></font><br><br><br><a name="kanren"><img src="img/00/kanren.gif" hspace="10"><br><br><font style="margin-left:40px;text-indent:10pt">　<a href="13.html" target="down">Chain Of Responsibility パターン</a>: 親子関係にあるオブジェクト間のリンクは、<a href="13.html" target="down">Chain Of Responsibility パターン</a>でしばしば使われる。<br><font style="text-indent:10pt">　<a href="09.html" target="down">Decorator パターン</a>: しばしば Composite パターンとともに使われる。decorator と composite を同時に使う場合、通常、これらは共通の親クラスを持つ。そのため decorator は、Add、Remove、GetChild のようなオペレーションで Component クラスのインタフェースをサポートしなければならなくなる。<br><font style="text-indent:10pt">　<a href="11.html" target="down">Flyweight パターン</a>: このパターンにより、component を共有できるようになる。しかし、共有されるオブジェクトは親オブジェクトを参照できなくなる。<br><font style="text-indent:10pt">　<a href="16.html" target="down">Iterator パターン</a>: composite を走査するために使われる。<br><font style="text-indent:10pt">　<a href="23.html" target="down">Visitor パターン</a>: Composite クラスや Leaf クラスに分散しているオペレーションや振る舞いを局所化する。</font></font></font></font></font><br><br><br></body></html>